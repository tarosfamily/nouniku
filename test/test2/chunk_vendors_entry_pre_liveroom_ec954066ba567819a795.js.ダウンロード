(window.webpackJsonp = window.webpackJsonp || []).push([
  [28], {
    "0x0X": function (t, e, r) {
      "use strict";
      e.a = function (t) {
        function k(t, e, r) {
          var i = e.trim().split(d),
            n = (e = i).length,
            a = t.length;
          switch (a) {
          case 0:
          case 1:
            var s = 0;
            for (t = 0 === a ? "" : t[0] + " "; s < n; ++s) e[s] = u(t, e[s], r).trim();
            break;
          default:
            var o = s = 0;
            for (e = []; s < n; ++s)
              for (var l = 0; l < a; ++l) e[o++] = u(t[l] + " ", i[s], r).trim()
          }
          return e
        }

        function u(t, e, r) {
          var i = e.charCodeAt(0);
          switch (i < 33 && (i = (e = e.trim()).charCodeAt(0)), i) {
          case 38:
            return e.replace(n, "$1" + t.trim());
          case 58:
            return t.trim() + e.replace(n, "$1" + t.trim());
          default:
            if (0 < +r && 0 < e.indexOf("\f")) return e.replace(n, (58 === t.charCodeAt(0) ? "" : "$1") + t.trim())
          }
          return t + e
        }

        function C(t, e, r, i) {
          var n = t + ";",
            a = 2 * e + 3 * r + 4 * i;
          if (944 == a) {
            t = n.indexOf(":", 9) + 1;
            var s = n.substring(t, n.length - 1).trim(),
              s = n.substring(0, t).trim() + s + ";";
            return 1 === j || 2 === j && w(s, 1) ? "-webkit-" + s + s : s
          }
          if (0 === j || 2 === j && !w(n, 1)) return n;
          switch (a) {
          case 1015:
            return 97 === n.charCodeAt(10) ? "-webkit-" + n + n : n;
          case 951:
            return 116 === n.charCodeAt(3) ? "-webkit-" + n + n : n;
          case 963:
            return 110 === n.charCodeAt(5) ? "-webkit-" + n + n : n;
          case 1009:
            if (100 !== n.charCodeAt(4)) break;
          case 969:
          case 942:
            return "-webkit-" + n + n;
          case 978:
            return "-webkit-" + n + "-moz-" + n + n;
          case 1019:
          case 983:
            return "-webkit-" + n + "-moz-" + n + "-ms-" + n + n;
          case 883:
            if (45 === n.charCodeAt(8)) return "-webkit-" + n + n;
            if (0 < n.indexOf("image-set(", 11)) return n.replace(v, "$1-webkit-$2") + n;
            break;
          case 932:
            if (45 === n.charCodeAt(4)) switch (n.charCodeAt(5)) {
            case 103:
              return "-webkit-box-" + n.replace("-grow", "") + "-webkit-" + n + "-ms-" + n.replace("grow", "positive") + n;
            case 115:
              return "-webkit-" + n + "-ms-" + n.replace("shrink", "negative") + n;
            case 98:
              return "-webkit-" + n + "-ms-" + n.replace("basis", "preferred-size") + n
            }
            return "-webkit-" + n + "-ms-" + n + n;
          case 964:
            return "-webkit-" + n + "-ms-flex-" + n + n;
          case 1023:
            if (99 !== n.charCodeAt(8)) break;
            return "-webkit-box-pack" + (s = n.substring(n.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify")) + "-webkit-" + n + "-ms-flex-pack" + s + n;
          case 1005:
            return l.test(n) ? n.replace(o, ":-webkit-") + n.replace(o, ":-moz-") + n : n;
          case 1e3:
            switch (e = (s = n.substring(13).trim()).indexOf("-") + 1, s.charCodeAt(0) + s.charCodeAt(e)) {
            case 226:
              s = n.replace(c, "tb");
              break;
            case 232:
              s = n.replace(c, "tb-rl");
              break;
            case 220:
              s = n.replace(c, "lr");
              break;
            default:
              return n
            }
            return "-webkit-" + n + "-ms-" + s + n;
          case 1017:
            if (-1 === n.indexOf("sticky", 9)) break;
          case 975:
            switch (e = (n = t).length - 10, a = (s = (33 === n.charCodeAt(e) ? n.substring(0, e) : n).substring(t.indexOf(":", 7) + 1).trim()).charCodeAt(0) + (0 | s.charCodeAt(7))) {
            case 203:
              if (s.charCodeAt(8) < 111) break;
            case 115:
              n = n.replace(s, "-webkit-" + s) + ";" + n;
              break;
            case 207:
            case 102:
              n = n.replace(s, "-webkit-" + (102 < a ? "inline-" : "") + "box") + ";" + n.replace(s, "-webkit-" + s) + ";" + n.replace(s, "-ms-" + s + "box") + ";" + n
            }
            return n + ";";
          case 938:
            if (45 === n.charCodeAt(5)) switch (n.charCodeAt(6)) {
            case 105:
              return s = n.replace("-items", ""), "-webkit-" + n + "-webkit-box-" + s + "-ms-flex-" + s + n;
            case 115:
              return "-webkit-" + n + "-ms-flex-item-" + n.replace(g, "") + n;
            default:
              return "-webkit-" + n + "-ms-flex-line-pack" + n.replace("align-content", "").replace(g, "") + n
            }
            break;
          case 973:
          case 989:
            if (45 !== n.charCodeAt(3) || 122 === n.charCodeAt(4)) break;
          case 931:
          case 953:
            if (!0 === m.test(t)) return 115 === (s = t.substring(t.indexOf(":") + 1)).charCodeAt(0) ? C(t.replace("stretch", "fill-available"), e, r, i).replace(":fill-available", ":stretch") : n.replace(s, "-webkit-" + s) + n.replace(s, "-moz-" + s.replace("fill-", "")) + n;
            break;
          case 962:
            if (n = "-webkit-" + n + (102 === n.charCodeAt(5) ? "-ms-" + n : "") + n, 211 === r + i && 105 === n.charCodeAt(13) && 0 < n.indexOf("transform", 10)) return n.substring(0, n.indexOf(";", 27) + 1).replace(h, "$1-webkit-$2") + n
          }
          return n
        }

        function w(t, e) {
          var r = t.indexOf(1 === e ? ":" : "{"),
            i = t.substring(0, 3 !== e ? r : 10),
            r = t.substring(r + 1, t.length - 1);
          return s(2 !== e ? i : i.replace(a, "$1"), r, e)
        }

        function x(t, e) {
          var r = C(e, e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2));
          return r !== e + ";" ? r.replace(i, " or ($1)").substring(4) : "(" + e + ")"
        }

        function P(t, e, r, i, n, a, s, o, l, u) {
          for (var h, d = 0, c = e; d < z; ++d) switch (h = p[d].call(f, t, c, r, i, n, a, s, o, l, u)) {
          case void 0:
          case !1:
          case !0:
          case null:
            break;
          default:
            c = h
          }
          if (c !== e) return c
        }

        function e(t) {
          return void 0 !== (t = t.prefix) && (s = null, t ? "function" != typeof t ? j = 1 : (j = 2, s = t) : j = 0), e
        }

        function f(t, e) {
          var r, t = t;
          t.charCodeAt(0) < 33 && (t = t.trim()), t = [t], 0 < z && (void 0 !== (r = P(-1, e, t, t, H, B, 0, 0, 0, 0)) && "string" == typeof r && (e = r));
          e = function t(e, r, i, n, a) {
            for (var s, o, l, u, h, d = 0, c = 0, f = 0, g = 0, m = 0, v = 0, p = l = s = 0, y = 0, E = 0, b = 0, S = 0, _ = i.length, L = _ - 1, T = "", A = "", R = "", D = ""; y < _;) {
              if (o = i.charCodeAt(y), y === L && 0 !== c + g + f + d && (0 !== c && (o = 47 === c ? 10 : 47), g = f = d = 0, _++, L++), 0 === c + g + f + d) {
                if (y === L && (0 < E && (T = T.replace(F, "")), 0 < T.trim().length)) {
                  switch (o) {
                  case 32:
                  case 9:
                  case 59:
                  case 13:
                  case 10:
                    break;
                  default:
                    T += i.charAt(y)
                  }
                  o = 59
                }
                switch (o) {
                case 123:
                  for (s = (T = T.trim()).charCodeAt(0), l = 1, S = ++y; y < _;) {
                    switch (o = i.charCodeAt(y)) {
                    case 123:
                      l++;
                      break;
                    case 125:
                      l--;
                      break;
                    case 47:
                      switch (o = i.charCodeAt(y + 1)) {
                      case 42:
                      case 47:
                        t: {
                          for (p = y + 1; p < L; ++p) switch (i.charCodeAt(p)) {
                          case 47:
                            if (42 !== o || 42 !== i.charCodeAt(p - 1) || y + 2 === p) break;
                            y = p + 1;
                            break t;
                          case 10:
                            if (47 === o) {
                              y = p + 1;
                              break t
                            }
                          }
                          y = p
                        }
                      }
                      break;
                    case 91:
                      o++;
                    case 40:
                      o++;
                    case 34:
                    case 39:
                      for (; y++ < L && i.charCodeAt(y) !== o;);
                    }
                    if (0 === l) break;
                    y++
                  }
                  if (l = i.substring(S, y), 0 === s && (s = (T = T.replace(O, "").trim()).charCodeAt(0)), 64 === s) {
                    switch (0 < E && (T = T.replace(F, "")), o = T.charCodeAt(1)) {
                    case 100:
                    case 109:
                    case 115:
                    case 45:
                      E = r;
                      break;
                    default:
                      E = V
                    }
                    if (S = (l = t(r, E, l, o, a + 1)).length, 0 < z && (h = P(3, l, E = k(V, T, b), r, H, B, S, o, a, n), T = E.join(""), void 0 !== h && 0 === (S = (l = h.trim()).length) && (o = 0, l = "")), 0 < S) switch (o) {
                    case 115:
                      T = T.replace(U, x);
                    case 100:
                    case 109:
                    case 45:
                      l = T + "{" + l + "}";
                      break;
                    case 107:
                      l = (T = T.replace(I, "$1 $2")) + "{" + l + "}", l = 1 === j || 2 === j && w("@" + l, 3) ? "@-webkit-" + l + "@" + l : "@" + l;
                      break;
                    default:
                      l = T + l, 112 === n && (A += l, l = "")
                    } else l = ""
                  } else l = t(r, k(r, T, b), l, n, a + 1);
                  R += l, l = b = E = p = s = 0, T = "", o = i.charCodeAt(++y);
                  break;
                case 125:
                case 59:
                  if (1 < (S = (T = (0 < E ? T.replace(F, "") : T).trim()).length)) switch (0 === p && (s = T.charCodeAt(0), 45 === s || 96 < s && s < 123) && (S = (T = T.replace(" ", ":")).length), 0 < z && void 0 !== (h = P(1, T, r, e, H, B, A.length, n, a, n)) && 0 === (S = (T = h.trim()).length) && (T = "\0\0"), s = T.charCodeAt(0), o = T.charCodeAt(1), s) {
                  case 0:
                    break;
                  case 64:
                    if (105 === o || 99 === o) {
                      D += T + i.charAt(y);
                      break
                    }
                  default:
                    58 !== T.charCodeAt(S - 1) && (A += C(T, s, o, T.charCodeAt(2)))
                  }
                  b = E = p = s = 0, T = "", o = i.charCodeAt(++y)
                }
              }
              switch (o) {
              case 13:
              case 10:
                47 === c ? c = 0 : 0 === 1 + s && 107 !== n && 0 < T.length && (E = 1, T += "\0"), 0 < z * q && P(0, T, r, e, H, B, A.length, n, a, n), B = 1, H++;
                break;
              case 59:
              case 125:
                if (0 === c + g + f + d) {
                  B++;
                  break
                }
              default:
                switch (B++, u = i.charAt(y), o) {
                case 9:
                case 32:
                  if (0 === g + d + c) switch (m) {
                  case 44:
                  case 58:
                  case 9:
                  case 32:
                    u = "";
                    break;
                  default:
                    32 !== o && (u = " ")
                  }
                  break;
                case 0:
                  u = "\\0";
                  break;
                case 12:
                  u = "\\f";
                  break;
                case 11:
                  u = "\\v";
                  break;
                case 38:
                  0 === g + c + d && (E = b = 1, u = "\f" + u);
                  break;
                case 108:
                  if (0 === g + c + d + G && 0 < p) switch (y - p) {
                  case 2:
                    112 === m && 58 === i.charCodeAt(y - 3) && (G = m);
                  case 8:
                    111 === v && (G = v)
                  }
                  break;
                case 58:
                  0 === g + c + d && (p = y);
                  break;
                case 44:
                  0 === c + f + g + d && (E = 1, u += "\r");
                  break;
                case 34:
                case 39:
                  0 === c && (g = g === o ? 0 : 0 === g ? o : g);
                  break;
                case 91:
                  0 === g + c + f && d++;
                  break;
                case 93:
                  0 === g + c + f && d--;
                  break;
                case 41:
                  0 === g + c + d && f--;
                  break;
                case 40:
                  0 === g + c + d && (0 === s && (2 * m + 3 * v == 533 || (s = 1)), f++);
                  break;
                case 64:
                  0 === c + f + g + d + p + l && (l = 1);
                  break;
                case 42:
                case 47:
                  if (!(0 < g + d + f)) switch (c) {
                  case 0:
                    switch (2 * o + 3 * i.charCodeAt(y + 1)) {
                    case 235:
                      c = 47;
                      break;
                    case 220:
                      S = y, c = 42
                    }
                    break;
                  case 42:
                    47 === o && 42 === m && S + 2 !== y && (33 === i.charCodeAt(S + 2) && (A += i.substring(S, y + 1)), u = "", c = 0)
                  }
                }
                0 === c && (T += u)
              }
              v = m, m = o, y++
            }
            if (0 < (S = A.length)) {
              if (E = r, 0 < z && void 0 !== (h = P(2, A, E, e, H, B, S, n, a, n)) && 0 === (A = h).length) return D + A + R;
              if (A = E.join(",") + "{" + A + "}", 0 != j * G) {
                switch (2 !== j || w(A, 2) || (G = 0), G) {
                case 111:
                  A = A.replace(N, ":-moz-$1") + A;
                  break;
                case 112:
                  A = A.replace(M, "::-webkit-input-$1") + A.replace(M, "::-moz-$1") + A.replace(M, ":-ms-input-$1") + A
                }
                G = 0
              }
            }
            return D + A + R
          }(V, t, e, 0, 0);
          return 0 < z && (void 0 !== (r = P(-2, e, t, t, H, B, e.length, 0, 0, 0)) && (e = r)), G = 0, B = H = 1, e
        }
        var O = /^\0+/g,
          F = /[\0\r\f]/g,
          o = /: */g,
          l = /zoo|gra/,
          h = /([,: ])(transform)/g,
          d = /,\r+?/g,
          n = /([\t\r\n ])*\f?&/g,
          I = /@(k\w+)\s*(\S*)\s*/,
          M = /::(place)/g,
          N = /:(read-only)/g,
          c = /[svh]\w+-[tblr]{2}/,
          U = /\(\s*(.*)\s*\)/g,
          i = /([\s\S]*?);/g,
          g = /-self|flex-/g,
          a = /[^]*?(:[rp][el]a[\w-]+)[^]*/,
          m = /stretch|:\s*\w+\-(?:conte|avail)/,
          v = /([^-])(image-set\()/,
          B = 1,
          H = 1,
          G = 0,
          j = 1,
          V = [],
          p = [],
          z = 0,
          s = null,
          q = 0;
        return f.use = function t(e) {
          switch (e) {
          case void 0:
          case null:
            z = p.length = 0;
            break;
          default:
            if ("function" == typeof e) p[z++] = e;
            else if ("object" == typeof e)
              for (var r = 0, i = e.length; r < i; ++r) t(e[r]);
            else q = 0 | !!e
          }
          return t
        }, f.set = e, void 0 !== t && e(t), f
      }
    },
    "9uj6": function (t, e, r) {
      "use strict";
      r.r(e);
      var i = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
        r = function (e) {
          var r = {};
          return function (t) {
            return void 0 === r[t] && (r[t] = e(t)), r[t]
          }
        }(function (t) {
          return i.test(t) || 111 === t.charCodeAt(0) && 110 === t.charCodeAt(1) && t.charCodeAt(2) < 91
        });
      e.default = r
    },
    Gytx: function (t, e) {
      t.exports = function (t, e, r, i) {
        if (void 0 !== (u = r ? r.call(i, t, e) : void 0)) return !!u;
        if (t === e) return !0;
        if ("object" != typeof t || !t || "object" != typeof e || !e) return !1;
        var n = Object.keys(t),
          a = Object.keys(e);
        if (n.length !== a.length) return !1;
        for (var s = Object.prototype.hasOwnProperty.bind(e), o = 0; o < n.length; o++) {
          var l = n[o];
          if (!s(l)) return !1;
          var u, h = t[l],
            d = e[l];
          if (!1 === (u = r ? r.call(i, h, d, l) : void 0) || void 0 === u && h !== d) return !1
        }
        return !0
      }
    },
    ME5O: function (t, e, r) {
      "use strict";
      e.a = {
        animationIterationCount: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
      }
    },
    WSuF: function (t, e, r) {
      (function (ce) {
        t.exports = function (A, R) {
          "use strict";

          function t(t) {
            return t && "object" == typeof t && "default" in t ? t : {
              default: t
            }
          }
          var D = t(A),
            e = t(R);

          function i(e, t) {
            var r, i = Object.keys(e);
            return Object.getOwnPropertySymbols && (r = Object.getOwnPropertySymbols(e), t && (r = r.filter(function (t) {
              return Object.getOwnPropertyDescriptor(e, t).enumerable
            })), i.push.apply(i, r)), i
          }

          function l(e) {
            for (var t = 1; t < arguments.length; t++) {
              var r = null != arguments[t] ? arguments[t] : {};
              t % 2 ? i(Object(r), !0).forEach(function (t) {
                u(e, t, r[t])
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : i(Object(r)).forEach(function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
              })
            }
            return e
          }

          function s(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
          }

          function n(t, e) {
            for (var r = 0; r < e.length; r++) {
              var i = e[r];
              i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
            }
          }

          function o(t, e, r) {
            return e && n(t.prototype, e), r && n(t, r), t
          }

          function u(t, e, r) {
            return e in t ? Object.defineProperty(t, e, {
              value: r,
              enumerable: !0,
              configurable: !0,
              writable: !0
            }) : t[e] = r, t
          }

          function h(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
              constructor: {
                value: t,
                writable: !0,
                configurable: !0
              }
            }), e && r(t, e)
          }

          function a(t) {
            return (a = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
              return t.__proto__ || Object.getPrototypeOf(t)
            })(t)
          }

          function r(t, e) {
            return (r = Object.setPrototypeOf || function (t, e) {
              return t.__proto__ = e, t
            })(t, e)
          }

          function d(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
          }

          function c(r) {
            var i = function () {
              if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
              if (Reflect.construct.sham) return !1;
              if ("function" == typeof Proxy) return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0
              } catch (t) {
                return !1
              }
            }();
            return function () {
              var t, e = a(r);
              return t = i ? (t = a(this).constructor, Reflect.construct(e, arguments, t)) : e.apply(this, arguments), e = this, !(t = t) || "object" != typeof t && "function" != typeof t ? d(e) : t
            }
          }

          function f(t, e, r) {
            return (f = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function (t, e, r) {
              t = function (t, e) {
                for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = a(t)););
                return t
              }(t, e);
              if (t) {
                e = Object.getOwnPropertyDescriptor(t, e);
                return e.get ? e.get.call(r) : e.value
              }
            })(t, e, r || t)
          }

          function g(t, e) {
            return e = e || t.slice(0), Object.freeze(Object.defineProperties(t, {
              raw: {
                value: Object.freeze(e)
              }
            }))
          }

          function k(t, e) {
            return function (t) {
              if (Array.isArray(t)) return t
            }(t) || function (t, e) {
              var r = t && ("undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]);
              if (null != r) {
                var i, n, a = [],
                  s = !0,
                  o = !1;
                try {
                  for (r = r.call(t); !(s = (i = r.next()).done) && (a.push(i.value), !e || a.length !== e); s = !0);
                } catch (t) {
                  o = !0, n = t
                } finally {
                  try {
                    s || null == r.return || r.return()
                  } finally {
                    if (o) throw n
                  }
                }
                return a
              }
            }(t, e) || v(t, e) || function () {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
          }

          function m(t) {
            return function (t) {
              if (Array.isArray(t)) return p(t)
            }(t) || function (t) {
              if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
            }(t) || v(t) || function () {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
            }()
          }

          function v(t, e) {
            if (t) {
              if ("string" == typeof t) return p(t, e);
              var r = Object.prototype.toString.call(t).slice(8, -1);
              return "Map" === (r = "Object" === r && t.constructor ? t.constructor.name : r) || "Set" === r ? Array.from(t) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? p(t, e) : void 0
            }
          }

          function p(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var r = 0, i = new Array(e); r < e; r++) i[r] = t[r];
            return i
          }
          var y = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof ce ? ce : "undefined" != typeof self ? self : {};

          function E(t) {
            return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
          }

          function b(t) {
            var e = {
              exports: {}
            };
            return t(e, e.exports), e.exports
          }
          var S = E(b(function (t, e) {
              "undefined" != typeof window && (t.exports = function (r) {
                var i = {};

                function n(t) {
                  if (i[t]) return i[t].exports;
                  var e = i[t] = {
                    i: t,
                    l: !1,
                    exports: {}
                  };
                  return r[t].call(e.exports, e, e.exports, n), e.l = !0, e.exports
                }
                return n.m = r, n.c = i, n.d = function (t, e, r) {
                  n.o(t, e) || Object.defineProperty(t, e, {
                    enumerable: !0,
                    get: r
                  })
                }, n.r = function (t) {
                  "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                    value: "Module"
                  }), Object.defineProperty(t, "__esModule", {
                    value: !0
                  })
                }, n.t = function (e, t) {
                  if (1 & t && (e = n(e)), 8 & t) return e;
                  if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                  var r = Object.create(null);
                  if (n.r(r), Object.defineProperty(r, "default", {
                      enumerable: !0,
                      value: e
                    }), 2 & t && "string" != typeof e)
                    for (var i in e) n.d(r, i, function (t) {
                      return e[t]
                    }.bind(null, i));
                  return r
                }, n.n = function (t) {
                  var e = t && t.__esModule ? function () {
                    return t.default
                  } : function () {
                    return t
                  };
                  return n.d(e, "a", e), e
                }, n.o = function (t, e) {
                  return Object.prototype.hasOwnProperty.call(t, e)
                }, n.p = "/dist/", n(n.s = 18)
              }([function (t, e, r) {
                var i;
                r.d(e, "a", function () {
                  return i
                }), (e = i = i || {}).MEDIA_ATTACHING = "hlsMediaAttaching", e.MEDIA_ATTACHED = "hlsMediaAttached", e.MEDIA_DETACHING = "hlsMediaDetaching", e.MEDIA_DETACHED = "hlsMediaDetached", e.BUFFER_RESET = "hlsBufferReset", e.BUFFER_CODECS = "hlsBufferCodecs", e.BUFFER_CREATED = "hlsBufferCreated", e.BUFFER_APPENDING = "hlsBufferAppending", e.BUFFER_APPENDED = "hlsBufferAppended", e.BUFFER_EOS = "hlsBufferEos", e.BUFFER_FLUSHING = "hlsBufferFlushing", e.BUFFER_FLUSHED = "hlsBufferFlushed", e.MANIFEST_LOADING = "hlsManifestLoading", e.MANIFEST_LOADED = "hlsManifestLoaded", e.MANIFEST_PARSED = "hlsManifestParsed", e.LEVEL_SWITCHING = "hlsLevelSwitching", e.LEVEL_SWITCHED = "hlsLevelSwitched", e.LEVEL_LOADING = "hlsLevelLoading", e.LEVEL_LOADED = "hlsLevelLoaded", e.LEVEL_UPDATED = "hlsLevelUpdated", e.LEVEL_PTS_UPDATED = "hlsLevelPtsUpdated", e.LEVELS_UPDATED = "hlsLevelsUpdated", e.AUDIO_TRACKS_UPDATED = "hlsAudioTracksUpdated", e.AUDIO_TRACK_SWITCHING = "hlsAudioTrackSwitching", e.AUDIO_TRACK_SWITCHED = "hlsAudioTrackSwitched", e.AUDIO_TRACK_LOADING = "hlsAudioTrackLoading", e.AUDIO_TRACK_LOADED = "hlsAudioTrackLoaded", e.SUBTITLE_TRACKS_UPDATED = "hlsSubtitleTracksUpdated", e.SUBTITLE_TRACKS_CLEARED = "hlsSubtitleTracksCleared", e.SUBTITLE_TRACK_SWITCH = "hlsSubtitleTrackSwitch", e.SUBTITLE_TRACK_LOADING = "hlsSubtitleTrackLoading", e.SUBTITLE_TRACK_LOADED = "hlsSubtitleTrackLoaded", e.SUBTITLE_FRAG_PROCESSED = "hlsSubtitleFragProcessed", e.CUES_PARSED = "hlsCuesParsed", e.NON_NATIVE_TEXT_TRACKS_FOUND = "hlsNonNativeTextTracksFound", e.INIT_PTS_FOUND = "hlsInitPtsFound", e.FRAG_LOADING = "hlsFragLoading", e.FRAG_LOAD_EMERGENCY_ABORTED = "hlsFragLoadEmergencyAborted", e.FRAG_LOADED = "hlsFragLoaded", e.FRAG_DECRYPTED = "hlsFragDecrypted", e.FRAG_PARSING_INIT_SEGMENT = "hlsFragParsingInitSegment", e.FRAG_PARSING_USERDATA = "hlsFragParsingUserdata", e.FRAG_PARSING_METADATA = "hlsFragParsingMetadata", e.FRAG_PARSED = "hlsFragParsed", e.FRAG_BUFFERED = "hlsFragBuffered", e.FRAG_CHANGED = "hlsFragChanged", e.FPS_DROP = "hlsFpsDrop", e.FPS_DROP_LEVEL_CAPPING = "hlsFpsDropLevelCapping", e.ERROR = "hlsError", e.DESTROYING = "hlsDestroying", e.KEY_LOADING = "hlsKeyLoading", e.KEY_LOADED = "hlsKeyLoaded", e.LIVE_BACK_BUFFER_REACHED = "hlsLiveBackBufferReached", e.MILDOM_STALL_RECOVER = "hlsMildomStallRecover", e.MILDOM_LATENCY_CONTROL = "hlsMildomLatencyControl"
              }, function (t, e, r) {
                r.d(e, "a", function () {
                  return s
                }), r.d(e, "b", function () {
                  return o
                });
                var n = function () {},
                  i = {
                    trace: n,
                    debug: n,
                    log: n,
                    warn: n,
                    info: n,
                    error: n
                  },
                  a = i;

                function s(t) {
                  if (self.console && !0 === t || "object" == typeof t) {
                    ! function (r) {
                      for (var t = arguments.length, e = new Array(1 < t ? t - 1 : 0), i = 1; i < t; i++) e[i - 1] = arguments[i];
                      e.forEach(function (t) {
                        var e;
                        a[t] = r[t] ? r[t].bind(r) : (e = t, (t = self.console[e]) ? t.bind(self.console, "[" + e + "] >") : n)
                      })
                    }(t, "debug", "log", "info", "warn", "error");
                    try {
                      a.log()
                    } catch (t) {
                      a = i
                    }
                  } else a = i
                }
                var o = i
              }, function (t, e, r) {
                var i, n;
                r.d(e, "b", function () {
                  return i
                }), r.d(e, "a", function () {
                  return n
                }), (e = i = i || {}).NETWORK_ERROR = "networkError", e.MEDIA_ERROR = "mediaError", e.KEY_SYSTEM_ERROR = "keySystemError", e.MUX_ERROR = "muxError", e.OTHER_ERROR = "otherError", (e = n = n || {}).KEY_SYSTEM_NO_KEYS = "keySystemNoKeys", e.KEY_SYSTEM_NO_ACCESS = "keySystemNoAccess", e.KEY_SYSTEM_NO_SESSION = "keySystemNoSession", e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = "keySystemLicenseRequestFailed", e.KEY_SYSTEM_NO_INIT_DATA = "keySystemNoInitData", e.MANIFEST_LOAD_ERROR = "manifestLoadError", e.MANIFEST_LOAD_TIMEOUT = "manifestLoadTimeOut", e.MANIFEST_PARSING_ERROR = "manifestParsingError", e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = "manifestIncompatibleCodecsError", e.LEVEL_EMPTY_ERROR = "levelEmptyError", e.LEVEL_LOAD_ERROR = "levelLoadError", e.LEVEL_LOAD_TIMEOUT = "levelLoadTimeOut", e.LEVEL_SWITCH_ERROR = "levelSwitchError", e.AUDIO_TRACK_LOAD_ERROR = "audioTrackLoadError", e.AUDIO_TRACK_LOAD_TIMEOUT = "audioTrackLoadTimeOut", e.FRAG_LOAD_ERROR = "fragLoadError", e.FRAG_LOAD_TIMEOUT = "fragLoadTimeOut", e.FRAG_DECRYPT_ERROR = "fragDecryptError", e.FRAG_PARSING_ERROR = "fragParsingError", e.REMUX_ALLOC_ERROR = "remuxAllocError", e.KEY_LOAD_ERROR = "keyLoadError", e.KEY_LOAD_TIMEOUT = "keyLoadTimeOut", e.BUFFER_ADD_CODEC_ERROR = "bufferAddCodecError", e.BUFFER_APPEND_ERROR = "bufferAppendError", e.BUFFER_APPENDING_ERROR = "bufferAppendingError", e.BUFFER_STALLED_ERROR = "bufferStalledError", e.BUFFER_FULL_ERROR = "bufferFullError", e.BUFFER_SEEK_OVER_HOLE = "bufferSeekOverHole", e.BUFFER_NUDGE_ON_STALL = "bufferNudgeOnStall", e.INTERNAL_EXCEPTION = "internalException", e.INTERNAL_ABORTED = "aborted"
              }, function (t, e, r) {
                r.d(e, "a", function () {
                  return i
                });
                var i = Number.isFinite || function (t) {
                  return "number" == typeof t && isFinite(t)
                }
              }, function (t, e, r) {
                r.d(e, "b", function () {
                  return v
                }), r.d(e, "g", function () {
                  return p
                }), r.d(e, "f", function () {
                  return n
                }), r.d(e, "d", function () {
                  return o
                }), r.d(e, "c", function () {
                  return l
                }), r.d(e, "e", function () {
                  return d
                }), r.d(e, "h", function () {
                  return c
                }), r.d(e, "a", function () {
                  return f
                });
                var i = r(7),
                  g = r(5),
                  a = Math.pow(2, 32) - 1,
                  u = [].push;

                function h(t) {
                  return String.fromCharCode.apply(null, t)
                }

                function m(t, e) {
                  t.data && (e += t.start, t = t.data);
                  e = t[e] << 24 | t[e + 1] << 16 | t[e + 2] << 8 | t[e + 3];
                  return e < 0 ? 4294967296 + e : e
                }

                function s(t, e, r) {
                  t.data && (e += t.start, t = t.data), t[e] = r >> 24, t[e + 1] = r >> 16 & 255, t[e + 2] = r >> 8 & 255, t[e + 3] = 255 & r
                }

                function v(t, e) {
                  var r, i, n = [];
                  if (!e.length) return n;
                  for (var a = ("data" in t ? (r = t.data, i = t.start, t.end) : (i = 0, (r = t).byteLength)), s = i; s < a;) {
                    var o = m(r, s),
                      l = 1 < o ? s + o : a;
                    h(r.subarray(s + 4, s + 8)) === e[0] && (1 === e.length ? n.push({
                      data: r,
                      start: s + 8,
                      end: l
                    }) : (o = v({
                      data: r,
                      start: s + 8,
                      end: l
                    }, e.slice(1))).length && u.apply(n, o)), s = l
                  }
                  return n
                }

                function p(t) {
                  var e = v(t, ["moov"]),
                    e = e ? e[0] : null,
                    e = e ? e.end : null,
                    t = v(t, ["sidx"]);
                  if (!t || !t[0]) return null;
                  var r = [],
                    i = t[0],
                    t = i.data[0],
                    n = 0 === t ? 8 : 16,
                    a = m(i, n);
                  n += 4, n += 0 === t ? 8 : 16;
                  var s = i.end + 0,
                    o = function (t, e) {
                      t.data && (e += t.start, t = t.data);
                      e = t[e] << 8 | t[e + 1];
                      return e < 0 ? 65536 + e : e
                    }(i, n += 2);
                  n += 2;
                  for (var l = 0; l < o; l++) {
                    var u = n,
                      h = m(i, u);
                    u += 4;
                    var d = 2147483647 & h;
                    if (1 == (2147483648 & h) >>> 31) return void console.warn("SIDX has hierarchical references (not supported)");
                    h = m(i, u);
                    u += 4, r.push({
                      referenceSize: d,
                      subsegmentDuration: h,
                      info: {
                        duration: h / a,
                        start: s,
                        end: s + d - 1
                      }
                    }), s += d, n = u += 4
                  }
                  return {
                    earliestPresentationTime: 0,
                    timescale: a,
                    version: t,
                    referencesCount: o,
                    references: r,
                    moovEndOffset: e
                  }
                }

                function n(t) {
                  for (var e = [], r = v(t, ["moov", "trak"]), i = 0; i < r.length; i++) {
                    var n, a, s, o = r[i],
                      l = v(o, ["tkhd"])[0];
                    l && (n = m(l, 0 === l.data[l.start] ? 12 : 20), (s = v(o, ["mdia", "mdhd"])[0]) && (a = m(s, 0 === s.data[s.start] ? 12 : 20), (l = v(o, ["mdia", "hdlr"])[0]) && (s = h(l.data.subarray(l.start + 8, l.start + 12)), (l = {
                      soun: g.a.AUDIO,
                      vide: g.a.VIDEO
                    }[s]) && (s = void 0, (o = v(o, ["mdia", "minf", "stbl", "stsd"])).length && (s = h((o = o[0]).data.subarray(o.start + 12, o.start + 16))), e[n] = {
                      timescale: a,
                      type: l
                    }, e[l] = {
                      timescale: a,
                      id: n,
                      codec: s
                    }))))
                  }
                  return e
                }

                function o(r, t) {
                  t = v(t, ["moof", "traf"]), t = [].concat.apply([], t.map(function (e) {
                    return v(e, ["tfhd"]).map(function (t) {
                      t = m(t, 4), t = r[t].timescale || 9e4;
                      return v(e, ["tfdt"]).map(function (t) {
                        var e = t.data[t.start],
                          r = m(t, 4);
                        return 1 === e && (r *= Math.pow(2, 32), r += m(t, 8)), r
                      })[0] / t
                    })
                  })), t = Math.min.apply(null, t);
                  return isFinite(t) ? t : 0
                }

                function l(t, e) {
                  for (var r = 0, i = 0, n = 0, a = v(t, ["moof", "traf"]), s = 0; s < a.length; s++) {
                    var o = a[s],
                      l = v(o, ["tfhd"])[0],
                      u = v(o, ["trun"]),
                      o = m(l, 0),
                      h = void 0;
                    8 & o && (h = m(l, 2 & o ? 12 : 8));
                    for (var d = 0; d < u.length; d++) {
                      var r = h ? h * m(u[d], 4) : function (t) {
                          var e = m(t, 0),
                            r = 8;
                          1 & e && (r += 4), 4 & e && (r += 4);
                          for (var i = 0, n = m(t, 4), a = 0; a < n; a++) 256 & e && (i += m(t, r), r += 4), 512 & e && (r += 4), 1024 & e && (r += 4), 2048 & e && (r += 4);
                          return i
                        }(u[d]),
                        c = e[m(l, 4)],
                        f = c.timescale || 9e4;
                      i += r / f, c && c.type === g.a.VIDEO && (n += r / f)
                    }
                  }
                  if (0 === i) {
                    t = p(t);
                    if (null != t && t.references) return t.references.reduce(function (t, e) {
                      return t + e.info.duration || 0
                    }, 0)
                  }
                  return n || i
                }

                function d(r, t, n) {
                  v(t, ["moof", "traf"]).map(function (e) {
                    return v(e, ["tfhd"]).map(function (t) {
                      var t = m(t, 4),
                        i = r[t].timescale || 9e4;
                      v(e, ["tfdt"]).map(function (t) {
                        var e = t.data[t.start],
                          r = m(t, 4);
                        0 === e ? s(t, 4, r - n * i) : (r *= Math.pow(2, 32), r += m(t, 8), r -= n * i, r = Math.max(r, 0), e = Math.floor(r / (a + 1)), r = Math.floor(r % (a + 1)), s(t, 4, e), s(t, 8, r))
                      })
                    })
                  })
                }

                function c(t) {
                  var e = {
                      valid: null,
                      remainder: null
                    },
                    r = v(t, ["moof"]);
                  if (!r) return e;
                  if (r.length < 2) return e.remainder = t, e;
                  r = r[r.length - 1];
                  return e.valid = Object(i.a)(t, 0, r.start - 8), e.remainder = Object(i.a)(t, r.start - 8), e
                }

                function f(t, e) {
                  var r = new Uint8Array(t.length + e.length);
                  return r.set(t), r.set(e, t.length), r
                }
              }, function (t, e, r) {
                r.d(e, "a", function () {
                  return n
                }), r.d(e, "c", function () {
                  return f
                }), r.d(e, "b", function () {
                  return g
                });
                var n, a = r(3),
                  i = r(11),
                  s = r(1),
                  o = r(14),
                  l = r(9);

                function u(t, e) {
                  t.prototype = Object.create(e.prototype), (t.prototype.constructor = t).__proto__ = e
                }

                function h(t, e) {
                  for (var r = 0; r < e.length; r++) {
                    var i = e[r];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                  }
                }

                function d(t, e, r) {
                  return e && h(t.prototype, e), r && h(t, r), t
                }(r = n = n || {}).AUDIO = "audio", r.VIDEO = "video", r.AUDIOVIDEO = "audiovideo";
                var c, r = (v.prototype.setByteRange = function (t, e) {
                    var r = t.split("@", 2),
                      t = [];
                    1 === r.length ? t[0] = e ? e.byteRangeEndOffset : 0 : t[0] = parseInt(r[1]), t[1] = parseInt(r[0]) + t[0], this._byteRange = t
                  }, d(v, [{
                    key: "byteRange",
                    get: function () {
                      return this._byteRange || []
                    }
                  }, {
                    key: "byteRangeStartOffset",
                    get: function () {
                      return this.byteRange[0]
                    }
                  }, {
                    key: "byteRangeEndOffset",
                    get: function () {
                      return this.byteRange[1]
                    }
                  }, {
                    key: "url",
                    get: function () {
                      return !this._url && this.baseurl && this.relurl && (this._url = Object(i.buildAbsoluteURL)(this.baseurl, this.relurl, {
                        alwaysNormalize: !0
                      })), this._url || ""
                    },
                    set: function (t) {
                      this._url = t
                    }
                  }]), v),
                  f = function (i) {
                    function t(t, e) {
                      var r;
                      return (r = i.call(this, e) || this)._decryptdata = null, r.elementaryStreams = ((e = {})[n.AUDIO] = null, e[n.VIDEO] = null, e[n.AUDIOVIDEO] = null, e), r.rawProgramDateTime = null, r.programDateTime = null, r.tagList = [], r.duration = 0, r.sn = 0, r.levelkey = void 0, r.type = void 0, r.loader = null, r.level = -1, r.cc = 0, r.startPTS = void 0, r.endPTS = void 0, r.appendedPTS = void 0, r.startDTS = void 0, r.endDTS = void 0, r.start = 0, r.backtracked = !1, r.deltaPTS = void 0, r.maxStartPTS = void 0, r.minEndPTS = void 0, r.stats = new l.a, r.urlId = 0, r.data = void 0, r.bitrateTest = !1, r.dropped = 0, r.title = null, r.prefetch = !1, r.type = t, r
                    }
                    u(t, i);
                    var e = t.prototype;
                    return e.createInitializationVector = function (t) {
                      for (var e = new Uint8Array(16), r = 12; r < 16; r++) e[r] = t >> 8 * (15 - r) & 255;
                      return e
                    }, e.setDecryptDataFromLevelKey = function (t, e) {
                      var r = t;
                      return "AES-128" === (null == t ? void 0 : t.method) && t.uri && !t.iv && ((r = o.a.fromURI(t.uri)).method = t.method, r.iv = this.createInitializationVector(e), r.keyFormat = "identity"), r
                    }, e.setElementaryStreamInfo = function (t, e, r, i, n) {
                      var a = this.elementaryStreams,
                        s = a[t];
                      s ? (s.startPTS = Math.min(s.startPTS, e), s.endPTS = Math.max(s.endPTS, r), s.startDTS = Math.min(s.startDTS, i), s.endDTS = Math.max(s.endDTS, n)) : a[t] = {
                        startPTS: e,
                        endPTS: r,
                        startDTS: i,
                        endDTS: n
                      }
                    }, d(t, [{
                      key: "decryptdata",
                      get: function () {
                        return this.levelkey || this._decryptdata ? (!this._decryptdata && this.levelkey && ("number" != typeof (t = this.sn) && (this.levelkey && "AES-128" === this.levelkey.method && !this.levelkey.iv && s.b.warn('missing IV for initialization segment with method="' + this.levelkey.method + '" - compliance issue'), t = 0), this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, t)), this._decryptdata) : null;
                        var t
                      }
                    }, {
                      key: "end",
                      get: function () {
                        return this.start + this.duration
                      }
                    }, {
                      key: "endProgramDateTime",
                      get: function () {
                        if (null === this.programDateTime) return null;
                        if (!Object(a.a)(this.programDateTime)) return null;
                        var t = Object(a.a)(this.duration) ? this.duration : 0;
                        return this.programDateTime + 1e3 * t
                      }
                    }, {
                      key: "encrypted",
                      get: function () {
                        var t;
                        return !(null === (t = this.decryptdata) || void 0 === t || !t.keyFormat || !this.decryptdata.uri)
                      }
                    }]), t
                  }(r),
                  g = (u(m, c = r), d(m, [{
                    key: "start",
                    get: function () {
                      return this.fragment.start + this.fragOffset
                    }
                  }, {
                    key: "end",
                    get: function () {
                      return this.start + this.duration
                    }
                  }]), m);

                function m(t, e, r, i, n) {
                  (r = c.call(this, r) || this).fragOffset = 0, r.duration = 0, r.gap = !1, r.independent = !1, r.relurl = void 0, r.fragment = void 0, r.index = void 0, r.stats = new l.a, r.duration = t.decimalFloatingPoint("DURATION"), r.gap = t.bool("GAP"), r.independent = t.bool("INDEPENDENT"), r.relurl = t.enumeratedString("URI"), r.fragment = e, r.index = i;
                  t = t.enumeratedString("BYTERANGE");
                  return t && r.setByteRange(t, n), n && (r.fragOffset = n.fragOffset + n.duration), r
                }

                function v(t) {
                  this._byteRange = null, this._url = null, this.baseurl = void 0, this.relurl = void 0, this.baseurl = t
                }
              }, function (t, e, r) {
                r.d(e, "b", function () {
                  return i
                }), r.d(e, "a", function () {
                  return n
                }), r.d(e, "d", function () {
                  return a
                }), r.d(e, "e", function () {
                  return s
                }), r.d(e, "c", function () {
                  return o
                }), r.d(e, "f", function () {
                  return p
                });

                function l(t, e) {
                  return e + 10 <= t.length && 73 === t[e] && 68 === t[e + 1] && 51 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128
                }

                function u(t, e) {
                  return e + 10 <= t.length && 51 === t[e] && 68 === t[e + 1] && 73 === t[e + 2] && t[e + 3] < 255 && t[e + 4] < 255 && t[e + 6] < 128 && t[e + 7] < 128 && t[e + 8] < 128 && t[e + 9] < 128
                }
                var h, i = function (t, e) {
                    for (var r = e, i = 0; l(t, e);) i += 10, i += d(t, e + 6), u(t, e + 10) && (i += 10), e += i;
                    if (0 < i) return t.subarray(r, r + i)
                  },
                  d = function (t, e) {
                    var r = 0,
                      r = (127 & t[e]) << 21;
                    return r |= (127 & t[e + 1]) << 14, (r |= (127 & t[e + 2]) << 7) | 127 & t[e + 3]
                  },
                  n = function (t, e) {
                    return l(t, e) && d(t, e + 6) + 10 <= t.length - e
                  },
                  a = function (t) {
                    for (var e = o(t), r = 0; r < e.length; r++) {
                      var i = e[r];
                      if (s(i)) return v(i)
                    }
                  },
                  s = function (t) {
                    return t && "PRIV" === t.key && "com.apple.streaming.transportStreamTimestamp" === t.info
                  },
                  o = function (t) {
                    for (var e, r = 0, i = []; l(t, r);) {
                      for (var n = d(t, r + 6), a = (r += 10) + n; r + 8 < a;) {
                        var s = (s = t.subarray(r), o = e = void 0, e = String.fromCharCode(s[0], s[1], s[2], s[3]), o = d(s, 4), {
                            type: e,
                            size: o,
                            data: s.subarray(10, 10 + o)
                          }),
                          o = c(s);
                        o && i.push(o), r += s.size + 10
                      }
                      u(t, r) && (r += 10)
                    }
                    return i
                  },
                  c = function (t) {
                    return "PRIV" === t.type ? f(t) : "T" === t.type[0] ? g(t) : "W" === t.type[0] ? m(t) : void 0
                  },
                  f = function (t) {
                    if (!(t.size < 2)) {
                      var e = p(t.data, !0),
                        r = new Uint8Array(t.data.subarray(e.length + 1));
                      return {
                        key: t.type,
                        info: e,
                        data: r.buffer
                      }
                    }
                  },
                  g = function (t) {
                    if (!(t.size < 2)) {
                      if ("TXXX" === t.type) {
                        var e = 1,
                          r = p(t.data.subarray(1), !0);
                        e += r.length + 1;
                        e = p(t.data.subarray(e));
                        return {
                          key: t.type,
                          info: r,
                          data: e
                        }
                      }
                      e = p(t.data.subarray(1));
                      return {
                        key: t.type,
                        data: e
                      }
                    }
                  },
                  m = function (t) {
                    if ("WXXX" === t.type) {
                      if (t.size < 2) return;
                      var e = 1,
                        r = p(t.data.subarray(1), !0);
                      e += r.length + 1;
                      e = p(t.data.subarray(e));
                      return {
                        key: t.type,
                        info: r,
                        data: e
                      }
                    }
                    e = p(t.data);
                    return {
                      key: t.type,
                      data: e
                    }
                  },
                  v = function (t) {
                    if (8 === t.data.byteLength) {
                      var e = new Uint8Array(t.data),
                        t = 1 & e[3],
                        e = (e[4] << 23) + (e[5] << 15) + (e[6] << 7) + e[7];
                      return e /= 45, t && (e += 47721858.84), Math.round(e)
                    }
                  },
                  p = function (t, e) {
                    void 0 === e && (e = !1);
                    h = h || void 0 === self.TextDecoder ? h : new self.TextDecoder("utf-8");
                    if (h) {
                      var r = h.decode(t);
                      if (e) {
                        var i = r.indexOf("\0");
                        return -1 !== i ? r.substring(0, i) : r
                      }
                      return r.replace(/\0/g, "")
                    }
                    for (var n, a, s, o = t.length, l = "", u = 0; u < o;) {
                      if (0 === (n = t[u++]) && e) return l;
                      if (0 !== n && 3 !== n) switch (n >> 4) {
                      case 0:
                      case 1:
                      case 2:
                      case 3:
                      case 4:
                      case 5:
                      case 6:
                      case 7:
                        l += String.fromCharCode(n);
                        break;
                      case 12:
                      case 13:
                        a = t[u++], l += String.fromCharCode((31 & n) << 6 | 63 & a);
                        break;
                      case 14:
                        a = t[u++], s = t[u++], l += String.fromCharCode((15 & n) << 12 | (63 & a) << 6 | (63 & s) << 0)
                      }
                    }
                    return l
                  }
              }, function (t, e, r) {
                function i(t, e, r) {
                  return Uint8Array.prototype.slice ? t.slice(e, r) : new Uint8Array(Array.prototype.slice.call(t, e, r))
                }
                r.d(e, "a", function () {
                  return i
                })
              }, function (t, e, r) {
                r.d(e, "c", function () {
                  return nt
                }), r.d(e, "d", function () {
                  return ot
                }), r.d(e, "a", function () {
                  return lt
                }), r.d(e, "b", function () {
                  return ut
                });
                var K = r(0),
                  W = r(2),
                  n = r(13),
                  c = r(3),
                  R = r(6),
                  D = r(4),
                  d = r(7),
                  i = ((E = s.prototype).resetInitSegment = function (t, e, r) {
                    this._id3Track = {
                      type: "id3",
                      id: 0,
                      pid: -1,
                      inputTimeScale: 9e4,
                      sequenceNumber: 0,
                      samples: [],
                      dropped: 0
                    }
                  }, E.resetTimeStamp = function () {}, E.resetContiguity = function () {}, E.canParse = function (t, e) {
                    return !1
                  }, E.appendFrame = function (t, e, r) {}, E.demux = function (t, e) {
                    this.cachedData && (t = Object(D.a)(this.cachedData, t), this.cachedData = null);
                    var r, i, n, a = R.b(t, 0),
                      s = a ? a.length : 0,
                      o = this._audioTrack,
                      l = this._id3Track,
                      u = a ? R.d(a) : void 0,
                      h = t.length;
                    for (null === this.initPTS && (this.initPTS = f(u, e)), a && 0 < a.length && l.samples.push({
                        pts: this.initPTS,
                        dts: this.initPTS,
                        data: a
                      }), i = this.initPTS; s < h;) this.canParse(t, s) ? (n = this.appendFrame(o, t, s)) ? (this.frameIndex++, i = n.sample.pts, r = s += n.length) : s = h : R.a(t, s) ? (a = R.b(t, s), l.samples.push({
                      pts: i,
                      dts: i,
                      data: a
                    }), r = s += a.length) : s++, s === h && r !== h && (n = Object(d.a)(t, r), this.cachedData ? this.cachedData = Object(D.a)(this.cachedData, n) : this.cachedData = n);
                    return {
                      audioTrack: o,
                      avcTrack: {
                        type: "",
                        id: -1,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: -1,
                        samples: [],
                        dropped: 0
                      },
                      id3Track: l,
                      textTrack: {
                        type: "",
                        id: -1,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: -1,
                        samples: [],
                        dropped: 0
                      }
                    }
                  }, E.demuxSampleAes = function (t, e, r) {
                    return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"))
                  }, E.flush = function (t) {
                    return this.cachedData && this.demux(this.cachedData, 0), this.frameIndex = 0, this.initPTS = null, this.cachedData = null, {
                      audioTrack: this._audioTrack,
                      avcTrack: {
                        type: "",
                        id: -1,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: -1,
                        samples: [],
                        dropped: 0
                      },
                      id3Track: this._id3Track,
                      textTrack: {
                        type: "",
                        id: -1,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: -1,
                        samples: [],
                        dropped: 0
                      }
                    }
                  }, E.destroy = function () {}, s),
                  f = function (t, e) {
                    return Object(c.a)(t) ? 90 * t : 9e4 * e
                  },
                  a = i,
                  Y = r(1);

                function s() {
                  this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.initPTS = null
                }

                function o(t, e) {
                  return 255 === t[e] && 240 == (246 & t[e + 1])
                }

                function l(t, e) {
                  return 1 & t[e + 1] ? 7 : 9
                }

                function u(t, e) {
                  return (3 & t[e + 3]) << 11 | t[e + 4] << 3 | (224 & t[e + 5]) >>> 5
                }

                function g(t, e) {
                  return e + 1 < t.length && o(t, e)
                }

                function m(t, e, r, i, n) {
                  t.samplerate || (n = function (t, e, r, i) {
                    var n, a, s = navigator.userAgent.toLowerCase(),
                      o = i,
                      l = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350],
                      u = 1 + ((192 & e[r + 2]) >>> 6),
                      h = (60 & e[r + 2]) >>> 2;
                    if (!(l.length - 1 < h)) return n = (1 & e[r + 2]) << 2, n |= (192 & e[r + 3]) >>> 6, Y.b.log("manifest codec:" + i + ",ADTS data:type:" + u + ",sampleingIndex:" + h + "[" + l[h] + "Hz],channelConfig:" + n), i = /firefox/i.test(s) ? 6 <= h ? (u = 5, a = new Array(4), h - 3) : (u = 2, a = new Array(2), h) : -1 !== s.indexOf("android") ? (u = 2, a = new Array(2), h) : (u = 5, a = new Array(4), i && (-1 !== i.indexOf("mp4a.40.29") || -1 !== i.indexOf("mp4a.40.5")) || !i && 6 <= h ? h - 3 : ((i && -1 !== i.indexOf("mp4a.40.2") && (6 <= h && 1 == n || /vivaldi/i.test(s)) || !i && 1 == n) && (u = 2, a = new Array(2)), h)), a[0] = u << 3, a[0] |= (14 & h) >> 1, a[1] |= (1 & h) << 7, a[1] |= n << 3, 5 === u && (a[1] |= (14 & i) >> 1, a[2] = (1 & i) << 7, a[2] |= 8, a[3] = 0), {
                      config: a,
                      samplerate: l[h],
                      channelCount: n,
                      codec: "mp4a.40." + u,
                      manifestCodec: o
                    };
                    t.trigger(K.a.ERROR, {
                      type: W.b.MEDIA_ERROR,
                      details: W.a.FRAG_PARSING_ERROR,
                      fatal: !0,
                      reason: "invalid ADTS sampling index:" + h
                    })
                  }(e, r, i, n), t.config = n.config, t.samplerate = n.samplerate, t.channelCount = n.channelCount, t.codec = n.codec, t.manifestCodec = n.manifestCodec, Y.b.log("parsed codec:" + t.codec + ",rate:" + n.samplerate + ",nb channel:" + n.channelCount))
                }

                function v(t) {
                  return 9216e4 / t
                }

                function p(t, n, a, s, o) {
                  var e = function (t) {
                    var e = n.length,
                      r = l(n, a),
                      i = u(n, a);
                    if (0 < (i -= r) && a + r + i <= e) return {
                      headerLength: r,
                      frameLength: i,
                      stamp: s + o * t
                    }
                  }(v(t.samplerate));
                  if (e) {
                    var r = e.stamp,
                      i = e.headerLength,
                      e = e.frameLength,
                      r = {
                        unit: n.subarray(a + i, a + i + e),
                        pts: r,
                        dts: r
                      };
                    return t.samples.push(r), {
                      sample: r,
                      length: e + i
                    }
                  }
                }
                var h = function (i) {
                  var t;

                  function e(t, e) {
                    var r;
                    return (r = i.call(this) || this).observer = void 0, r.config = void 0, r.observer = t, r.config = e, r
                  }
                  r = i, (t = e).prototype = Object.create(r.prototype), (t.prototype.constructor = t).__proto__ = r;
                  var r = e.prototype;
                  return r.resetInitSegment = function (t, e, r) {
                    i.prototype.resetInitSegment.call(this, t, e, r), this._audioTrack = {
                      container: "audio/adts",
                      type: "audio",
                      id: 0,
                      pid: -1,
                      sequenceNumber: 0,
                      isAAC: !0,
                      samples: [],
                      manifestCodec: t,
                      duration: r,
                      inputTimeScale: 9e4,
                      dropped: 0
                    }
                  }, e.probe = function (t) {
                    if (!t) return !1;
                    for (var e = (R.b(t, 0) || []).length, r = t.length; e < r; e++)
                      if (function (t, e) {
                          if (g(t, e)) {
                            var r = l(t, e);
                            if (e + r >= t.length) return;
                            var i = u(t, e);
                            if (i <= r) return;
                            i = e + i;
                            if (i === t.length || i + 1 < t.length && o(t, i)) return 1
                          }
                        }(t, e)) return Y.b.log("ADTS sync word found !"), !0;
                    return !1
                  }, r.canParse = function (t, e) {
                    return (e = e) + 5 < (t = t).length && o(t, e) && u(t, e) < t.length - e
                  }, r.appendFrame = function (t, e, r) {
                    return m(t, this.observer, e, r, t.manifestCodec), p(t, e, r, this.initPTS, this.frameIndex)
                  }, e
                }(a);
                h.minProbeByteLength = 9;
                var y = h,
                  E = ((e = b.prototype).resetTimeStamp = function () {}, e.resetInitSegment = function () {}, e.resetContiguity = function () {}, b.probe = function (t) {
                    return 0 < Object(D.b)({
                      data: t,
                      start: 0,
                      end: Math.min(t.length, 16384)
                    }, ["moof"]).length
                  }, e.demux = function (t) {
                    var e = t;
                    this.remainderData && (e = Object(D.a)(this.remainderData, t));
                    t = Object(D.h)(e);
                    this.remainderData = t.remainder;
                    e = {
                      type: "",
                      id: -1,
                      pid: -1,
                      inputTimeScale: 9e4,
                      sequenceNumber: -1,
                      samples: [],
                      dropped: 0
                    };
                    return e.samples = t.valid, {
                      audioTrack: {
                        type: "",
                        id: -1,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: -1,
                        samples: [],
                        dropped: 0
                      },
                      avcTrack: e,
                      id3Track: {
                        type: "",
                        id: -1,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: -1,
                        samples: [],
                        dropped: 0
                      },
                      textTrack: {
                        type: "",
                        id: -1,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: -1,
                        samples: [],
                        dropped: 0
                      }
                    }
                  }, e.flush = function () {
                    var t = {
                      type: "",
                      id: -1,
                      pid: -1,
                      inputTimeScale: 9e4,
                      sequenceNumber: -1,
                      samples: [],
                      dropped: 0
                    };
                    return t.samples = this.remainderData, this.remainderData = null, {
                      audioTrack: {
                        type: "",
                        id: -1,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: -1,
                        samples: [],
                        dropped: 0
                      },
                      avcTrack: t,
                      id3Track: {
                        type: "",
                        id: -1,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: -1,
                        samples: [],
                        dropped: 0
                      },
                      textTrack: {
                        type: "",
                        id: -1,
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: -1,
                        samples: [],
                        dropped: 0
                      }
                    }
                  }, e.demuxSampleAes = function (t, e, r) {
                    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"))
                  }, e.destroy = function () {}, b);

                function b() {
                  this.remainderData = null
                }
                E.minProbeByteLength = 1024;
                var i = E,
                  S = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160],
                  _ = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3],
                  L = [
                    [0, 72, 144, 12],
                    [0, 0, 0, 0],
                    [0, 72, 144, 12],
                    [0, 144, 144, 12]
                  ],
                  T = [0, 1, 1, 4];

                function k(t, e, r, i, n) {
                  if (!(r + 24 > e.length)) {
                    var a = A(e, r);
                    if (a && r + a.frameLength <= e.length) {
                      n = i + n * (9e4 * a.samplesPerFrame / a.sampleRate), n = {
                        unit: e.subarray(r, r + a.frameLength),
                        pts: n,
                        dts: n
                      };
                      return t.config = [], t.channelCount = a.channelCount, t.samplerate = a.sampleRate, t.samples.push(n), {
                        sample: n,
                        length: a.frameLength
                      }
                    }
                  }
                }

                function A(t, e) {
                  var r = t[e + 1] >> 3 & 3,
                    i = t[e + 1] >> 1 & 3,
                    n = t[e + 2] >> 4 & 15,
                    a = t[e + 2] >> 2 & 3,
                    s = t[e + 2] >> 1 & 1;
                  if (1 != r && 0 != n && 15 != n && 3 != a) {
                    n = 1e3 * S[14 * (3 == r ? 3 - i : 3 == i ? 3 : 4) + n - 1], a = _[3 * (3 == r ? 0 : 2 == r ? 1 : 2) + a], t = t[e + 3] >> 6 == 3 ? 1 : 2, e = L[r][i], r = T[i], i = 8 * e * r;
                    return {
                      sampleRate: a,
                      channelCount: t,
                      frameLength: Math.floor(e * n / a + s) * r,
                      samplesPerFrame: i
                    }
                  }
                }

                function C(t, e) {
                  return 255 === t[e] && 224 == (224 & t[e + 1]) && 0 != (6 & t[e + 1])
                }
                var w = ((h = F.prototype).loadWord = function () {
                    var t = this.data,
                      e = this.bytesAvailable,
                      r = t.byteLength - e,
                      i = new Uint8Array(4),
                      e = Math.min(4, e);
                    if (0 === e) throw new Error("no bytes available");
                    i.set(t.subarray(r, r + e)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = 8 * e, this.bytesAvailable -= e
                  }, h.skipBits = function (t) {
                    var e;
                    this.bitsAvailable > t || (t -= this.bitsAvailable, t -= (e = t >> 3) >> 3, this.bytesAvailable -= e, this.loadWord()), this.word <<= t, this.bitsAvailable -= t
                  }, h.readBits = function (t) {
                    var e = Math.min(this.bitsAvailable, t),
                      r = this.word >>> 32 - e;
                    return 32 < t && Y.b.error("Cannot read more than 32 bits at a time"), this.bitsAvailable -= e, 0 < this.bitsAvailable ? this.word <<= e : 0 < this.bytesAvailable && this.loadWord(), 0 < (e = t - e) && this.bitsAvailable ? r << e | this.readBits(e) : r
                  }, h.skipLZ = function () {
                    for (var t = 0; t < this.bitsAvailable; ++t)
                      if (0 != (this.word & 2147483648 >>> t)) return this.word <<= t, this.bitsAvailable -= t, t;
                    return this.loadWord(), t + this.skipLZ()
                  }, h.skipUEG = function () {
                    this.skipBits(1 + this.skipLZ())
                  }, h.skipEG = function () {
                    this.skipBits(1 + this.skipLZ())
                  }, h.readUEG = function () {
                    var t = this.skipLZ();
                    return this.readBits(t + 1) - 1
                  }, h.readEG = function () {
                    var t = this.readUEG();
                    return 1 & t ? 1 + t >>> 1 : -1 * (t >>> 1)
                  }, h.readBoolean = function () {
                    return 1 === this.readBits(1)
                  }, h.readUByte = function () {
                    return this.readBits(8)
                  }, h.readUShort = function () {
                    return this.readBits(16)
                  }, h.readUInt = function () {
                    return this.readBits(32)
                  }, h.skipScalingList = function (t) {
                    for (var e = 8, r = 8, i = 0; i < t; i++) e = 0 === (r = 0 !== r ? (e + this.readEG() + 256) % 256 : r) ? e : r
                  }, h.readSPS = function () {
                    var t, e, r, i = 0,
                      n = 0,
                      a = 0,
                      s = 0,
                      o = this.readUByte.bind(this),
                      l = this.readBits.bind(this),
                      u = this.readUEG.bind(this),
                      h = this.readBoolean.bind(this),
                      d = this.skipBits.bind(this),
                      c = this.skipEG.bind(this),
                      f = this.skipUEG.bind(this),
                      g = this.skipScalingList.bind(this);
                    o();
                    var m = o();
                    if (l(5), d(3), o(), f(), 100 === m || 110 === m || 122 === m || 244 === m || 44 === m || 83 === m || 86 === m || 118 === m || 128 === m) {
                      var v = u();
                      if (3 === v && d(1), f(), f(), d(1), h())
                        for (e = 3 !== v ? 8 : 12, r = 0; r < e; r++) h() && g(r < 6 ? 16 : 64)
                    }
                    f();
                    v = u();
                    if (0 === v) u();
                    else if (1 === v)
                      for (d(1), c(), c(), t = u(), r = 0; r < t; r++) c();
                    f(), d(1);
                    v = u(), f = u(), l = l(1);
                    0 === l && d(1), d(1), h() && (i = u(), n = u(), a = u(), s = u());
                    var p = [1, 1];
                    if (h() && h()) switch (o()) {
                    case 1:
                      p = [1, 1];
                      break;
                    case 2:
                      p = [12, 11];
                      break;
                    case 3:
                      p = [10, 11];
                      break;
                    case 4:
                      p = [16, 11];
                      break;
                    case 5:
                      p = [40, 33];
                      break;
                    case 6:
                      p = [24, 11];
                      break;
                    case 7:
                      p = [20, 11];
                      break;
                    case 8:
                      p = [32, 11];
                      break;
                    case 9:
                      p = [80, 33];
                      break;
                    case 10:
                      p = [18, 11];
                      break;
                    case 11:
                      p = [15, 11];
                      break;
                    case 12:
                      p = [64, 33];
                      break;
                    case 13:
                      p = [160, 99];
                      break;
                    case 14:
                      p = [4, 3];
                      break;
                    case 15:
                      p = [3, 2];
                      break;
                    case 16:
                      p = [2, 1];
                      break;
                    case 255:
                      p = [o() << 8 | o(), o() << 8 | o()]
                    }
                    return {
                      width: Math.ceil(16 * (v + 1) - 2 * i - 2 * n),
                      height: (2 - l) * (f + 1) * 16 - (l ? 2 : 4) * (a + s),
                      pixelRatio: p
                    }
                  }, h.readSliceType = function () {
                    return this.readUByte(), this.readUEG(), this.readUEG()
                  }, F),
                  x = ((e = O.prototype).decryptBuffer = function (t, e) {
                    this.decrypter.decrypt(t, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, e)
                  }, e.decryptAacSample = function (e, r, i, n) {
                    var a = e[r].unit,
                      t = a.subarray(16, a.length - a.length % 16),
                      t = t.buffer.slice(t.byteOffset, t.byteOffset + t.length),
                      s = this;
                    this.decryptBuffer(t, function (t) {
                      t = new Uint8Array(t), a.set(t, 16), n || s.decryptAacSamples(e, r + 1, i)
                    })
                  }, e.decryptAacSamples = function (t, e, r) {
                    for (;; e++) {
                      if (e >= t.length) return void r();
                      if (!(t[e].unit.length < 32)) {
                        var i = this.decrypter.isSync();
                        if (this.decryptAacSample(t, e, r, i), !i) return
                      }
                    }
                  }, e.getAvcEncryptedData = function (t) {
                    for (var e = 16 * Math.floor((t.length - 48) / 160) + 16, r = new Int8Array(e), i = 0, n = 32; n <= t.length - 16; n += 160, i += 16) r.set(t.subarray(n, n + 16), i);
                    return r
                  }, e.getAvcDecryptedUnit = function (t, e) {
                    e = new Uint8Array(e);
                    for (var r = 0, i = 32; i <= t.length - 16; i += 160, r += 16) t.set(e.subarray(r, r + 16), i);
                    return t
                  }, e.decryptAvcSample = function (e, r, i, n, a, s) {
                    var o = this.discardEPB(a.data),
                      t = this.getAvcEncryptedData(o),
                      l = this;
                    this.decryptBuffer(t.buffer, function (t) {
                      a.data = l.getAvcDecryptedUnit(o, t), s || l.decryptAvcSamples(e, r, i + 1, n)
                    })
                  }, e.decryptAvcSamples = function (t, e, r, i) {
                    for (;; e++, r = 0) {
                      if (e >= t.length) return void i();
                      for (var n = t[e].units; !(r >= n.length); r++) {
                        var a = n[r];
                        if (!(a.data.length <= 48 || 1 !== a.type && 5 !== a.type)) {
                          var s = this.decrypter.isSync();
                          if (this.decryptAvcSample(t, e, r, i, a, s), !s) return
                        }
                      }
                    }
                  }, O),
                  P = {
                    video: 1,
                    audio: 2,
                    id3: 3,
                    text: 4
                  },
                  E = function () {
                    function A(t, e, r) {
                      this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.contiguous = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._duration = 0, this.aacLastPTS = null, this._initPTS = null, this._initDTS = null, this._pmtId = -1, this._avcTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = void 0, this.avcSample = null, this.remainderData = null, this.observer = t, this.config = e, this.typeSupported = r
                    }
                    A.probe = function (t) {
                      t = A._syncOffset(t);
                      return !(t < 0 || (t && Y.b.warn("MPEG2-TS detected but first sync word found @ offset " + t + ", junk ahead ?"), 0))
                    }, A._syncOffset = function (t) {
                      for (var e = Math.min(1e3, t.length - 564), r = 0; r < e;) {
                        if (71 === t[r] && 71 === t[r + 188] && 71 === t[r + 376]) return r;
                        r++
                      }
                      return -1
                    }, A.createTrack = function (t, e) {
                      return {
                        container: "video" === t || "audio" === t ? "video/mp2t" : void 0,
                        type: t,
                        id: P[t],
                        pid: -1,
                        inputTimeScale: 9e4,
                        sequenceNumber: 0,
                        samples: [],
                        dropped: 0,
                        duration: "audio" === t ? e : void 0
                      }
                    };
                    var t = A.prototype;
                    return t.resetInitSegment = function (t, e, r) {
                      this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = A.createTrack("video", r), this._audioTrack = A.createTrack("audio", r), this._id3Track = A.createTrack("id3", r), this._txtTrack = A.createTrack("text", r), this._audioTrack.isAAC = !0, this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = t, this.videoCodec = e, this._duration = r
                    }, t.resetTimeStamp = function () {}, t.resetContiguity = function () {
                      var t = this._audioTrack,
                        e = this._avcTrack,
                        r = this._id3Track;
                      t && (t.pesData = null), e && (e.pesData = null), r && (r.pesData = null), this.aacOverFlow = null, this.aacLastPTS = null
                    }, t.demux = function (t, e, r, i, n) {
                      var a, s, o, l, u;
                      void 0 === n && (n = !1), (i = void 0 === i ? !1 : i) || (this.sampleAes = null), this.contiguous = e;
                      var h = this._avcTrack,
                        d = this._audioTrack,
                        c = this._id3Track,
                        f = h.pid,
                        g = h.pesData,
                        m = d.pid,
                        v = c.pid,
                        p = d.pesData,
                        y = c.pesData,
                        E = !1,
                        b = this.pmtParsed,
                        S = this._pmtId,
                        _ = t.length;
                      if (this.remainderData && (_ = (t = Object(D.a)(this.remainderData, t)).length, this.remainderData = null), _ < 188 && !n) return this.remainderData = t, {
                        audioTrack: d,
                        avcTrack: h,
                        id3Track: c,
                        textTrack: this._txtTrack
                      };
                      var L = Math.max(0, A._syncOffset(t));
                      for ((_ -= (_ + L) % 188) < t.byteLength && !n && (this.remainderData = new Uint8Array(t.buffer, _, t.buffer.byteLength - _)), a = L; a < _; a += 188)
                        if (71 === t[a]) {
                          if (s = !!(64 & t[a + 1]), o = ((31 & t[a + 1]) << 8) + t[a + 2], 1 < (48 & t[a + 3]) >> 4) {
                            if ((l = a + 5 + t[a + 4]) === a + 188) continue
                          } else l = a + 4;
                          switch (o) {
                          case f:
                            s && (g && (u = M(g)) && this._parseAVCPES(u, !1), g = {
                              data: [],
                              size: 0
                            }), g && (g.data.push(t.subarray(l, a + 188)), g.size += a + 188 - l);
                            break;
                          case m:
                            s && (p && (u = M(p)) && (d.isAAC ? this._parseAACPES(u) : this._parseMPEGPES(u)), p = {
                              data: [],
                              size: 0
                            }), p && (p.data.push(t.subarray(l, a + 188)), p.size += a + 188 - l);
                            break;
                          case v:
                            s && (y && (u = M(y)) && this._parseID3PES(u), y = {
                              data: [],
                              size: 0
                            }), y && (y.data.push(t.subarray(l, a + 188)), y.size += a + 188 - l);
                            break;
                          case 0:
                            s && (l += t[l] + 1), S = this._pmtId = (31 & t[l + 10]) << 8 | t[l + 11];
                            break;
                          case S:
                            s && (l += t[l] + 1);
                            var T = function (t, e, r, i) {
                              var n = {
                                  audio: -1,
                                  avc: -1,
                                  id3: -1,
                                  isAAC: !0
                                },
                                a = e + 3 + ((15 & t[e + 1]) << 8 | t[e + 2]) - 4;
                              for (e += 12 + ((15 & t[e + 10]) << 8 | t[e + 11]); e < a;) {
                                var s = (31 & t[e + 1]) << 8 | t[e + 2];
                                switch (t[e]) {
                                case 207:
                                  if (!i) {
                                    Y.b.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
                                    break
                                  }
                                case 15:
                                  -1 === n.audio && (n.audio = s);
                                  break;
                                case 21:
                                  -1 === n.id3 && (n.id3 = s);
                                  break;
                                case 219:
                                  if (!i) {
                                    Y.b.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
                                    break
                                  }
                                case 27:
                                  -1 === n.avc && (n.avc = s);
                                  break;
                                case 3:
                                case 4:
                                  r ? -1 === n.audio && (n.audio = s, n.isAAC = !1) : Y.b.log("MPEG audio found, not supported in this browser");
                                  break;
                                case 36:
                                  Y.b.warn("Unsupported HEVC stream type found")
                                }
                                e += 5 + ((15 & t[e + 3]) << 8 | t[e + 4])
                              }
                              return n
                            }(t, l, !0 === this.typeSupported.mpeg || !0 === this.typeSupported.mp3, i);
                            0 < (f = T.avc) && (h.pid = f), 0 < (m = T.audio) && (d.pid = m, d.isAAC = T.isAAC), 0 < (v = T.id3) && (c.pid = v), E && !b && (Y.b.log("reparse from beginning"), E = !1, a = L - 188), b = this.pmtParsed = !0;
                            break;
                          case 17:
                          case 8191:
                            break;
                          default:
                            E = !0
                          }
                        } else this.observer.emit(K.a.ERROR, K.a.ERROR, {
                          type: W.b.MEDIA_ERROR,
                          details: W.a.FRAG_PARSING_ERROR,
                          fatal: !1,
                          reason: "TS packet did not start with 0x47"
                        });
                      return h.pesData = g, d.pesData = p, c.pesData = y, {
                        audioTrack: d,
                        avcTrack: h,
                        id3Track: c,
                        textTrack: this._txtTrack
                      }
                    }, t.flush = function () {
                      var t = this.remainderData;
                      return this.remainderData = null, t = t ? this.demux(t, this.contiguous, -1, !1, !0) : {
                        audioTrack: this._audioTrack,
                        avcTrack: this._avcTrack,
                        textTrack: this._txtTrack,
                        id3Track: this._id3Track
                      }, this.extractRemainingSamples(t), t
                    }, t.extractRemainingSamples = function (t) {
                      var e, r = t.audioTrack,
                        i = t.avcTrack,
                        n = t.id3Track,
                        a = i.pesData,
                        s = r.pesData,
                        t = n.pesData;
                      a && (e = M(a)) ? (this._parseAVCPES(e, !0), i.pesData = null) : i.pesData = a, s && (e = M(s)) ? (r.isAAC ? this._parseAACPES(e) : this._parseMPEGPES(e), r.pesData = null) : (null != s && s.size && Y.b.log("last AAC PES packet truncated,might overlap between fragments"), r.pesData = s), t && (e = M(t)) ? (this._parseID3PES(e), n.pesData = null) : n.pesData = t
                    }, t.demuxSampleAes = function (t, e, r) {
                      var i = this,
                        n = this.demux(t, r, !0),
                        a = this.sampleAes = new x(this.observer, this.config, e, this.discardEPB);
                      return new Promise(function (t, e) {
                        i.decrypt(n.audioTrack, n.avcTrack, a).then(function () {
                          t(n)
                        })
                      })
                    }, t.decrypt = function (e, r, i) {
                      return new Promise(function (t) {
                        e.samples && e.isAAC ? i.decryptAacSamples(e.samples, 0, function () {
                          r.samples ? i.decryptAvcSamples(r.samples, 0, 0, function () {
                            t()
                          }) : t()
                        }) : r.samples && i.decryptAvcSamples(r.samples, 0, 0, function () {
                          t()
                        })
                      })
                    }, t.destroy = function () {
                      this._initPTS = this._initDTS = null, this._duration = 0
                    }, t.pushAccessUnit = function (t, e) {
                      if (t.units.length && t.frame) {
                        if (isNaN(t.pts)) {
                          var r = e.samples,
                            i = r.length;
                          if (!i) return void e.dropped++;
                          i = r[i - 1];
                          t.pts = i.pts, t.dts = i.dts
                        }
                        e.samples.push(t)
                      }
                      t.debug.length && Y.b.log(t.pts + "/" + t.dts + ":" + t.debug)
                    }, t._parseAVCPES = function (v, t) {
                      var p, y, E, b = this,
                        S = this._avcTrack,
                        e = this._parseAVCNALu(v.data),
                        _ = this.avcSample,
                        L = !1,
                        T = this.pushAccessUnit.bind(this);
                      v.data = null, _ && e.length && !S.audFound && (T(_, S), _ = this.avcSample = I(!1, v.pts, v.dts, "")), e.forEach(function (t) {
                        switch (t.type) {
                        case 1:
                          y = !0, (_ = _ || (b.avcSample = I(!0, v.pts, v.dts, ""))).frame = !0;
                          var e = t.data;
                          L && 4 < e.length && (2 !== (c = new w(e).readSliceType()) && 4 !== c && 7 !== c && 9 !== c || (_.key = !0));
                          break;
                        case 5:
                          y = !0, (_ = _ || (b.avcSample = I(!0, v.pts, v.dts, ""))).key = !0, _.frame = !0;
                          break;
                        case 6:
                          y = !0, (p = new w(b.discardEPB(t.data))).readUByte();
                          for (var r = 0, i = 0, n = !1, a = 0; !n && 1 < p.bytesAvailable;) {
                            for (r = 0; r += a = p.readUByte(), 255 === a;);
                            for (i = 0; i += a = p.readUByte(), 255 === a;);
                            if (4 === r && 0 !== p.bytesAvailable) {
                              if (n = !0, 181 === p.readUByte() && 49 === p.readUShort() && 1195456820 === p.readUInt() && 3 === p.readUByte()) {
                                var s = p.readUByte(),
                                  o = 31 & s,
                                  l = [s, p.readUByte()];
                                for (E = 0; E < o; E++) l.push(p.readUByte()), l.push(p.readUByte()), l.push(p.readUByte());
                                b._insertSampleInOrder(b._txtTrack.samples, {
                                  type: 3,
                                  pts: v.pts,
                                  bytes: l
                                })
                              }
                            } else if (5 === r && 0 !== p.bytesAvailable) {
                              if (n = !0, 16 < i) {
                                var u = [];
                                for (E = 0; E < 16; E++) u.push(p.readUByte().toString(16)), 3 !== E && 5 !== E && 7 !== E && 9 !== E || u.push("-");
                                var h = i - 16,
                                  d = new Uint8Array(h);
                                for (E = 0; E < h; E++) d[E] = p.readUByte();
                                b._insertSampleInOrder(b._txtTrack.samples, {
                                  pts: v.pts,
                                  payloadType: r,
                                  uuid: u.join(""),
                                  userData: Object(R.f)(d),
                                  userDataBytes: d
                                })
                              }
                            } else if (i < p.bytesAvailable)
                              for (E = 0; E < i; E++) p.readUByte()
                          }
                          break;
                        case 7:
                          if (L = y = !0, !S.sps) {
                            var c = (p = new w(t.data)).readSPS();
                            S.width = c.width, S.height = c.height, S.pixelRatio = c.pixelRatio, S.sps = [t.data], S.duration = b._duration;
                            var f = t.data.subarray(1, 4),
                              g = "avc1.";
                            for (E = 0; E < 3; E++) {
                              var m = f[E].toString(16);
                              g += m = m.length < 2 ? "0" + m : m
                            }
                            S.codec = g
                          }
                          break;
                        case 8:
                          y = !0, S.pps || (S.pps = [t.data]);
                          break;
                        case 9:
                          y = !1, S.audFound = !0, _ && T(_, S), _ = b.avcSample = I(!1, v.pts, v.dts, "");
                          break;
                        case 12:
                          y = !1;
                          break;
                        default:
                          y = !1, _ && (_.debug += "unknown NAL " + t.type + " ")
                        }
                        _ && y && _.units.push(t)
                      }), t && _ && (T(_, S), this.avcSample = null)
                    }, t._insertSampleInOrder = function (t, e) {
                      var r = t.length;
                      if (0 < r) {
                        if (e.pts >= t[r - 1].pts) t.push(e);
                        else
                          for (var i = r - 1; 0 <= i; i--)
                            if (e.pts < t[i].pts) {
                              t.splice(i, 0, e);
                              break
                            }
                      } else t.push(e)
                    }, t._getLastNalUnit = function () {
                      var t, e, r = this.avcSample;
                      return e = null !== (r = !r || 0 === r.units.length ? (t = this._avcTrack.samples)[t.length - 1] : r) && void 0 !== r && r.units ? (r = r.units)[r.length - 1] : e
                    }, t._parseAVCNALu = function (t) {
                      var e, r, i, n, a, s, o, l, u = t.byteLength,
                        h = this._avcTrack,
                        d = h.naluState || 0,
                        c = d,
                        f = [],
                        g = 0,
                        m = -1;
                      for (-1 === d && (n = 31 & t[m = 0], d = 0, g = 1); g < u;) e = t[g++], d = d ? 1 !== d ? e ? 1 === e ? (0 <= m ? (i = {
                        data: t.subarray(m, g - d - 1),
                        type: n
                      }, f.push(i)) : (a = this._getLastNalUnit()) && (c && g <= 4 - c && a.state && (a.data = a.data.subarray(0, a.data.byteLength - c)), 0 < (r = g - d - 1)) && ((s = new Uint8Array(a.data.byteLength + r)).set(a.data, 0), s.set(t.subarray(0, r), a.data.byteLength), a.data = s), g < u ? (n = 31 & t[m = g], 0) : -1) : 0 : 3 : e ? 0 : 2 : e ? 0 : 1;
                      return 0 <= m && 0 <= d && (i = {
                        data: t.subarray(m, u),
                        type: n,
                        state: d
                      }, f.push(i)), 0 === f.length && (o = this._getLastNalUnit()) && ((l = new Uint8Array(o.data.byteLength + t.byteLength)).set(o.data, 0), l.set(t, o.data.byteLength), o.data = l), h.naluState = d, f
                    }, t.discardEPB = function (t) {
                      for (var e = t.byteLength, r = [], i = 1; i < e - 2;) 0 === t[i] && 0 === t[i + 1] && 3 === t[i + 2] ? (r.push(i + 2), i += 2) : i++;
                      if (0 === r.length) return t;
                      for (var n = e - r.length, a = new Uint8Array(n), s = 0, i = 0; i < n; s++, i++) s === r[0] && (s++, r.shift()), a[i] = t[s];
                      return a
                    }, t._parseAACPES = function (t) {
                      var e, r, i, n, a = this._audioTrack,
                        s = this.aacLastPTS,
                        o = this.aacOverFlow,
                        l = t.data,
                        u = t.pts;
                      for (o && ((t = new Uint8Array(o.byteLength + l.byteLength)).set(o, 0), t.set(l, o.byteLength), l = t), e = 0, i = l.length; e < i - 1 && !g(l, e); e++);
                      if (!e || (d = e < i - 1 ? (n = "AAC PES did not start with ADTS header,offset:" + e, !1) : (n = "no ADTS header found in AAC PES", !0), Y.b.warn("parsing error:" + n), this.observer.emit(K.a.ERROR, K.a.ERROR, {
                          type: W.b.MEDIA_ERROR,
                          details: W.a.FRAG_PARSING_ERROR,
                          fatal: d,
                          reason: n
                        }), !d)) {
                        m(a, this.observer, l, e, this.audioCodec);
                        var h = 0,
                          d = v(a.samplerate);
                        for (o && s && (d = s + d, 1 < Math.abs(d - u) && (Y.b.log("[tsdemuxer]: AAC: align PTS for overlapping frames by " + Math.round((d - u) / 90)), u = d)); e < i;) {
                          if (g(l, e)) {
                            if (e + 5 < i) {
                              var c = p(a, l, e, u, h);
                              if (c) {
                                e += c.length, r = c.sample.pts, h++;
                                continue
                              }
                            }
                            break
                          }
                          e++
                        }
                        o = e < i ? l.subarray(e, i) : null, this.aacOverFlow = o, this.aacLastPTS = r
                      }
                    }, t._parseMPEGPES = function (t) {
                      for (var e, r = t.data, i = r.length, n = 0, a = 0, s = t.pts; a < i;)
                        if ((o = a) + 1 < (e = r).length && C(e, o)) {
                          var o = k(this._audioTrack, r, a, s, n);
                          if (!o) break;
                          a += o.length, n++
                        } else a++
                    }, t._parseID3PES = function (t) {
                      this._id3Track.samples.push(t)
                    }, A
                  }();

                function O(t, e, r, i) {
                  this.decryptdata = r, this.discardEPB = i, this.decrypter = new n.a(t, e, {
                    removePKCS7Padding: !1
                  })
                }

                function F(t) {
                  this.data = t, this.bytesAvailable = t.byteLength, this.word = 0, this.bitsAvailable = 0
                }

                function I(t, e, r, i) {
                  return {
                    key: t,
                    frame: !1,
                    pts: e,
                    dts: r,
                    units: [],
                    debug: i,
                    length: 0
                  }
                }

                function M(t) {
                  var e, r, i, n, a, s, o = 0,
                    l = t.data;
                  if (!t || 0 === t.size) return null;
                  for (; l[0].length < 19 && 1 < l.length;) {
                    var u = new Uint8Array(l[0].length + l[1].length);
                    u.set(l[0]), u.set(l[1], l[0].length), l[0] = u, l.splice(1, 1)
                  }
                  if (1 !== ((e = l[0])[0] << 16) + (e[1] << 8) + e[2]) return null;
                  if ((r = (e[4] << 8) + e[5]) && r > t.size - 6) return null;
                  if (192 & (i = e[7]) && (n = 536870912 * (14 & e[9]) + 4194304 * (255 & e[10]) + 16384 * (254 & e[11]) + 128 * (255 & e[12]) + (254 & e[13]) / 2, 64 & i ? 54e5 < n - (a = 536870912 * (14 & e[14]) + 4194304 * (255 & e[15]) + 16384 * (254 & e[16]) + 128 * (255 & e[17]) + (254 & e[18]) / 2) && (Y.b.warn(Math.round((n - a) / 9e4) + "s delta between PTS and DTS, align them"), n = a) : a = n), s = (i = e[8]) + 9, t.size <= s) return null;
                  t.size -= s;
                  for (var h = new Uint8Array(t.size), d = 0, c = l.length; d < c; d++) {
                    var f = (e = l[d]).byteLength;
                    if (s) {
                      if (f < s) {
                        s -= f;
                        continue
                      }
                      e = e.subarray(s), f -= s, s = 0
                    }
                    h.set(e, o), o += f
                  }
                  return r && (r -= i + 3), {
                    data: h,
                    pts: n,
                    dts: a,
                    len: r
                  }
                }
                E.minProbeByteLength = 188;
                h = E, e = function (i) {
                  var t;

                  function e() {
                    return i.apply(this, arguments) || this
                  }
                  r = i, (t = e).prototype = Object.create(r.prototype), (t.prototype.constructor = t).__proto__ = r;
                  var r = e.prototype;
                  return r.resetInitSegment = function (t, e, r) {
                    i.prototype.resetInitSegment.call(this, t, e, r), this._audioTrack = {
                      container: "audio/mpeg",
                      type: "audio",
                      id: 0,
                      pid: -1,
                      sequenceNumber: 0,
                      isAAC: !1,
                      samples: [],
                      manifestCodec: t,
                      duration: r,
                      inputTimeScale: 9e4,
                      dropped: 0
                    }
                  }, e.probe = function (t) {
                    if (!t) return !1;
                    for (var e = (R.b(t, 0) || []).length, r = t.length; e < r; e++)
                      if (function (t, e) {
                          if (e + 1 < t.length && C(t, e)) {
                            var r = A(t, e),
                              i = 4,
                              i = e + (i = null != r && r.frameLength ? r.frameLength : i);
                            if (i === t.length || i + 1 < t.length && C(t, i)) return 1
                          }
                        }(t, e)) return Y.b.log("MPEG Audio sync word found !"), !0;
                    return !1
                  }, r.canParse = function (t, e) {
                    return C(t, e) && 4 <= t.length - e
                  }, r.appendFrame = function (t, e, r) {
                    if (null !== this.initPTS) return k(t, e, r, this.initPTS, this.frameIndex)
                  }, e
                }(a);
                e.minProbeByteLength = 4;
                var E = e,
                  H = (B.getSilentFrame = function (t, e) {
                    if ("mp4a.40.2" === t) return 1 === e ? new Uint8Array([0, 200, 0, 128, 35, 128]) : 2 === e ? new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]) : 3 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]) : 4 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]) : 5 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]) : 6 === e ? new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]) : void 0;
                    else return 1 === e ? new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]) : 2 === e || 3 === e ? new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]) : void 0
                  }, B),
                  N = Math.pow(2, 32) - 1,
                  a = (U.init = function () {
                    for (var t in U.types = {
                        avc1: [],
                        avcC: [],
                        btrt: [],
                        dinf: [],
                        dref: [],
                        esds: [],
                        ftyp: [],
                        hdlr: [],
                        mdat: [],
                        mdhd: [],
                        mdia: [],
                        mfhd: [],
                        minf: [],
                        moof: [],
                        moov: [],
                        mp4a: [],
                        ".mp3": [],
                        mvex: [],
                        mvhd: [],
                        pasp: [],
                        sdtp: [],
                        stbl: [],
                        stco: [],
                        stsc: [],
                        stsd: [],
                        stsz: [],
                        stts: [],
                        tfdt: [],
                        tfhd: [],
                        traf: [],
                        trak: [],
                        trun: [],
                        trex: [],
                        tkhd: [],
                        vmhd: [],
                        smhd: []
                      }) U.types.hasOwnProperty(t) && (U.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
                    var e = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
                      r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]);
                    U.HDLR_TYPES = {
                      video: e,
                      audio: r
                    };
                    var i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
                      n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
                    U.STTS = U.STSC = U.STCO = n, U.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), U.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), U.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), U.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]);
                    e = new Uint8Array([105, 115, 111, 109]), r = new Uint8Array([97, 118, 99, 49]), n = new Uint8Array([0, 0, 0, 1]);
                    U.FTYP = U.box(U.types.ftyp, e, n, e, r), U.DINF = U.box(U.types.dinf, U.box(U.types.dref, i))
                  }, U.box = function (t) {
                    for (var e = 8, r = arguments.length, i = new Array(1 < r ? r - 1 : 0), n = 1; n < r; n++) i[n - 1] = arguments[n];
                    for (var a = i.length, s = a; a--;) e += i[a].byteLength;
                    var o = new Uint8Array(e);
                    for (o[0] = e >> 24 & 255, o[1] = e >> 16 & 255, o[2] = e >> 8 & 255, o[3] = 255 & e, o.set(t, 4), a = 0, e = 8; a < s; a++) o.set(i[a], e), e += i[a].byteLength;
                    return o
                  }, U.hdlr = function (t) {
                    return U.box(U.types.hdlr, U.HDLR_TYPES[t])
                  }, U.mdat = function (t) {
                    return U.box(U.types.mdat, t)
                  }, U.mdhd = function (t, e) {
                    e *= t;
                    var r = Math.floor(e / (1 + N)),
                      e = Math.floor(e % (1 + N));
                    return U.box(U.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e, 85, 196, 0, 0]))
                  }, U.mdia = function (t) {
                    return U.box(U.types.mdia, U.mdhd(t.timescale, t.duration), U.hdlr(t.type), U.minf(t))
                  }, U.mfhd = function (t) {
                    return U.box(U.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t]))
                  }, U.minf = function (t) {
                    return "audio" === t.type ? U.box(U.types.minf, U.box(U.types.smhd, U.SMHD), U.DINF, U.stbl(t)) : U.box(U.types.minf, U.box(U.types.vmhd, U.VMHD), U.DINF, U.stbl(t))
                  }, U.moof = function (t, e, r) {
                    return U.box(U.types.moof, U.mfhd(t), U.traf(r, e))
                  }, U.moov = function (t) {
                    for (var e = t.length, r = []; e--;) r[e] = U.trak(t[e]);
                    return U.box.apply(null, [U.types.moov, U.mvhd(t[0].timescale, t[0].duration)].concat(r).concat(U.mvex(t)))
                  }, U.mvex = function (t) {
                    for (var e = t.length, r = []; e--;) r[e] = U.trex(t[e]);
                    return U.box.apply(null, [U.types.mvex].concat(r))
                  }, U.mvhd = function (t, e) {
                    e *= t;
                    var r = Math.floor(e / (1 + N)),
                      e = Math.floor(e % (1 + N)),
                      e = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                    return U.box(U.types.mvhd, e)
                  }, U.sdtp = function (t) {
                    for (var e, r = t.samples || [], i = new Uint8Array(4 + r.length), n = 0; n < r.length; n++) e = r[n].flags, i[n + 4] = e.dependsOn << 4 | e.isDependedOn << 2 | e.hasRedundancy;
                    return U.box(U.types.sdtp, i)
                  }, U.stbl = function (t) {
                    return U.box(U.types.stbl, U.stsd(t), U.box(U.types.stts, U.STTS), U.box(U.types.stsc, U.STSC), U.box(U.types.stsz, U.STSZ), U.box(U.types.stco, U.STCO))
                  }, U.avc1 = function (t) {
                    for (var e, r, i = [], n = [], a = 0; a < t.sps.length; a++) r = (e = t.sps[a]).byteLength, i.push(r >>> 8 & 255), i.push(255 & r), i = i.concat(Array.prototype.slice.call(e));
                    for (a = 0; a < t.pps.length; a++) r = (e = t.pps[a]).byteLength, n.push(r >>> 8 & 255), n.push(255 & r), n = n.concat(Array.prototype.slice.call(e));
                    var s = U.box(U.types.avcC, new Uint8Array([1, i[3], i[4], i[5], 255, 224 | t.sps.length].concat(i).concat([t.pps.length]).concat(n))),
                      o = t.width,
                      l = t.height,
                      u = t.pixelRatio[0],
                      h = t.pixelRatio[1];
                    return U.box(U.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, o >> 8 & 255, 255 & o, l >> 8 & 255, 255 & l, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), s, U.box(U.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), U.box(U.types.pasp, new Uint8Array([u >> 24, u >> 16 & 255, u >> 8 & 255, 255 & u, h >> 24, h >> 16 & 255, h >> 8 & 255, 255 & h])))
                  }, U.esds = function (t) {
                    var e = t.config.length;
                    return new Uint8Array([0, 0, 0, 0, 3, 23 + e, 0, 1, 0, 4, 15 + e, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([e]).concat(t.config).concat([6, 1, 2]))
                  }, U.mp4a = function (t) {
                    var e = t.samplerate;
                    return U.box(U.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, e >> 8 & 255, 255 & e, 0, 0]), U.box(U.types.esds, U.esds(t)))
                  }, U.mp3 = function (t) {
                    var e = t.samplerate;
                    return U.box(U.types[".mp3"], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, e >> 8 & 255, 255 & e, 0, 0]))
                  }, U.stsd = function (t) {
                    return "audio" === t.type ? t.isAAC || "mp3" !== t.codec ? U.box(U.types.stsd, U.STSD, U.mp4a(t)) : U.box(U.types.stsd, U.STSD, U.mp3(t)) : U.box(U.types.stsd, U.STSD, U.avc1(t))
                  }, U.tkhd = function (t) {
                    var e = t.id,
                      r = t.duration * t.timescale,
                      i = t.width,
                      n = t.height,
                      t = Math.floor(r / (1 + N)),
                      r = Math.floor(r % (1 + N));
                    return U.box(U.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, 0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, i >> 8 & 255, 255 & i, 0, 0, n >> 8 & 255, 255 & n, 0, 0]))
                  }, U.traf = function (t, e) {
                    var r = U.sdtp(t),
                      i = t.id,
                      n = Math.floor(e / (1 + N)),
                      e = Math.floor(e % (1 + N));
                    return U.box(U.types.traf, U.box(U.types.tfhd, new Uint8Array([0, 0, 0, 0, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i])), U.box(U.types.tfdt, new Uint8Array([1, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, e >> 24, e >> 16 & 255, e >> 8 & 255, 255 & e])), U.trun(t, r.length + 16 + 20 + 8 + 16 + 8 + 8), r)
                  }, U.trak = function (t) {
                    return t.duration = t.duration || 4294967295, U.box(U.types.trak, U.tkhd(t), U.mdia(t))
                  }, U.trex = function (t) {
                    t = t.id;
                    return U.box(U.types.trex, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]))
                  }, U.trun = function (t, e) {
                    var r, i, n, a, s, o = t.samples || [],
                      l = o.length,
                      t = 12 + 16 * l,
                      u = new Uint8Array(t);
                    for (u.set([0, 0, 15, 1, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l, (e += 8 + t) >>> 24 & 255, e >>> 16 & 255, e >>> 8 & 255, 255 & e], 0), r = 0; r < l; r++) i = (s = o[r]).duration, n = s.size, a = s.flags, s = s.cts, u.set([i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, 255 & i, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, a.isLeading << 2 | a.dependsOn, a.isDependedOn << 6 | a.hasRedundancy << 4 | a.paddingValue << 1 | a.isNonSync, 61440 & a.degradPrio, 15 & a.degradPrio, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s], 12 + 16 * r);
                    return U.box(U.types.trun, u)
                  }, U.initSegment = function (t) {
                    U.types || U.init();
                    var e = U.moov(t),
                      t = new Uint8Array(U.FTYP.byteLength + e.byteLength);
                    return t.set(U.FTYP), t.set(e, U.FTYP.byteLength), t
                  }, U);

                function U() {}

                function B() {}
                a.types = void 0, a.HDLR_TYPES = void 0, a.STTS = void 0, a.STSC = void 0, a.STCO = void 0, a.STSZ = void 0, a.VMHD = void 0, a.SMHD = void 0, a.STSD = void 0, a.FTYP = void 0, a.DINF = void 0;
                var X = a;

                function $(t, e) {
                  return r = e = void 0 === e ? !1 : e, t = t * 1e3 * (t = void 0 === (t = 1 / 9e4) ? 1 : t), (r = void 0 === e ? !1 : r) ? Math.round(t) : t;
                  var r
                }

                function Q() {
                  return (Q = Object.assign || function (t) {
                    for (var e = 1; e < arguments.length; e++) {
                      var r, i = arguments[e];
                      for (r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
                    }
                    return t
                  }).apply(this, arguments)
                }
                var J = null,
                  a = ((e = G.prototype).destroy = function () {}, e.resetTimeStamp = function (t) {
                    Y.b.log("[mp4-remuxer]: initPTS & initDTS reset reset"), this._initPTS = this._initDTS = t
                  }, e.resetNextTimestamp = function () {
                    Y.b.log("[mp4-remuxer]: reset next timestamp"), this.isVideoContiguous = !1, this.isAudioContiguous = !1
                  }, e.resetInitSegment = function () {
                    Y.b.log("[mp4-remuxer]: ISGenerated flag reset"), this.ISGenerated = !1
                  }, e.getVideoStartPts = function (t) {
                    var i = !1,
                      t = t.reduce(function (t, e) {
                        var r = e.pts - t;
                        return r < -4294967296 ? (i = !0, Z(t, e.pts)) : 0 < r ? t : e.pts
                      }, t[0].pts);
                    return i && Y.b.debug("PTS rollover detected"), t
                  }, e.remux = function (t, e, r, i, n, a) {
                    var s, o, l, u, h = this.isVideoContiguous;
                    !h && this.config.forceKeyFrameOnDiscontinuity && (c = e.samples.length, (d = function (t) {
                      for (var e = t.samples, r = 0, i = 0; i < e.length && !e[i].key; i++) r++;
                      return r && (t.samples = e.slice(r), t.dropped += r), r
                    }(e)) && Y.b.warn("[mp4-remuxer]: Dropped " + d + " out of " + c + " video samples due to a missing keyframe"));
                    var d, c, f, g = -1 < e.pid,
                      m = 0 < t.samples.length,
                      v = 1 < e.samples.length;
                    return (!g || v || this.ISGenerated) && (this.ISGenerated || (o = this.generateIS(t, e, n)), this.ISGenerated) && (c = d = n, m && v && (g = this.getVideoStartPts(e.samples), g = (Z(t.samples[0].pts, g) - g) / e.inputTimeScale, d += Math.max(0, g), c += Math.max(0, -g)), m ? (t.samplerate || (Y.b.warn("[mp4-remuxer]: regenerate InitSegment as audio detected"), delete(o = this.generateIS(t, e, n)).video), s = this.remuxAudio(t, d, this.isAudioContiguous, a, c), v && (f = s ? s.endPTS - s.startPTS : 0, e.inputTimeScale || (Y.b.warn("[mp4-remuxer]: regenerate InitSegment as video detected"), o = this.generateIS(t, e, n)), f = this.remuxVideo(e, c, h, f))) : v && (f = this.remuxVideo(e, c, h, 0))), this.ISGenerated && (r.samples.length && (u = this.remuxID3(r, n)), i.samples.length && (l = this.remuxText(i, n))), {
                      audio: s,
                      video: f,
                      initSegment: o,
                      text: l,
                      id3: u
                    }
                  }, e.generateIS = function (t, e, r) {
                    Y.b.log("[mp4-remuxer]: generateIS", Q({}, t), Q({}, e), r);
                    var i, n, a, s = t.samples,
                      o = e.samples,
                      l = this.typeSupported,
                      u = {},
                      h = !Object(c.a)(this._initPTS),
                      d = "audio/mp4";
                    if (h && (a = n = 1 / 0), t.config && s.length && (t.timescale = t.samplerate, Y.b.log("[mp4-remuxer]: audio sampling rate : " + t.samplerate), t.isAAC || (l.mpeg ? (d = "audio/mpeg", t.codec = "") : l.mp3 && (t.codec = "mp3")), u.audio = {
                        id: "audio",
                        container: d,
                        codec: t.codec,
                        initSegment: !t.isAAC && l.mpeg ? new Uint8Array(0) : X.initSegment([t]),
                        metadata: {
                          channelCount: t.channelCount
                        }
                      }, h && (i = t.inputTimeScale, a = n = s[0].pts - Math.round(i * r))), e.sps && e.pps && o.length && (e.timescale = e.inputTimeScale, u.video = {
                        id: "main",
                        container: "video/mp4",
                        codec: e.codec,
                        initSegment: X.initSegment([e]),
                        metadata: {
                          width: e.width,
                          height: e.height
                        }
                      }, h) && (i = e.inputTimeScale, e = this.getVideoStartPts(o), r = Math.round(i * r), n = Math.min(n, Z(o[0].dts, e) - r), a = Math.min(a, e - r)), Object.keys(u).length) return this.ISGenerated = !0, h && (this._initPTS = a, this._initDTS = n), {
                      tracks: u,
                      initPTS: a,
                      timescale: i
                    }
                  }, e.remuxVideo = function (t, e, r, i) {
                    var n, a = t.inputTimeScale,
                      s = t.samples,
                      o = [],
                      l = s.length,
                      u = this._initPTS,
                      h = this.nextAvcDts,
                      d = 8,
                      c = Number.POSITIVE_INFINITY,
                      f = Number.NEGATIVE_INFINITY,
                      g = 0,
                      m = !1;
                    r && null !== h || (h = e * a - (s[0].pts - Z(s[0].dts, s[0].pts)));
                    for (var v = 0; v < l; v++) {
                      var p = s[v];
                      p.pts = Z(p.pts - u, h), p.dts = Z(p.dts - u, h), p.dts > p.pts && (g = Math.max(Math.min(g, p.pts - p.dts), -18e3)), p.dts < s[0 < v ? v - 1 : v].dts && (m = !0)
                    }
                    m && s.sort(function (t, e) {
                      var r = t.dts - e.dts,
                        e = t.pts - e.pts;
                      return r || e
                    }), y = s[0].dts;
                    var y, e = s[s.length - 1].dts,
                      E = Math.round((e - y) / (l - 1));
                    if (g < 0) {
                      if (g < -2 * E) {
                        Y.b.warn("PTS < DTS detected in video samples, offsetting DTS from PTS by " + $(-E, !0) + " ms");
                        for (var b = g, S = 0; S < l; S++) s[S].dts = b = Math.max(b, s[S].pts - E), s[S].pts = Math.max(b, s[S].pts)
                      } else {
                        Y.b.warn("PTS < DTS detected in video samples, shifting DTS by " + $(g, !0) + " ms to overcome this issue");
                        for (var _ = 0; _ < l; _++) s[_].dts = s[_].dts + g
                      }
                      y = s[0].dts, e = s[l - 1].dts
                    }!r || ((r = E < (P = y - h)) || P < -1) && (r ? Y.b.warn("AVC: " + $(P, !0) + " ms (" + P + "dts) hole between fragments detected, filling it") : Y.b.warn("AVC: " + $(-P, !0) + " ms (" + P + "dts) overlapping between fragments detected"), r = s[0].pts - P, s[0].dts = y = h, s[0].pts = r, Y.b.log("Video: First PTS/DTS adjusted: " + $(r, !0) + "/" + $(y, !0) + ", delta: " + $(P, !0) + " ms")), J && J < 75 && (y = Math.max(0, y));
                    for (var L = 0, T = 0, A = 0; A < l; A++) {
                      for (var R = s[A], D = R.units, k = D.length, C = 0, w = 0; w < k; w++) C += D[w].data.length;
                      T += C, L += k, R.length = C, R.dts = Math.max(R.dts, y), R.pts = Math.max(R.pts, R.dts, 0), c = Math.min(R.pts, c), f = Math.max(R.pts, f)
                    }
                    e = s[l - 1].dts;
                    var x, P = T + 4 * L + 8;
                    try {
                      x = new Uint8Array(P)
                    } catch (t) {
                      return void this.observer.emit(K.a.ERROR, K.a.ERROR, {
                        type: W.b.MUX_ERROR,
                        details: W.a.REMUX_ALLOC_ERROR,
                        fatal: !1,
                        bytes: P,
                        reason: "fail allocating video mdat " + P
                      })
                    }
                    var O, F = new DataView(x.buffer);
                    F.setUint32(0, P), x.set(X.types.mdat, 4);
                    for (var I = 0; I < l; I++) {
                      for (var M, N, U = s[I], B = U.units, H = 0, G = 0, j = B.length; G < j; G++) {
                        var V = B[G],
                          z = V.data,
                          V = V.data.byteLength;
                        F.setUint32(d, V), d += 4, x.set(z, d), d += V, H += 4 + V
                      }
                      I < l - 1 ? (n = s[I + 1].dts - U.dts, M = void 0, O = -1 < navigator.userAgent.toLowerCase().indexOf("chrome"), M = -1 < navigator.userAgent.toLowerCase().indexOf("safari"), !O && M && (n = E)) : (M = this.config, q = U.dts - s[0 < I ? I - 1 : I].dts, M.stretchShortVideoTrack && null !== this.nextAudioPts && Math.floor(M.maxBufferHole * a) < (N = (i ? c + i * a : this.nextAudioPts) - U.pts) ? ((n = N - q) < 0 && (n = q), Y.b.log("[mp4-remuxer]: It is approximately " + N / 90 + " ms to the next segment; using duration " + n / 90 + " ms for the last video frame.")) : n = q);
                      var q = Math.round(U.pts - U.dts);
                      o.push(new tt(U.key, n, H, q))
                    }
                    o.length && J && J < 70 && ((P = o[0].flags).dependsOn = 2, P.isNonSync = 0), this.nextAvcDts = h = e + n, this.isVideoContiguous = !0;
                    e = {
                      data1: X.moof(t.sequenceNumber++, y, Q({}, t, {
                        samples: o
                      })),
                      data2: x,
                      startPTS: c / a,
                      endPTS: (f + n) / a,
                      startDTS: y / a,
                      endDTS: h / a,
                      type: "video",
                      hasAudio: !1,
                      hasVideo: !0,
                      nb: o.length,
                      dropped: t.dropped
                    };
                    return t.samples = [], t.dropped = 0, e
                  }, e.remuxAudio = function (t, e, r, i, n) {
                    var a, s = t.inputTimeScale,
                      o = t.samplerate || s,
                      l = s / o,
                      u = t.isAAC ? 1024 : 1152,
                      h = u * l,
                      d = this._initPTS,
                      c = !t.isAAC && this.typeSupported.mpeg,
                      f = [],
                      g = t.samples,
                      m = c ? 0 : 8,
                      v = this.nextAudioPts || -1;
                    if (this.isAudioContiguous = r = r || g.length && 0 < v && (i && Math.abs(e - v / s) < .1 || Math.abs(g[0].pts - v - d) < 20 * h), g.forEach(function (t) {
                        t.pts = t.dts = Z(t.pts - d, e * s)
                      }), (g = g.filter(function (t) {
                        return 0 <= t.pts
                      })).length) {
                      if ((!r || v < 0) && (v = 0 === n ? 0 : i ? Math.max(0, e * s) : g[0].pts), t.isAAC)
                        for (var p = this.config.maxAudioFramesDrift, y = 0, E = v; y < g.length;) {
                          var b = g[y],
                            S = b.pts,
                            _ = S - E,
                            L = Math.abs(1e3 * _ / s);
                          if (_ <= -p * h) r || 0 < y ? (Y.b.warn("[mp4-remuxer]: Dropping 1 audio frame @ " + (E / s).toFixed(3) + "s due to " + Math.round(L) + " ms overlap."), g.splice(y, 1)) : (Y.b.warn("Audio frame @ " + (S / s).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1e3 * _ / s) + " ms."), E = S + h, y++);
                          else if (p * h <= _ && L < 1e4) {
                            var T = Math.floor(_ / h);
                            Y.b.warn("[mp4-remuxer]: Injecting " + T + " audio frame @ " + ((E = S - T * h) / s).toFixed(3) + "s due to " + Math.round(1e3 * _ / s) + " ms gap.");
                            for (var A = 0; A < T; A++) {
                              var R = Math.max(E, 0);
                              (a = H.getSilentFrame(t.manifestCodec || t.codec, t.channelCount)) || (Y.b.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead."), a = b.unit.subarray()), g.splice(y, 0, {
                                unit: a,
                                pts: R,
                                dts: R
                              }), E += h, y++
                            }
                            b.pts = b.dts = E, E += h, y++
                          } else b.pts = b.dts = E, E += h, y++
                        }
                      for (var D, k = null, C = null, w = 0, x = g.length; x--;) w += g[x].unit.byteLength;
                      for (var P = 0, O = g.length; P < O; P++) {
                        var F = g[P],
                          I = F.unit,
                          F = F.pts;
                        if (null !== C) f[P - 1].duration = Math.round((F - C) / l);
                        else {
                          var M = Math.round(1e3 * (F - v) / s),
                            N = 0;
                          if (r && t.isAAC) {
                            if (0 < M && M < 1e4) N = Math.round((F - v) / h), Y.b.log("[mp4-remuxer]: " + M + " ms hole between AAC samples detected,filling it"), 0 < N && (w += N * (a = !(a = H.getSilentFrame(t.manifestCodec || t.codec, t.channelCount)) ? I.subarray() : a).length);
                            else if (M < -12) {
                              Y.b.log("[mp4-remuxer]: drop overlapping AAC sample, expected/parsed/delta:" + (v / s).toFixed(3) + "s/" + (F / s).toFixed(3) + "s/" + -M + "ms"), w -= I.byteLength;
                              continue
                            }
                            F = v
                          }
                          if (k = F, !(0 < w)) return;
                          w += m;
                          try {
                            D = new Uint8Array(w)
                          } catch (t) {
                            return void this.observer.emit(K.a.ERROR, K.a.ERROR, {
                              type: W.b.MUX_ERROR,
                              details: W.a.REMUX_ALLOC_ERROR,
                              fatal: !1,
                              bytes: w,
                              reason: "fail allocating audio mdat " + w
                            })
                          }
                          c || (new DataView(D.buffer).setUint32(0, w), D.set(X.types.mdat, 4));
                          for (var U = 0; U < N; U++)(a = H.getSilentFrame(t.manifestCodec || t.codec, t.channelCount)) || (Y.b.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating the current frame instead"), a = I.subarray()), D.set(a, m), m += a.byteLength, f.push(new tt(!0, 1024, a.byteLength, 0))
                        }
                        D.set(I, m);
                        M = I.byteLength;
                        m += M, f.push(new tt(!0, u, M, 0)), C = F
                      }
                      var B = f.length;
                      if (B) {
                        o = f[f.length - 1];
                        this.nextAudioPts = v = C + l * o.duration;
                        n = c ? new Uint8Array(0) : X.moof(t.sequenceNumber++, k / l, Q({}, t, {
                          samples: f
                        }));
                        t.samples = [];
                        i = k / s, o = v / s;
                        return {
                          data1: n,
                          data2: D,
                          startPTS: i,
                          endPTS: o,
                          startDTS: i,
                          endDTS: o,
                          type: "audio",
                          hasAudio: !0,
                          hasVideo: !1,
                          nb: B
                        }
                      }
                    }
                  }, e.remuxEmptyAudio = function (t, e, r, i) {
                    var n = t.inputTimeScale,
                      a = n / (t.samplerate || n),
                      s = this.nextAudioPts,
                      o = (null !== s ? s : i.startDTS * n) + this._initDTS,
                      n = i.endDTS * n + this._initDTS,
                      l = 1024 * a,
                      u = Math.ceil((n - o) / l),
                      h = H.getSilentFrame(t.manifestCodec || t.codec, t.channelCount);
                    if (Y.b.warn("[mp4-remuxer]: remux empty Audio"), h) {
                      for (var d = [], c = 0; c < u; c++) {
                        var f = o + c * l;
                        d.push({
                          unit: h,
                          pts: f,
                          dts: f
                        })
                      }
                      return t.samples = d, this.remuxAudio(t, e, r, !1)
                    }
                    Y.b.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec")
                  }, e.remuxID3 = function (t, e) {
                    var r = t.samples.length;
                    if (r) {
                      for (var i = t.inputTimeScale, n = this._initPTS, a = this._initDTS, s = 0; s < r; s++) {
                        var o = t.samples[s];
                        o.pts = Z(o.pts - n, e * i) / i, o.dts = Z(o.dts - a, e * i) / i
                      }
                      var l = t.samples;
                      return t.samples = [], {
                        samples: l
                      }
                    }
                  }, e.remuxText = function (t, e) {
                    var r = t.samples.length;
                    if (r) {
                      for (var i = t.inputTimeScale, n = this._initPTS, a = 0; a < r; a++) {
                        var s = t.samples[a];
                        s.pts = Z(s.pts - n, e * i) / i
                      }
                      t.samples.sort(function (t, e) {
                        return t.pts - e.pts
                      });
                      var o = t.samples;
                      return t.samples = [], {
                        samples: o
                      }
                    }
                  }, G);

                function G(t, e, r, i) {
                  this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = void 0, this._initDTS = void 0, this.nextAvcDts = null, this.nextAudioPts = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.observer = t, this.config = e, this.typeSupported = r, this.ISGenerated = !1, null === J && (r = (navigator.userAgent || "").match(/Chrome\/(\d+)/i), J = r ? parseInt(r[1]) : 0)
                }

                function Z(t, e) {
                  var r;
                  if (null === e) return t;
                  for (r = e < t ? -8589934592 : 8589934592; 4294967296 < Math.abs(t - e);) t += r;
                  return t
                }
                var j, tt = function (t, e, r, i) {
                    this.size = void 0, this.duration = void 0, this.cts = void 0, this.flags = void 0, this.duration = e, this.size = r, this.cts = i, this.flags = new V(t)
                  },
                  V = function (t) {
                    this.isLeading = 0, this.isDependedOn = 0, this.hasRedundancy = 0, this.degradPrio = 0, this.dependsOn = 1, this.isNonSync = 1, this.dependsOn = t ? 2 : 1, this.isNonSync = t ? 0 : 1
                  },
                  e = ((e = et.prototype).destroy = function () {}, e.resetTimeStamp = function (t) {
                    this.initPTS = t, this.lastEndDTS = null
                  }, e.resetNextTimestamp = function () {
                    this.lastEndDTS = null
                  }, e.resetInitSegment = function (t, e, r) {
                    this.audioCodec = e, this.videoCodec = r, this.generateInitSegment(t), this.emitInitSegment = !0
                  }, e.generateInitSegment = function (t) {
                    var e = this.audioCodec,
                      r = this.videoCodec;
                    if (!t || !t.byteLength) return this.initTracks = void 0, void(this.initData = void 0);
                    var i = this.initData = Object(D.f)(t),
                      e = e || "mp4a.40.5",
                      r = r || "avc1.42e01e",
                      n = {};
                    i.audio && i.video ? n.audiovideo = {
                      container: "video/mp4",
                      codec: e + "," + r,
                      initSegment: t,
                      id: "main"
                    } : i.audio ? n.audio = {
                      container: "audio/mp4",
                      codec: e,
                      initSegment: t,
                      id: "audio"
                    } : i.video ? n.video = {
                      container: "video/mp4",
                      codec: r,
                      initSegment: t,
                      id: "main"
                    } : Y.b.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes."), this.initTracks = n
                  }, e.remux = function (t, e, r, i, n) {
                    var a = this.initPTS,
                      s = this.lastEndDTS,
                      o = {
                        audio: void 0,
                        video: void 0,
                        text: i,
                        id3: r,
                        initSegment: void 0
                      };
                    Object(c.a)(s) || (s = this.lastEndDTS = n || 0);
                    var l = e.samples;
                    if (!l || !l.length) return o;
                    var u = {
                        initPTS: void 0,
                        timescale: 1
                      },
                      h = this.initData;
                    if (h && h.length || (this.generateInitSegment(l), h = this.initData), !h || !h.length) return Y.b.warn("[passthrough-remuxer.ts]: Failed to generate initSegment."), o;
                    this.emitInitSegment && (u.tracks = this.initTracks, this.emitInitSegment = !1), Object(c.a)(a) || (this.initPTS = u.initPTS = a = z(h, l, n));
                    e = s, n = Object(D.c)(l, h) + e;
                    Object(D.e)(h, l, a), this.lastEndDTS = n;
                    s = !!h.audio, a = !!h.video, h = "";
                    s && (h += "audio"), a && (h += "video");
                    a = {
                      data1: l,
                      startPTS: e,
                      startDTS: e,
                      endPTS: n,
                      endDTS: n,
                      type: h,
                      hasAudio: s,
                      hasVideo: a,
                      nb: 1,
                      dropped: 0
                    };
                    return o.audio = "audio" === a.type ? a : void 0, o.video = "audio" !== a.type ? a : void 0, o.text = i, o.id3 = r, o.initSegment = u, o
                  }, et),
                  z = function (t, e, r) {
                    return Object(D.d)(t, e) - r
                  },
                  e = e,
                  q = r(15);

                function et() {
                  this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = void 0, this.initTracks = void 0, this.lastEndDTS = null
                }
                try {
                  j = self.performance.now.bind(self.performance)
                } catch (t) {
                  Y.b.debug("Unable to use Performance API on this environment"), j = self.Date.now
                }
                var rt = [{
                    demux: h,
                    remux: a
                  }, {
                    demux: i,
                    remux: e
                  }, {
                    demux: y,
                    remux: a
                  }, {
                    demux: E,
                    remux: a
                  }],
                  it = 1024;
                rt.forEach(function (t) {
                  t = t.demux;
                  it = Math.max(it, t.minProbeByteLength)
                });
                var nt = ((a = at.prototype).configure = function (t, e) {
                  this.transmuxConfig = t, this.currentTransmuxState = e, this.decrypter && this.decrypter.reset()
                }, a.push = function (t, e, r) {
                  var i = this,
                    n = r.transmuxing;
                  n.executeStart = j();
                  var a = new Uint8Array(t),
                    s = this.cache,
                    o = this.config,
                    l = this.currentTransmuxState,
                    u = this.transmuxConfig,
                    h = (y = null, y = 0 < a.byteLength && null != e && null != e.key ? e.method : y);
                  if ("AES-128" === h) {
                    var d = this.getDecrypter();
                    if (!o.enableSoftwareAES) return this.decryptionPromise = d.webCryptoDecrypt(a, e.key.buffer, e.iv.buffer).then(function (t) {
                      t = i.push(t, null, r);
                      return i.decryptionPromise = null, t
                    }), this.decryptionPromise;
                    var c = d.softwareDecrypt(a, e.key.buffer, e.iv.buffer);
                    if (!c) return n.executeEnd = j(), st(r);
                    a = new Uint8Array(c)
                  }
                  var f = l.contiguous,
                    g = l.discontinuity,
                    m = l.trackSwitch,
                    v = l.accurateTimeOffset,
                    p = l.timeOffset,
                    t = u.audioCodec,
                    y = u.videoCodec,
                    o = u.defaultInitPts,
                    d = u.duration,
                    c = u.initSegmentData;
                  (g || m) && this.resetInitSegment(c, t, y, d), g && this.resetInitialTimestamp(o), f || this.resetContiguity();
                  o = this.demuxer, f = this.remuxer;
                  if (this.needsProbing(a, g, m) && (s.dataLength && (m = s.flush(), a = Object(D.a)(m, a)), o = (u = this.configureTransmuxer(a, u)).demuxer, f = u.remuxer), !o || !f) return s.push(a), n.executeEnd = j(), st(r);
                  v = this.transmux(a, e, h, p, v, r);
                  return l.contiguous = !0, l.discontinuity = !1, l.trackSwitch = !1, n.executeEnd = j(), v
                }, a.flush = function (t) {
                  var e = this,
                    r = t.transmuxing;
                  r.executeStart = j();
                  var i = this.decrypter,
                    n = this.cache,
                    a = this.currentTransmuxState,
                    s = this.decryptionPromise,
                    o = this.observer,
                    l = [];
                  if (s) return s.then(function () {
                    return e.flush(t)
                  });
                  var u = a.accurateTimeOffset,
                    s = a.timeOffset;
                  !i || (h = i.flush()) && l.push(this.push(h, null, t));
                  a = n.dataLength;
                  n.reset();
                  var i = this.demuxer,
                    h = this.remuxer;
                  if (!i || !h) return it <= a && o.emit(K.a.ERROR, K.a.ERROR, {
                    type: W.b.MEDIA_ERROR,
                    details: W.a.FRAG_PARSING_ERROR,
                    fatal: !0,
                    reason: "no demux matching with content found"
                  }), r.executeEnd = j(), [st(t)];
                  n = i.flush(s), a = n.audioTrack, o = n.avcTrack, i = n.id3Track, n = n.textTrack;
                  return Y.b.log("[transmuxer.ts]: Flushed fragment " + t.sn + " of level " + t.level), l.push({
                    remuxResult: h.remux(a, o, i, n, s, u),
                    chunkMeta: t
                  }), r.executeEnd = j(), l
                }, a.resetInitialTimestamp = function (t) {
                  var e = this.demuxer,
                    r = this.remuxer;
                  e && r && (e.resetTimeStamp(t), r.resetTimeStamp(t))
                }, a.resetContiguity = function () {
                  var t = this.demuxer,
                    e = this.remuxer;
                  t && e && (t.resetContiguity(), e.resetNextTimestamp())
                }, a.resetInitSegment = function (t, e, r, i) {
                  var n = this.demuxer,
                    a = this.remuxer;
                  n && a && (n.resetInitSegment(e, r, i), a.resetInitSegment(t, e, r))
                }, a.destroy = function () {
                  this.demuxer && (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer && (this.remuxer.destroy(), this.remuxer = void 0)
                }, a.transmux = function (t, e, r, i, n, a) {
                  return "SAMPLE-AES" === r ? this.transmuxSampleAes(t, e, i, n, a) : this.transmuxUnencrypted(t, i, n, a)
                }, a.transmuxUnencrypted = function (t, e, r, i) {
                  var n = this.demuxer.demux(t, e, !1),
                    a = n.audioTrack,
                    s = n.avcTrack,
                    t = n.id3Track,
                    n = n.textTrack;
                  return {
                    remuxResult: this.remuxer.remux(a, s, t, n, e, r),
                    chunkMeta: i
                  }
                }, a.transmuxSampleAes = function (t, e, r, i, n) {
                  var a = this;
                  return this.demuxer.demuxSampleAes(t, e, r).then(function (t) {
                    return {
                      remuxResult: a.remuxer.remux(t.audioTrack, t.avcTrack, t.id3Track, t.textTrack, r, i),
                      chunkMeta: n
                    }
                  })
                }, a.configureTransmuxer = function (t, e) {
                  for (var r, i = this.config, n = this.observer, a = this.typeSupported, s = this.vendor, o = e.audioCodec, l = e.defaultInitPts, u = e.duration, h = e.initSegmentData, d = e.videoCodec, c = 0, f = rt.length; c < f && !(r = rt[c]).demux.probe(t); c++);
                  if (!r) return {
                    remuxer: void 0,
                    demuxer: void 0
                  };
                  var g = this.demuxer,
                    e = this.remuxer;
                  return e && e instanceof r.remux || (e = this.remuxer = new r.remux(n, i, a, s)), g && g instanceof r.demux || (g = this.demuxer = new r.demux(n, i, a), this.probe = r.demux.probe), this.resetInitSegment(h, o, d, u), this.resetInitialTimestamp(l), Y.b.log("[transmuxer]: Probe succeeded with a data length of " + t.length + "."), {
                    demuxer: g,
                    remuxer: e
                  }
                }, a.needsProbing = function (t, e, r) {
                  return !this.demuxer || e || r
                }, a.getDecrypter = function () {
                  return this.decrypter || (this.decrypter = new n.a(this.observer, this.config))
                }, at);

                function at(t, e, r, i) {
                  this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.vendor = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.cache = new q.a, this.observer = t, this.typeSupported = e, this.config = r, this.vendor = i
                }
                var st = function (t) {
                  return {
                    remuxResult: {},
                    chunkMeta: t
                  }
                };

                function ot(t) {
                  return "then" in t && t.then instanceof Function
                }
                var lt = function (t, e, r, i, n) {
                    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = t, this.videoCodec = e, this.initSegmentData = r, this.duration = i, this.defaultInitPts = n
                  },
                  ut = function (t, e, r, i, n) {
                    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.discontinuity = t, this.contiguous = e, this.accurateTimeOffset = r, this.trackSwitch = i, this.timeOffset = n
                  }
              }, function (t, e, r) {
                r.d(e, "a", function () {
                  return i
                }), r.d(e, "b", function () {
                  return n
                });
                var i = function () {
                  this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {
                    start: 0,
                    first: 0,
                    end: 0
                  }, this.parsing = {
                    start: 0,
                    end: 0
                  }, this.buffering = {
                    start: 0,
                    first: 0,
                    end: 0
                  }
                };

                function n(t) {
                  t.loading = {
                    start: 0,
                    first: 0,
                    end: 0
                  }, t.parsing = {
                    start: 0,
                    end: 0
                  }, t.buffering = {
                    start: 0,
                    first: 0,
                    end: 0
                  }, t.loaded = 0, t.aborted = !1, t.retry = 0, t.chunkCount = 0
                }
              }, function (t, e) {
                t.exports = void 0
              }, function (t, e, r) {
                var i = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/?#]*\/)*[^;?#]*)?(;[^?#]*)?(\?[^#]*)?(#.*)?$/,
                  a = /^([^\/?#]*)(.*)$/,
                  n = /(?:\/|^)\.(?=\/)/g,
                  s = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g,
                  o = {
                    buildAbsoluteURL: function (t, e, r) {
                      if (r = r || {}, t = t.trim(), !(e = e.trim())) {
                        if (!r.alwaysNormalize) return t;
                        var i = o.parseURL(t);
                        if (!i) throw new Error("Error trying to parse base URL.");
                        return i.path = o.normalizePath(i.path), o.buildURLFromParts(i)
                      }
                      i = o.parseURL(e);
                      if (!i) throw new Error("Error trying to parse relative URL.");
                      if (i.scheme) return r.alwaysNormalize ? (i.path = o.normalizePath(i.path), o.buildURLFromParts(i)) : e;
                      e = o.parseURL(t);
                      if (!e) throw new Error("Error trying to parse base URL.");
                      !e.netLoc && e.path && "/" !== e.path[0] && (n = a.exec(e.path), e.netLoc = n[1], e.path = n[2]), e.netLoc && !e.path && (e.path = "/");
                      var n, t = {
                        scheme: e.scheme,
                        netLoc: i.netLoc,
                        path: null,
                        params: i.params,
                        query: i.query,
                        fragment: i.fragment
                      };
                      return i.netLoc || (t.netLoc = e.netLoc, "/" === i.path[0]) || (i.path ? (n = (n = e.path).substring(0, n.lastIndexOf("/") + 1) + i.path, t.path = o.normalizePath(n)) : (t.path = e.path, i.params || (t.params = e.params, i.query || (t.query = e.query)))), null === t.path && (t.path = r.alwaysNormalize ? o.normalizePath(i.path) : i.path), o.buildURLFromParts(t)
                    },
                    parseURL: function (t) {
                      t = i.exec(t);
                      return t ? {
                        scheme: t[1] || "",
                        netLoc: t[2] || "",
                        path: t[3] || "",
                        params: t[4] || "",
                        query: t[5] || "",
                        fragment: t[6] || ""
                      } : null
                    },
                    normalizePath: function (t) {
                      for (t = t.split("").reverse().join("").replace(n, ""); t.length !== (t = t.replace(s, "")).length;);
                      return t.split("").reverse().join("")
                    },
                    buildURLFromParts: function (t) {
                      return t.scheme + t.netLoc + t.path + t.params + t.query + t.fragment
                    }
                  };
                t.exports = o
              }, function (t, e, r) {
                var i = Object.prototype.hasOwnProperty,
                  f = "~";

                function n() {}

                function a(t, e, r) {
                  this.fn = t, this.context = e, this.once = r || !1
                }

                function s(t, e, r, i, n) {
                  if ("function" != typeof r) throw new TypeError("The listener must be a function");
                  n = new a(r, i || t, n), e = f ? f + e : e;
                  return t._events[e] ? t._events[e].fn ? t._events[e] = [t._events[e], n] : t._events[e].push(n) : (t._events[e] = n, t._eventsCount++), t
                }

                function l(t, e) {
                  0 == --t._eventsCount ? t._events = new n : delete t._events[e]
                }

                function o() {
                  this._events = new n, this._eventsCount = 0
                }
                Object.create && (n.prototype = Object.create(null), (new n).__proto__ || (f = !1)), o.prototype.eventNames = function () {
                  var t, e, r = [];
                  if (0 === this._eventsCount) return r;
                  for (e in t = this._events) i.call(t, e) && r.push(f ? e.slice(1) : e);
                  return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(t)) : r
                }, o.prototype.listeners = function (t) {
                  var e = this._events[f ? f + t : t];
                  if (!e) return [];
                  if (e.fn) return [e.fn];
                  for (var r = 0, i = e.length, n = new Array(i); r < i; r++) n[r] = e[r].fn;
                  return n
                }, o.prototype.listenerCount = function (t) {
                  t = this._events[f ? f + t : t];
                  return t ? t.fn ? 1 : t.length : 0
                }, o.prototype.emit = function (t, e, r, i, n, a) {
                  var s = f ? f + t : t;
                  if (!this._events[s]) return !1;
                  var o, l = this._events[s],
                    u = arguments.length;
                  if (l.fn) {
                    switch (l.once && this.removeListener(t, l.fn, void 0, !0), u) {
                    case 1:
                      return l.fn.call(l.context), !0;
                    case 2:
                      return l.fn.call(l.context, e), !0;
                    case 3:
                      return l.fn.call(l.context, e, r), !0;
                    case 4:
                      return l.fn.call(l.context, e, r, i), !0;
                    case 5:
                      return l.fn.call(l.context, e, r, i, n), !0;
                    case 6:
                      return l.fn.call(l.context, e, r, i, n, a), !0
                    }
                    for (c = 1, o = new Array(u - 1); c < u; c++) o[c - 1] = arguments[c];
                    l.fn.apply(l.context, o)
                  } else
                    for (var h, d = l.length, c = 0; c < d; c++) switch (l[c].once && this.removeListener(t, l[c].fn, void 0, !0), u) {
                    case 1:
                      l[c].fn.call(l[c].context);
                      break;
                    case 2:
                      l[c].fn.call(l[c].context, e);
                      break;
                    case 3:
                      l[c].fn.call(l[c].context, e, r);
                      break;
                    case 4:
                      l[c].fn.call(l[c].context, e, r, i);
                      break;
                    default:
                      if (!o)
                        for (h = 1, o = new Array(u - 1); h < u; h++) o[h - 1] = arguments[h];
                      l[c].fn.apply(l[c].context, o)
                    }
                  return !0
                }, o.prototype.on = function (t, e, r) {
                  return s(this, t, e, r, !1)
                }, o.prototype.once = function (t, e, r) {
                  return s(this, t, e, r, !0)
                }, o.prototype.removeListener = function (t, e, r, i) {
                  t = f ? f + t : t;
                  if (!this._events[t]) return this;
                  if (!e) return l(this, t), this;
                  var n = this._events[t];
                  if (n.fn) n.fn !== e || i && !n.once || r && n.context !== r || l(this, t);
                  else {
                    for (var a = 0, s = [], o = n.length; a < o; a++)(n[a].fn !== e || i && !n[a].once || r && n[a].context !== r) && s.push(n[a]);
                    s.length ? this._events[t] = 1 === s.length ? s[0] : s : l(this, t)
                  }
                  return this
                }, o.prototype.removeAllListeners = function (t) {
                  return t ? this._events[t = f ? f + t : t] && l(this, t) : (this._events = new n, this._eventsCount = 0), this
                }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prefixed = f, t.exports = o.EventEmitter = o
              }, function (t, e, r) {
                r.d(e, "a", function () {
                  return d
                });
                var s = (n.prototype.decrypt = function (t, e) {
                    return this.subtle.decrypt({
                      name: "AES-CBC",
                      iv: this.aesIV
                    }, e, t)
                  }, n),
                  o = (i.prototype.expandKey = function () {
                    return this.subtle.importKey("raw", this.key, {
                      name: "AES-CBC"
                    }, !1, ["encrypt", "decrypt"])
                  }, i),
                  l = r(7);

                function i(t, e) {
                  this.subtle = void 0, this.key = void 0, this.subtle = t, this.key = e
                }

                function n(t, e) {
                  this.subtle = void 0, this.aesIV = void 0, this.subtle = t, this.aesIV = e
                }
                var u = ((e = f.prototype).uint8ArrayToUint32Array_ = function (t) {
                    for (var e = new DataView(t), r = new Uint32Array(4), i = 0; i < 4; i++) r[i] = e.getUint32(4 * i);
                    return r
                  }, e.initTable = function () {
                    for (var t = this.sBox, e = this.invSBox, r = this.subMix, i = r[0], n = r[1], a = r[2], s = r[3], r = this.invSubMix, o = r[0], l = r[1], u = r[2], h = r[3], d = new Uint32Array(256), c = 0, f = 0, g = 0, g = 0; g < 256; g++) d[g] = g < 128 ? g << 1 : g << 1 ^ 283;
                    for (g = 0; g < 256; g++) {
                      var m = f ^ f << 1 ^ f << 2 ^ f << 3 ^ f << 4;
                      t[c] = m = m >>> 8 ^ 255 & m ^ 99;
                      var v = d[e[m] = c],
                        p = d[v],
                        y = d[p],
                        E = 257 * d[m] ^ 16843008 * m;
                      i[c] = E << 24 | E >>> 8, n[c] = E << 16 | E >>> 16, a[c] = E << 8 | E >>> 24, s[c] = E, o[m] = (E = 16843009 * y ^ 65537 * p ^ 257 * v ^ 16843008 * c) << 24 | E >>> 8, l[m] = E << 16 | E >>> 16, u[m] = E << 8 | E >>> 24, h[m] = E, c ? (c = v ^ d[d[d[y ^ v]]], f ^= d[d[f]]) : c = f = 1
                    }
                  }, e.expandKey = function (t) {
                    for (var e = this.uint8ArrayToUint32Array_(t), r = !0, i = 0; i < e.length && r;) r = e[i] === this.key[i], i++;
                    if (!r) {
                      this.key = e;
                      var n = this.keySize = e.length;
                      if (4 !== n && 6 !== n && 8 !== n) throw new Error("Invalid aes key size=" + n);
                      for (var a, s, o, l = this.ksRows = 4 * (n + 6 + 1), u = this.keySchedule = new Uint32Array(l), h = this.invKeySchedule = new Uint32Array(l), d = this.sBox, c = this.rcon, t = this.invSubMix, f = t[0], g = t[1], m = t[2], v = t[3], p = 0; p < l; p++) p < n ? s = u[p] = e[p] : (o = s, p % n == 0 ? (o = d[(o = o << 8 | o >>> 24) >>> 24] << 24 | d[o >>> 16 & 255] << 16 | d[o >>> 8 & 255] << 8 | d[255 & o], o ^= c[p / n | 0] << 24) : 6 < n && p % n == 4 && (o = d[o >>> 24] << 24 | d[o >>> 16 & 255] << 16 | d[o >>> 8 & 255] << 8 | d[255 & o]), u[p] = s = (u[p - n] ^ o) >>> 0);
                      for (a = 0; a < l; a++) p = l - a, o = 3 & a ? u[p] : u[p - 4], h[a] = a < 4 || p <= 4 ? o : f[d[o >>> 24]] ^ g[d[o >>> 16 & 255]] ^ m[d[o >>> 8 & 255]] ^ v[d[255 & o]], h[a] = h[a] >>> 0
                    }
                  }, e.networkToHostOrderSwap = function (t) {
                    return t << 24 | (65280 & t) << 8 | (16711680 & t) >> 8 | t >>> 24
                  }, e.decrypt = function (t, e, r) {
                    for (var i, n, a, s, o, l, u, h, d, c, f, g, m, v, p = this.keySize + 6, y = this.invKeySchedule, E = this.invSBox, b = this.invSubMix, S = b[0], _ = b[1], L = b[2], T = b[3], r = this.uint8ArrayToUint32Array_(r), A = r[0], R = r[1], D = r[2], k = r[3], C = new Int32Array(t), w = new Int32Array(C.length), x = this.networkToHostOrderSwap; e < C.length;) {
                      for (d = x(C[e]), c = x(C[e + 1]), f = x(C[e + 2]), g = x(C[e + 3]), o = d ^ y[0], l = g ^ y[1], u = f ^ y[2], h = c ^ y[3], m = 4, v = 1; v < p; v++) i = S[o >>> 24] ^ _[l >> 16 & 255] ^ L[u >> 8 & 255] ^ T[255 & h] ^ y[m], n = S[l >>> 24] ^ _[u >> 16 & 255] ^ L[h >> 8 & 255] ^ T[255 & o] ^ y[m + 1], a = S[u >>> 24] ^ _[h >> 16 & 255] ^ L[o >> 8 & 255] ^ T[255 & l] ^ y[m + 2], s = S[h >>> 24] ^ _[o >> 16 & 255] ^ L[l >> 8 & 255] ^ T[255 & u] ^ y[m + 3], o = i, l = n, u = a, h = s, m += 4;
                      i = E[o >>> 24] << 24 ^ E[l >> 16 & 255] << 16 ^ E[u >> 8 & 255] << 8 ^ E[255 & h] ^ y[m], n = E[l >>> 24] << 24 ^ E[u >> 16 & 255] << 16 ^ E[h >> 8 & 255] << 8 ^ E[255 & o] ^ y[m + 1], a = E[u >>> 24] << 24 ^ E[h >> 16 & 255] << 16 ^ E[o >> 8 & 255] << 8 ^ E[255 & l] ^ y[m + 2], s = E[h >>> 24] << 24 ^ E[o >> 16 & 255] << 16 ^ E[l >> 8 & 255] << 8 ^ E[255 & u] ^ y[m + 3], m += 3, w[e] = x(i ^ A), w[e + 1] = x(s ^ R), w[e + 2] = x(a ^ D), w[e + 3] = x(n ^ k), A = d, R = c, D = f, k = g, e += 4
                    }
                    return w.buffer
                  }, f),
                  a = r(1),
                  h = r(4),
                  d = ((r = c.prototype).isSync = function () {
                    return this.config.enableSoftwareAES
                  }, r.flush = function () {
                    var t = this.currentResult;
                    if (t) {
                      var e, r, i = new Uint8Array(t);
                      return this.reset(), this.removePKCS7Padding ? (t = (r = (e = i).byteLength) && new DataView(e.buffer).getUint8(r - 1)) ? Object(l.a)(e, 0, r - t) : e : i
                    }
                    this.reset()
                  }, r.reset = function () {
                    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter && (this.softwareDecrypter = null)
                  }, r.softwareDecrypt = function (t, e, r) {
                    var i = this.currentIV,
                      n = this.currentResult,
                      a = this.remainderData;
                    this.logOnce("JS AES decrypt"), a && (t = Object(h.a)(a, t), this.remainderData = null);
                    t = this.getValidChunk(t);
                    if (!t.length) return null;
                    i && (r = i);
                    i = this.softwareDecrypter;
                    (i = i || (this.softwareDecrypter = new u)).expandKey(e);
                    return this.currentResult = i.decrypt(t.buffer, 0, r), this.currentIV = Object(l.a)(t, -16).buffer, n || null
                  }, r.webCryptoDecrypt = function (e, r, i) {
                    var n = this,
                      a = this.subtle;
                    return this.key === r && this.fastAesKey || (this.key = r, this.fastAesKey = new o(a, r)), this.fastAesKey.expandKey().then(function (t) {
                      return a ? new s(a, i).decrypt(e.buffer, t) : Promise.reject(new Error("web crypto not initialized"))
                    }).catch(function (t) {
                      return n.onWebCryptoError(t, e, r, i)
                    })
                  }, r.onWebCryptoError = function (t, e, r, i) {
                    return a.b.warn("[decrypter.ts]: WebCrypto Error, disable WebCrypto API:", t), this.config.enableSoftwareAES = !0, this.logEnabled = !0, this.softwareDecrypt(e, r, i)
                  }, r.getValidChunk = function (t) {
                    var e = t,
                      r = t.length - t.length % 16;
                    return r !== t.length && (e = Object(l.a)(t, 0, r), this.remainderData = Object(l.a)(t, r)), e
                  }, r.logOnce = function (t) {
                    this.logEnabled && (a.b.log("[decrypter.ts]: " + t), this.logEnabled = !1)
                  }, c);

                function c(t, e, r) {
                  r = (void 0 === r ? {} : r).removePKCS7Padding, r = void 0 === r || r;
                  if (this.logEnabled = !0, this.observer = void 0, this.config = void 0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.observer = t, this.config = e, this.removePKCS7Padding = r) try {
                    var i = self.crypto;
                    i ? this.subtle = i.subtle || i.webkitSubtle : this.config.enableSoftwareAES = !0
                  } catch (t) {}
                }

                function f() {
                  this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable()
                }
              }, function (t, e, r) {
                r.d(e, "a", function () {
                  return n
                });
                var i = r(11);
                var n = (a.fromURL = function (t, e) {
                  return new a(t, e)
                }, a.fromURI = function (t) {
                  return new a(t)
                }, function (t, e) {
                  for (var r = 0; r < e.length; r++) {
                    var i = e[r];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                  }
                }(a.prototype, [{
                  key: "uri",
                  get: function () {
                    return this._uri
                  }
                }]), a);

                function a(t, e) {
                  this._uri = null, this.method = null, this.keyFormat = null, this.keyFormatVersions = null, this.keyID = null, this.key = null, this.iv = null, this._uri = e ? Object(i.buildAbsoluteURL)(t, e, {
                    alwaysNormalize: !0
                  }) : t
                }
              }, function (t, e, r) {
                r.d(e, "a", function () {
                  return i
                });
                var i = ((e = n.prototype).push = function (t) {
                  this.chunks.push(t), this.dataLength += t.length
                }, e.flush = function () {
                  var t = this.chunks,
                    a = this.dataLength;
                  return t.length ? (t = 1 === t.length ? t[0] : function (t) {
                    for (var e = new Uint8Array(a), r = 0, i = 0; i < t.length; i++) {
                      var n = t[i];
                      e.set(n, r), r += n.length
                    }
                    return e
                  }(t), this.reset(), t) : new Uint8Array(0)
                }, e.reset = function () {
                  this.chunks.length = 0, this.dataLength = 0
                }, n);

                function n() {
                  this.chunks = [], this.dataLength = 0
                }
              }, function (t, e, c) {
                function a(r) {
                  var i = {};

                  function n(t) {
                    if (i[t]) return i[t].exports;
                    var e = i[t] = {
                      i: t,
                      l: !1,
                      exports: {}
                    };
                    return r[t].call(e.exports, e, e.exports, n), e.l = !0, e.exports
                  }
                  n.m = r, n.c = i, n.i = function (t) {
                    return t
                  }, n.d = function (t, e, r) {
                    n.o(t, e) || Object.defineProperty(t, e, {
                      configurable: !1,
                      enumerable: !0,
                      get: r
                    })
                  }, n.r = function (t) {
                    Object.defineProperty(t, "__esModule", {
                      value: !0
                    })
                  }, n.n = function (t) {
                    var e = t && t.__esModule ? function () {
                      return t.default
                    } : function () {
                      return t
                    };
                    return n.d(e, "a", e), e
                  }, n.o = function (t, e) {
                    return Object.prototype.hasOwnProperty.call(t, e)
                  }, n.p = "/", n.oe = function (t) {
                    throw console.error(t), t
                  };
                  var t = n(n.s = ENTRY_MODULE);
                  return t.default || t
                }

                function f(t) {
                  return (t + "").replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
                }
                t.exports = function (d, t) {
                  var r = {
                      main: c.m
                    },
                    i = (t = t || {}).all ? {
                      main: Object.keys(r.main)
                    } : function (t) {
                      for (var e = {
                          main: [d]
                        }, r = {
                          main: []
                        }, i = {
                          main: {}
                        };

                        function (r) {
                          return Object.keys(r).reduce(function (t, e) {
                            return t || 0 < r[e].length
                          }, !1)
                        }(e);)
                        for (var n = Object.keys(e), a = 0; a < n.length; a++) {
                          var s = n[a],
                            o = e[s].pop();
                          if (i[s] = i[s] || {}, !i[s][o] && t[s][o]) {
                            i[s][o] = !0, r[s] = r[s] || [], r[s].push(o);
                            for (var l = function (t, e, r) {
                                var i = {};
                                i[r] = [];
                                var n = e.toString();
                                if (!(e = n.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/))) return i;
                                for (var a, e = e[1], s = new RegExp("(\\\\n|\\W)" + f(e) + "\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)", "g"); a = s.exec(n);) "dll-reference" !== a[3] && i[r].push(a[3]);
                                for (s = new RegExp("\\(" + f(e) + '\\("(dll-reference\\s([\\.|\\-|\\+|\\w|/|@]+))"\\)\\)\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)', "g"); a = s.exec(n);) t[a[2]] || (i[r].push(a[1]), t[a[2]] = c(a[1]).m), i[a[2]] = i[a[2]] || [], i[a[2]].push(a[4]);
                                for (var o, l = Object.keys(i), u = 0; u < l.length; u++)
                                  for (var h = 0; h < i[l[u]].length; h++) o = i[l[u]][h], isNaN(+o) || (i[l[u]][h] = +i[l[u]][h]);
                                return i
                              }(t, t[s][o], s), u = Object.keys(l), h = 0; h < u.length; h++) e[u[h]] = e[u[h]] || [], e[u[h]] = e[u[h]].concat(l[u[h]])
                          }
                        }
                      return r
                    }(r),
                    n = "";
                  Object.keys(i).filter(function (t) {
                    return "main" !== t
                  }).forEach(function (e) {
                    for (var t = 0; i[e][t];) t++;
                    i[e].push(t), r[e][t] = "(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })", n = n + "var " + e + " = (" + a.toString().replace("ENTRY_MODULE", JSON.stringify(t)) + ")({" + i[e].map(function (t) {
                      return JSON.stringify(t) + ": " + r[e][t].toString()
                    }).join(",") + "});\n"
                  });
                  var n = n + "new ((" + a.toString().replace("ENTRY_MODULE", JSON.stringify(d)) + ")({" + i.main.map(function (t) {
                      return JSON.stringify(t) + ": " + r.main[t].toString()
                    }).join(",") + "}))(self);",
                    e = new window.Blob([n], {
                      type: "text/javascript"
                    });
                  if (t.bare) return e;
                  t = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(e), e = new window.Worker(t);
                  return e.objectURL = t, e
                }
              }, function (t, e, r) {
                r.r(e), r.d(e, "default", function () {
                  return a
                });
                var l = r(8),
                  i = r(0),
                  u = r(1),
                  n = r(12);

                function a(a) {
                  function s(t, e) {
                    a.postMessage({
                      event: t,
                      data: e
                    })
                  }
                  var o = new n.EventEmitter;
                  o.on(i.a.FRAG_DECRYPTED, s), o.on(i.a.ERROR, s), a.addEventListener("message", function (t) {
                    var e = t.data;
                    switch (e.cmd) {
                    case "init":
                      var r = JSON.parse(e.config);
                      r.debug = e.debug, a.transmuxer = new l.c(o, e.typeSupported, r, e.vendor), Object(u.a)(r.debug), s("init", null);
                      break;
                    case "configure":
                      a.transmuxer.configure(e.config, e.state);
                      break;
                    case "demux":
                      var i = a.transmuxer.push(e.data, e.decryptdata, e.chunkMeta);
                      Object(l.d)(i) ? i.then(function (t) {
                        h(a, t)
                      }) : h(a, i);
                      break;
                    case "flush":
                      var n = e.chunkMeta,
                        i = a.transmuxer.flush(n);
                      Object(l.d)(i) ? i.then(function (t) {
                        d(a, t, n)
                      }) : d(a, i, n)
                    }
                  })
                }

                function h(t, e) {
                  var r, i, n;
                  ((i = e.remuxResult).audio || i.video || i.text || i.id3 || i.initSegment) && (r = [], i = (n = e.remuxResult).audio, n = n.video, i && s(r, i), n && s(r, n), t.postMessage({
                    event: "transmuxComplete",
                    data: e
                  }, r))
                }

                function s(t, e) {
                  e.data1 && t.push(e.data1.buffer), e.data2 && t.push(e.data2.buffer)
                }

                function d(e, t, r) {
                  t.forEach(function (t) {
                    h(e, t)
                  }), e.postMessage({
                    event: "flush",
                    data: r
                  })
                }
              }, function (t, e, r) {
                r.r(e), r.d(e, "default", function () {
                  return He
                });
                var i = r(11),
                  g = r(2),
                  B = r(3),
                  p = r(0),
                  H = r(1),
                  s = r(4),
                  G = r(5);
                var j = (l.prototype.reloaded = function (t) {
                    if (!t) return this.advanced = !0, void(this.updated = !0);
                    var e = this.lastPartSn - t.lastPartSn,
                      r = this.lastPartIndex - t.lastPartIndex;
                    this.updated = this.endSN !== t.endSN || !!r || !!e, this.advanced = this.endSN > t.endSN || 0 < e || 0 == e && 0 < r, this.updated || this.advanced ? this.misses = Math.floor(.6 * t.misses) : this.misses = t.misses + 1, this.availabilityDelay = t.availabilityDelay
                  }, function (t, e) {
                    for (var r = 0; r < e.length; r++) {
                      var i = e[r];
                      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                  }(l.prototype, [{
                    key: "hasProgramDateTime",
                    get: function () {
                      return !!this.fragments.length && Object(B.a)(this.fragments[this.fragments.length - 1].programDateTime)
                    }
                  }, {
                    key: "levelTargetDuration",
                    get: function () {
                      return this.averagetargetduration || this.targetduration || 10
                    }
                  }, {
                    key: "edge",
                    get: function () {
                      var t;
                      return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].end : null !== (t = this.fragments) && void 0 !== t && t.length ? this.fragments[this.fragments.length - 1].end : 0
                    }
                  }, {
                    key: "age",
                    get: function () {
                      return this.lastModified ? Math.max(Date.now() - this.lastModified, 0) / 1e3 : 0
                    }
                  }, {
                    key: "lastPartIndex",
                    get: function () {
                      var t;
                      return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].index : -1
                    }
                  }, {
                    key: "lastPartSn",
                    get: function () {
                      var t;
                      return null !== (t = this.partList) && void 0 !== t && t.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN
                    }
                  }]), l),
                  V = r(14),
                  n = /^(\d+)x(\d+)$/,
                  a = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g,
                  z = ((dt = o.prototype).decimalInteger = function (t) {
                    t = parseInt(this[t], 10);
                    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
                  }, dt.hexadecimalInteger = function (t) {
                    if (this[t]) {
                      for (var e = (1 & (e = (this[t] || "0x").slice(2)).length ? "0" : "") + e, r = new Uint8Array(e.length / 2), i = 0; i < e.length / 2; i++) r[i] = parseInt(e.slice(2 * i, 2 * i + 2), 16);
                      return r
                    }
                    return null
                  }, dt.hexadecimalIntegerAsNumber = function (t) {
                    t = parseInt(this[t], 16);
                    return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t
                  }, dt.decimalFloatingPoint = function (t) {
                    return parseFloat(this[t])
                  }, dt.optionalFloat = function (t, e) {
                    t = this[t];
                    return t ? parseFloat(t) : e
                  }, dt.enumeratedString = function (t) {
                    return this[t]
                  }, dt.bool = function (t) {
                    return "YES" === this[t]
                  }, dt.decimalResolution = function (t) {
                    t = n.exec(this[t]);
                    if (null !== t) return {
                      width: parseInt(t[1], 10),
                      height: parseInt(t[2], 10)
                    }
                  }, o.parseAttrList = function (t) {
                    var e, r = {};
                    for (a.lastIndex = 0; null !== (e = a.exec(t));) {
                      var i = e[2];
                      0 === i.indexOf('"') && i.lastIndexOf('"') === i.length - 1 && (i = i.slice(1, -1)), r[e[1]] = i
                    }
                    return r
                  }, o),
                  u = {
                    audio: {
                      a3ds: !0,
                      "ac-3": !0,
                      "ac-4": !0,
                      alac: !0,
                      alaw: !0,
                      dra1: !0,
                      "dts+": !0,
                      "dts-": !0,
                      dtsc: !0,
                      dtse: !0,
                      dtsh: !0,
                      "ec-3": !0,
                      enca: !0,
                      g719: !0,
                      g726: !0,
                      m4ae: !0,
                      mha1: !0,
                      mha2: !0,
                      mhm1: !0,
                      mhm2: !0,
                      mlpa: !0,
                      mp4a: !0,
                      "raw ": !0,
                      Opus: !0,
                      samr: !0,
                      sawb: !0,
                      sawp: !0,
                      sevc: !0,
                      sqcp: !0,
                      ssmv: !0,
                      twos: !0,
                      ulaw: !0
                    },
                    video: {
                      avc1: !0,
                      avc2: !0,
                      avc3: !0,
                      avc4: !0,
                      avcp: !0,
                      drac: !0,
                      dvav: !0,
                      dvhe: !0,
                      encv: !0,
                      hev1: !0,
                      hvc1: !0,
                      mjp2: !0,
                      mp4v: !0,
                      mvc1: !0,
                      mvc2: !0,
                      mvc3: !0,
                      mvc4: !0,
                      resv: !0,
                      rv60: !0,
                      s263: !0,
                      svc1: !0,
                      svc2: !0,
                      "vc-1": !0,
                      vp08: !0,
                      vp09: !0
                    },
                    text: {
                      stpp: !0,
                      wvtt: !0
                    }
                  };

                function o(t) {
                  for (var e in t = "string" == typeof t ? o.parseAttrList(t) : t) t.hasOwnProperty(e) && (this[e] = t[e])
                }

                function l(t) {
                  this.PTSKnown = !1, this.alignedSliding = !1, this.availabilityDelay = void 0, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.initSegment = null, this.lastModified = void 0, this.live = !0, this.needSidxRanges = !1, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.tload = void 0, this.totalduration = 0, this.type = null, this.updated = !0, this.advanced = !0, this.misses = 0, this.url = void 0, this.m3u8 = "", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.isMildomLiveEnd = !1, this.fragments = [], this.url = t
                }

                function d(t, e) {
                  return MediaSource.isTypeSupported((e || "video") + '/mp4;codecs="' + t + '"')
                }
                var m, v, h = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)|#EXT-X-SESSION-DATA:([^\n\r]*)[\r\n]+/g,
                  c = /#EXT-X-MEDIA:(.*)/g,
                  q = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /(?!#) *(\S[\S ]*)/.source, /#EXT-X-BYTERANGE:*(.+)/.source, /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /#.*/.source].join("|"), "g"),
                  K = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(PLAYLIST-TYPE):(.+)/.source, /#EXT-X-(MEDIA-SEQUENCE): *(\d+)/.source, /#EXT-X-(SKIP):(.+)/.source, /#EXT-X-(TARGETDURATION): *(\d+)/.source, /#EXT-X-(KEY):(.+)/.source, /#EXT-X-(START):(.+)/.source, /#EXT-X-(ENDLIST)/.source, /#EXT-X-(DISCONTINUITY-SEQ)UENCE: *(\d+)/.source, /#EXT-X-(DIS)CONTINUITY/.source, /#EXT-X-(VERSION):(\d+)/.source, /#EXT-X-(MAP):(.+)/.source, /#EXT-X-(SERVER-CONTROL):(.+)/.source, /#EXT-X-(PART-INF):(.+)/.source, /#EXT-X-(GAP)/.source, /#EXT-X-(BITRATE):\s*(\d+)/.source, /#EXT-X-(PART):(.+)/.source, /#EXT-X-(PRELOAD-HINT):(.+)/.source, /#EXT-X-(RENDITION-REPORT):(.+)/.source, /#EXT-X-(PREFETCH-DIS)CONTINUITY/.source, /#EXT-X-(PREFETCH):(.+)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|")),
                  W = /\.(mp4|m4s|m4v|m4a)$/i,
                  y = (f.findGroup = function (t, e) {
                    for (var r = 0; r < t.length; r++) {
                      var i = t[r];
                      if (i.id === e) return i
                    }
                  }, f.convertAVC1ToAVCOTI = function (t) {
                    var e, r = t.split(".");
                    return 2 < r.length ? (e = r.shift() + ".", e += parseInt(r.shift()).toString(16), e += ("000" + parseInt(r.shift()).toString(16)).substr(-4)) : e = t, e
                  }, f.resolve = function (t, e) {
                    return i.buildAbsoluteURL(e, t, {
                      alwaysNormalize: !0
                    })
                  }, f.parseMasterPlaylist = function (t, e) {
                    var r, i, n, a, s = [],
                      o = {},
                      l = !1;
                    for (h.lastIndex = 0; null != (a = h.exec(t));) a[1] ? (i = {
                      attrs: r = new z(a[1]),
                      bitrate: r.decimalInteger("AVERAGE-BANDWIDTH") || r.decimalInteger("BANDWIDTH"),
                      name: r.NAME,
                      url: f.resolve(a[2], e)
                    }, (n = r.decimalResolution("RESOLUTION")) && (i.width = n.width, i.height = n.height), function (i, n) {
                      ["video", "audio", "text"].forEach(function (r) {
                        var t, e = i.filter(function (t) {
                          return !!(e = u[r]) && !0 === e[t.slice(0, 4)];
                          var e
                        });
                        e.length && (t = e.filter(function (t) {
                          return 0 === t.lastIndexOf("avc1", 0) || 0 === t.lastIndexOf("mp4a", 0)
                        }), n[r + "Codec"] = (0 < t.length ? t : e)[0], i = i.filter(function (t) {
                          return -1 === e.indexOf(t)
                        }))
                      }), n.unknownCodecs = i
                    }([].concat((r.CODECS || "").split(/[ ,]+/)), i), i.videoCodec && -1 !== i.videoCodec.indexOf("avc1") && (i.videoCodec = f.convertAVC1ToAVCOTI(i.videoCodec)), s.push(i)) : !a[3] || (a = new z(a[3]))["DATA-ID"] && (l = !0, o[a["DATA-ID"]] = a);
                    return {
                      levels: s,
                      sessionData: l ? o : null
                    }
                  }, f.parseMasterPlaylistMedia = function (t, e, r, i) {
                    void 0 === i && (i = []);
                    var n = [],
                      a = 0;
                    for (c.lastIndex = 0; null !== (s = c.exec(t));) {
                      var s, o = new z(s[1]);
                      o.TYPE === r && (s = {
                        attrs: o,
                        bitrate: 0,
                        id: a++,
                        groupId: o["GROUP-ID"],
                        instreamId: o["INSTREAM-ID"],
                        name: o.NAME || o.LANGUAGE || "",
                        type: r,
                        default: o.bool("DEFAULT"),
                        autoselect: o.bool("AUTOSELECT"),
                        forced: o.bool("FORCED"),
                        lang: o.LANGUAGE,
                        url: o.URI ? f.resolve(o.URI, e) : ""
                      }, i.length && (E(s, o = f.findGroup(i, s.groupId) || i[0], "audioCodec"), E(s, o, "textCodec")), n.push(s))
                    }
                    return n
                  }, f.parseLevelPlaylist = function (t, e, r, i, n, a) {
                    var s = new j(e);
                    s.isMildomLiveEnd = !1;
                    var o, l, u, h = s.fragments,
                      d = 0,
                      c = 0,
                      f = 0,
                      g = 0,
                      m = null,
                      v = new G.c(i, e),
                      p = -1;
                    for (q.lastIndex = 0, s.m3u8 = t; null !== (o = q.exec(t));) {
                      var y = o[1];
                      if (y) {
                        v.duration = parseFloat(y);
                        var E = (" " + o[2]).slice(1);
                        v.title = E || null, v.tagList.push(E ? ["INF", y, E] : ["INF", y])
                      } else if (o[3]) Object(B.a)(v.duration) && (v.start = f, u && (v.levelkey = u), v.sn = d, v.level = r, v.cc = g, v.urlId = n, h.push(v), v.relurl = (" " + o[3]).slice(1), Y(v, m), f += (m = v).duration, d++, c = 0, (v = new G.c(i, e)).start = f, v.sn = d, v.cc = g, v.level = r);
                      else if (o[4]) {
                        var b = (" " + o[4]).slice(1);
                        m ? v.setByteRange(b, m) : v.setByteRange(b)
                      } else if (o[5]) v.rawProgramDateTime = (" " + o[5]).slice(1), v.tagList.push(["PROGRAM-DATE-TIME", v.rawProgramDateTime]), -1 === p && (p = h.length);
                      else if (o = o[0].match(K)) {
                        for (l = 1; l < o.length && void 0 === o[l]; l++);
                        var S = (" " + o[l]).slice(1),
                          _ = (" " + o[l + 1]).slice(1),
                          L = o[l + 2] ? (" " + o[l + 2]).slice(1) : "",
                          b = h.filter(function (t) {
                            return t && !t.prefetch
                          }) || [],
                          T = b.reduce(function (t, e) {
                            return e ? e.duration + t : t
                          }, 0) / b.length;
                        switch (S) {
                        case "PLAYLIST-TYPE":
                          s.type = _.toUpperCase();
                          break;
                        case "MEDIA-SEQUENCE":
                          d = s.startSN = parseInt(_);
                          break;
                        case "SKIP":
                          var A = new z(_),
                            R = A.decimalInteger("SKIPPED-SEGMENTS");
                          if (Object(B.a)(R)) {
                            for (var D = s.skippedSegments = R; D--;) h.unshift(null);
                            d += R, f += R * s.targetduration
                          }
                          var k = A.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                          k && (s.recentlyRemovedDateranges = k.split("\t"));
                          break;
                        case "TARGETDURATION":
                          s.targetduration = parseFloat(_);
                          break;
                        case "VERSION":
                          s.version = parseInt(_);
                          break;
                        case "EXTM3U":
                          break;
                        case "ENDLIST":
                          s.live = !1, s.isMildomLiveEnd = !0;
                          break;
                        case "#":
                          (_ || L) && v.tagList.push(L ? [_, L] : [_]);
                          break;
                        case "DIS":
                          g++;
                        case "GAP":
                          v.tagList.push([S]);
                          break;
                        case "BITRATE":
                          v.tagList.push([S, _]);
                          break;
                        case "DISCONTINUITY-SEQ":
                          g = parseInt(_);
                          break;
                        case "PREFETCH":
                          if (!a) break;
                          v.prefetch = !0, v.duration = T || s.targetduration, v.title = null, v.start = f, v.levelkey = u, v.sn = d++, v.level = r, v.cc = g, v.urlId = n, v.relurl = _, Y(v, m), s.fragments.push(v), f += (m = v).duration, v = new G.c(i, e);
                          break;
                        case "PREFETCH-DIS":
                          if (!a) break;
                          g++, v.tagList.push(["PREFETCH-DIS"]);
                          break;
                        case "KEY":
                          var C = new z(_),
                            w = C.enumeratedString("METHOD"),
                            R = C.URI,
                            x = C.hexadecimalInteger("IV"),
                            A = C.enumeratedString("KEYFORMATVERSIONS"),
                            k = C.enumeratedString("KEYID"),
                            C = null != (C = C.enumeratedString("KEYFORMAT")) ? C : "identity";
                          if (-1 < ["com.apple.streamingkeydelivery", "com.microsoft.playready", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", "com.widevine"].indexOf(C)) {
                            H.b.warn("Keyformat " + C + " is not supported from the manifest");
                            continue
                          }
                          if ("identity" !== C) continue;
                          w && (u = V.a.fromURL(e, R), R && 0 <= ["AES-128", "SAMPLE-AES", "SAMPLE-AES-CENC"].indexOf(w) && (u.method = w, u.keyFormat = C, k && (u.keyID = k), A && (u.keyFormatVersions = A), u.iv = x));
                          break;
                        case "START":
                          x = new z(_).decimalFloatingPoint("TIME-OFFSET");
                          Object(B.a)(x) && (s.startTimeOffset = x);
                          break;
                        case "MAP":
                          var P = new z(_);
                          v.relurl = P.URI, P.BYTERANGE && v.setByteRange(P.BYTERANGE), v.level = r, v.sn = "initSegment", u && (v.levelkey = u), s.initSegment = v, (v = new G.c(i, e)).rawProgramDateTime = s.initSegment.rawProgramDateTime;
                          break;
                        case "SERVER-CONTROL":
                          var O = new z(_);
                          s.canBlockReload = O.bool("CAN-BLOCK-RELOAD"), s.canSkipUntil = O.optionalFloat("CAN-SKIP-UNTIL", 0), s.canSkipDateRanges = 0 < s.canSkipUntil && O.bool("CAN-SKIP-DATERANGES"), s.partHoldBack = O.optionalFloat("PART-HOLD-BACK", 0), s.holdBack = O.optionalFloat("HOLD-BACK", 0);
                          break;
                        case "PART-INF":
                          var F = new z(_);
                          s.partTarget = F.decimalFloatingPoint("PART-TARGET");
                          break;
                        case "PART":
                          P = (P = s.partList) || (s.partList = []), O = 0 < c ? P[P.length - 1] : void 0, F = c++, O = new G.b(new z(_), v, e, F, O);
                          P.push(O), v.duration += O.duration;
                          break;
                        case "PRELOAD-HINT":
                          var I = new z(_);
                          s.preloadHint = I;
                          break;
                        case "RENDITION-REPORT":
                          I = new z(_);
                          s.renditionReports = s.renditionReports || [], s.renditionReports.push(I);
                          break;
                        default:
                          H.b.warn("line parsed but not handled: " + o)
                        }
                      } else H.b.warn("No matches on slow regex match for level playlist!")
                    }
                    m && !m.relurl ? (h.pop(), f -= m.duration, s.fragmentHint = m) : s.fragmentHint = v;
                    var M = h.length,
                      N = h[0],
                      U = h[M - 1];
                    return 0 < f && M && U ? (s.averagetargetduration = f / M, M = U.sn, s.endSN = "initSegment" !== M ? M : 0, N && (s.startCC = N.cc, s.initSegment || s.fragments.every(function (t) {
                      return W.test(t.relurl)
                    }) && (H.b.warn("MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX"), (v = new G.c(i, e)).relurl = U.relurl, v.level = r, v.sn = "initSegment", s.initSegment = v, s.needSidxRanges = !0))) : (s.endSN = 0, s.startCC = 0), s.partList && (f += s.fragmentHint.duration), s.totalduration = f, s.endCC = g, 0 < p && function (t) {
                      for (var e = t[p], r = p; r--;) {
                        var i = t[r];
                        if (!i) return;
                        i.programDateTime = e.programDateTime - 1e3 * i.duration, e = i
                      }
                    }(h), s
                  }, f);

                function f() {}

                function E(t, e, r) {
                  e = e[r];
                  e && (t[r] = e)
                }

                function Y(t, e) {
                  t.rawProgramDateTime ? t.programDateTime = Date.parse(t.rawProgramDateTime) : null != e && e.programDateTime && (t.programDateTime = e.endProgramDateTime), Object(B.a)(t.programDateTime) || (t.programDateTime = null, t.rawProgramDateTime = null)
                }(pe = m = m || {}).MANIFEST = "manifest", pe.LEVEL = "level", pe.AUDIO_TRACK = "audioTrack", pe.SUBTITLE_TRACK = "subtitleTrack", (Nt = v = v || {}).MAIN = "main", Nt.AUDIO = "audio", Nt.SUBTITLE = "subtitle";
                var b = self.performance;

                function S(t, e) {
                  t = t.url;
                  return t = void 0 === t || 0 === t.indexOf("data:") ? e.url : t
                }
                var _, L = ((se = R.prototype).registerListeners = function () {
                    var t = this.hls;
                    t.on(p.a.MANIFEST_LOADING, this.onManifestLoading, this), t.on(p.a.LEVEL_LOADING, this.onLevelLoading, this), t.on(p.a.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.on(p.a.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                  }, se.unregisterListeners = function () {
                    var t = this.hls;
                    t.off(p.a.MANIFEST_LOADING, this.onManifestLoading, this), t.off(p.a.LEVEL_LOADING, this.onLevelLoading, this), t.off(p.a.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), t.off(p.a.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this)
                  }, se.createInternalLoader = function (t) {
                    var e = this.hls.config,
                      r = e.pLoader,
                      i = e.loader,
                      e = new(r || i)(e);
                    return t.loader = e, this.loaders[t.type] = e
                  }, se.getInternalLoader = function (t) {
                    return this.loaders[t.type]
                  }, se.resetInternalLoader = function (t) {
                    this.loaders[t] && delete this.loaders[t]
                  }, se.destroyInternalLoaders = function () {
                    for (var t in this.loaders) {
                      var e = this.loaders[t];
                      e && e.destroy(), this.resetInternalLoader(t)
                    }
                  }, se.destroy = function () {
                    this.unregisterListeners(), this.destroyInternalLoaders()
                  }, se.onManifestLoading = function (t, e) {
                    e = e.url;
                    this.checkAgeHeader = !0, this.load({
                      id: null,
                      level: 0,
                      responseType: "text",
                      type: m.MANIFEST,
                      url: e,
                      deliveryDirectives: null
                    })
                  }, se.onLevelLoading = function (t, e) {
                    var r = e.id,
                      i = e.level,
                      n = e.url,
                      e = e.deliveryDirectives;
                    this.load({
                      id: r,
                      level: i,
                      responseType: "text",
                      type: m.LEVEL,
                      url: n,
                      deliveryDirectives: e
                    })
                  }, se.onAudioTrackLoading = function (t, e) {
                    var r = e.id,
                      i = e.url,
                      e = e.deliveryDirectives;
                    this.load({
                      id: r,
                      level: null,
                      responseType: "text",
                      type: m.AUDIO_TRACK,
                      url: i,
                      deliveryDirectives: e
                    })
                  }, se.onSubtitleTrackLoading = function (t, e) {
                    var r = e.id,
                      i = e.url,
                      e = e.deliveryDirectives;
                    this.load({
                      id: r,
                      level: null,
                      responseType: "text",
                      type: m.SUBTITLE_TRACK,
                      url: i,
                      deliveryDirectives: e
                    })
                  }, se.load = function (t) {
                    var e, r, i, n, a, s = this.hls.config;
                    if (H.b.debug("[playlist-loader]: Loading playlist of type " + t.type + ", level: " + t.level + ", id: " + t.id), l = this.getInternalLoader(t)) {
                      var o = l.context;
                      if (o && o.url === t.url) return void H.b.trace("[playlist-loader]: playlist request ongoing");
                      H.b.log("[playlist-loader]: aborting previous loader for type: " + t.type), l.abort()
                    }
                    switch (t.type) {
                    case m.MANIFEST:
                      e = s.manifestLoadingMaxRetry, r = s.manifestLoadingTimeOut, i = s.manifestLoadingRetryDelay, n = s.manifestLoadingMaxRetryTimeout;
                      break;
                    case m.LEVEL:
                    case m.AUDIO_TRACK:
                      e = 0, r = s.levelLoadingTimeOut;
                      break;
                    default:
                      e = s.levelLoadingMaxRetry, r = s.levelLoadingTimeOut, i = s.levelLoadingRetryDelay, n = s.levelLoadingMaxRetryTimeout
                    }
                    var l = this.createInternalLoader(t);
                    null !== (o = t.deliveryDirectives) && void 0 !== o && o.part && (t.type === m.LEVEL && null !== t.level ? a = this.hls.levels[t.level].details : t.type === m.AUDIO_TRACK && null !== t.id ? a = this.hls.audioTracks[t.id].details : t.type === m.SUBTITLE_TRACK && null !== t.id && (a = this.hls.subtitleTracks[t.id].details), a) && (u = a.partTarget, h = a.targetduration, u && h && (r = Math.min(1e3 * Math.max(3 * u, .8 * h), r)));
                    var u = {
                        timeout: r,
                        maxRetry: e,
                        retryDelay: i,
                        maxRetryDelay: n,
                        highWaterMark: 0
                      },
                      h = {
                        onSuccess: this.loadsuccess.bind(this),
                        onError: this.loaderror.bind(this),
                        onTimeout: this.loadtimeout.bind(this)
                      };
                    H.b.debug("[playlist-loader]: Calling internal loader delegate for URL: " + t.url), l.load(t, u, h)
                  }, se.loadsuccess = function (t, e, r, i) {
                    if (void 0 === i && (i = null), r.isSidxRequest) return this._handleSidxRequest(t, r), void this._handlePlaylistLoaded(t, e, r, i);
                    this.resetInternalLoader(r.type);
                    var n = t.data;
                    0 === n.indexOf("#EXTM3U") ? (e.parsing.start = b.now(), 0 < n.indexOf("#EXTINF:") || 0 < n.indexOf("#EXT-X-TARGETDURATION:") ? this._handleTrackOrLevelPlaylist(t, e, r, i) : this._handleMasterPlaylist(t, e, r, i)) : this._handleManifestParsingError(t, r, "no EXTM3U delimiter", i)
                  }, se.loaderror = function (t, e, r) {
                    this._handleNetworkError(e, r = void 0 === r ? null : r, !1, t)
                  }, se.loadtimeout = function (t, e, r) {
                    this._handleNetworkError(e, r = void 0 === r ? null : r, !0)
                  }, se._handleMasterPlaylist = function (t, e, r, i) {
                    var n, a = this.hls,
                      s = t.data,
                      o = S(t, r),
                      l = y.parseMasterPlaylist(s, o),
                      u = l.levels,
                      h = l.sessionData;
                    u.length ? (n = u.map(function (t) {
                      return {
                        id: t.attrs.AUDIO,
                        audioCodec: t.audioCodec
                      }
                    }), l = u.map(function (t) {
                      return {
                        id: t.attrs.SUBTITLES,
                        textCodec: t.textCodec
                      }
                    }), n = y.parseMasterPlaylistMedia(s, o, "AUDIO", n), l = y.parseMasterPlaylistMedia(s, o, "SUBTITLES", l), s = y.parseMasterPlaylistMedia(s, o, "CLOSED-CAPTIONS"), n.length && (n.some(function (t) {
                      return !t.url
                    }) || !u[0].audioCodec || u[0].attrs.AUDIO || (H.b.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one"), n.unshift({
                      type: "main",
                      name: "main",
                      default: !1,
                      autoselect: !1,
                      forced: !1,
                      id: -1,
                      attrs: new z({}),
                      bitrate: 0,
                      url: ""
                    }))), a.trigger(p.a.MANIFEST_LOADED, {
                      levels: u,
                      audioTracks: n,
                      subtitles: l,
                      captions: s,
                      url: o,
                      stats: e,
                      networkDetails: i,
                      sessionData: h
                    })) : this._handleManifestParsingError(t, r, "no level found in manifest", i)
                  }, se._handleTrackOrLevelPlaylist = function (t, e, r, i) {
                    var n, a, s, o, l, u = this.hls,
                      h = u.config,
                      d = r.id,
                      c = r.level,
                      f = r.type;
                    r.loader && (n = S(t, r), o = Object(B.a)(d) ? d : 0, a = Object(B.a)(c) ? c : o, s = function () {
                      switch (r.type) {
                      case m.AUDIO_TRACK:
                        return v.AUDIO;
                      case m.SUBTITLE_TRACK:
                        return v.SUBTITLE;
                      default:
                        return v.MAIN
                      }
                    }(), (o = y.parseLevelPlaylist(t.data, n, a, s, o, h.progressive && h.lowLatencyMode)).tload = e.loading.end, h = self.performance.timing.navigationStart + o.tload, this.checkAgeHeader = !1, o.lastModified = +h, o.fragments.length ? (f === m.MANIFEST && (l = {
                      attrs: new z({}),
                      bitrate: 0,
                      details: o,
                      name: "",
                      url: n
                    }, u.trigger(p.a.MANIFEST_LOADED, {
                      levels: [l],
                      audioTracks: [],
                      url: n,
                      stats: e,
                      networkDetails: i,
                      sessionData: null
                    })), e.parsing.end = b.now(), o.needSidxRanges ? (l = o.initSegment.url, this.load({
                      url: l,
                      isSidxRequest: !0,
                      type: f,
                      level: c,
                      levelDetails: o,
                      id: d,
                      rangeStart: 0,
                      rangeEnd: 2048,
                      responseType: "arraybuffer",
                      deliveryDirectives: null
                    })) : (r.levelDetails = o, this._handlePlaylistLoaded(t, e, r, i))) : u.trigger(p.a.ERROR, {
                      type: g.b.NETWORK_ERROR,
                      details: g.a.LEVEL_EMPTY_ERROR,
                      fatal: !1,
                      url: n,
                      reason: "no fragments found in level",
                      level: "number" == typeof r.level ? r.level : void 0
                    }))
                  }, se._handleSidxRequest = function (t, e) {
                    var r, i = Object(s.g)(new Uint8Array(t.data));
                    i && (t = i.references, r = e.levelDetails, t.forEach(function (t, e) {
                      t = t.info, e = r.fragments[e];
                      0 === e.byteRange.length && e.setByteRange(String(1 + t.end - t.start) + "@" + String(t.start))
                    }), r.initSegment.setByteRange(String(i.moovEndOffset) + "@0"))
                  }, se._handleManifestParsingError = function (t, e, r, i) {
                    this.hls.trigger(p.a.ERROR, {
                      type: g.b.NETWORK_ERROR,
                      details: g.a.MANIFEST_PARSING_ERROR,
                      fatal: e.type === m.MANIFEST,
                      url: t.url,
                      reason: r,
                      response: t,
                      context: e,
                      networkDetails: i
                    })
                  }, se._handleNetworkError = function (t, e, r, i) {
                    var n, a;
                    void 0 === r && (r = !1), H.b.info("[playlist-loader]: A network error occurred while loading a " + t.type + "-type playlist");
                    var s = this.getInternalLoader(t);
                    switch (t.type) {
                    case m.MANIFEST:
                      n = r ? g.a.MANIFEST_LOAD_TIMEOUT : g.a.MANIFEST_LOAD_ERROR, a = !0;
                      break;
                    case m.LEVEL:
                      n = r ? g.a.LEVEL_LOAD_TIMEOUT : g.a.LEVEL_LOAD_ERROR, a = !1;
                      break;
                    case m.AUDIO_TRACK:
                      n = r ? g.a.AUDIO_TRACK_LOAD_TIMEOUT : g.a.AUDIO_TRACK_LOAD_ERROR, a = !1;
                      break;
                    default:
                      a = !1
                    }
                    s && this.resetInternalLoader(t.type);
                    e = {
                      type: g.b.NETWORK_ERROR,
                      details: n,
                      fatal: a,
                      url: t.url,
                      loader: s,
                      context: t,
                      networkDetails: e
                    };
                    i && (e.response = i), this.hls.trigger(p.a.ERROR, e)
                  }, se._handlePlaylistLoaded = function (t, e, r, i) {
                    var n = r.type,
                      a = r.level,
                      s = r.id,
                      o = r.levelDetails,
                      l = r.deliveryDirectives;
                    if (null != o && o.targetduration) switch (n) {
                    case m.MANIFEST:
                    case m.LEVEL:
                      this.hls.trigger(p.a.LEVEL_LOADED, {
                        details: o,
                        level: a || 0,
                        id: s || 0,
                        stats: e,
                        networkDetails: i,
                        deliveryDirectives: l
                      });
                      break;
                    case m.AUDIO_TRACK:
                      this.hls.trigger(p.a.AUDIO_TRACK_LOADED, {
                        details: o,
                        id: s || 0,
                        stats: e,
                        networkDetails: i,
                        deliveryDirectives: l
                      });
                      break;
                    case m.SUBTITLE_TRACK:
                      this.hls.trigger(p.a.SUBTITLE_TRACK_LOADED, {
                        details: o,
                        id: s || 0,
                        stats: e,
                        networkDetails: i,
                        deliveryDirectives: l
                      })
                    } else this._handleManifestParsingError(t, r, "invalid target duration", i)
                  }, R),
                  T = ((Se = A.prototype)._registerListeners = function () {
                    this.hls.on(p.a.KEY_LOADING, this.onKeyLoading, this)
                  }, Se._unregisterListeners = function () {
                    this.hls.off(p.a.KEY_LOADING, this.onKeyLoading)
                  }, Se.destroy = function () {
                    for (var t in this._unregisterListeners(), this.loaders) {
                      t = this.loaders[t];
                      t && t.destroy()
                    }
                    this.loaders = {}
                  }, Se.onKeyLoading = function (t, e) {
                    var r, i = e.frag,
                      n = i.type,
                      a = this.loaders[n];
                    i.decryptdata ? (r = i.decryptdata.uri) !== this.decrypturl || null === this.decryptkey ? (e = this.hls.config, a && (H.b.warn("abort previous key loader for type:" + n), a.abort()), r ? (a = i.loader = this.loaders[n] = new e.loader(e), this.decrypturl = r, this.decryptkey = null, n = {
                      url: r,
                      frag: i,
                      responseType: "arraybuffer"
                    }, r = {
                      timeout: e.fragLoadingTimeOut,
                      maxRetry: 0,
                      retryDelay: e.fragLoadingRetryDelay,
                      maxRetryDelay: e.fragLoadingMaxRetryTimeout,
                      highWaterMark: 0
                    }, e = {
                      onSuccess: this.loadsuccess.bind(this),
                      onError: this.loaderror.bind(this),
                      onTimeout: this.loadtimeout.bind(this)
                    }, a.load(n, r, e)) : H.b.warn("key uri is falsy")) : this.decryptkey && (i.decryptdata.key = this.decryptkey, this.hls.trigger(p.a.KEY_LOADED, {
                      frag: i
                    })) : H.b.warn("Missing decryption data on fragment in onKeyLoading")
                  }, Se.loadsuccess = function (t, e, r) {
                    r = r.frag;
                    r.decryptdata ? (this.decryptkey = r.decryptdata.key = new Uint8Array(t.data), r.loader = null, delete this.loaders[r.type], this.hls.trigger(p.a.KEY_LOADED, {
                      frag: r
                    })) : H.b.error("after key load, decryptdata unset")
                  }, Se.loaderror = function (t, e) {
                    var r = e.frag,
                      e = r.loader;
                    e && e.abort(), delete this.loaders[r.type], this.hls.trigger(p.a.ERROR, {
                      type: g.b.NETWORK_ERROR,
                      details: g.a.KEY_LOAD_ERROR,
                      fatal: !1,
                      frag: r,
                      response: t
                    })
                  }, Se.loadtimeout = function (t, e) {
                    var r = e.frag,
                      e = r.loader;
                    e && e.abort(), delete this.loaders[r.type], this.hls.trigger(p.a.ERROR, {
                      type: g.b.NETWORK_ERROR,
                      details: g.a.KEY_LOAD_TIMEOUT,
                      fatal: !1,
                      frag: r
                    })
                  }, A);

                function A(t) {
                  this.hls = void 0, this.loaders = {}, this.decryptkey = null, this.decrypturl = null, this.hls = t, this._registerListeners()
                }

                function R(t) {
                  this.hls = void 0, this.loaders = Object.create(null), this.checkAgeHeader = !0, this.hls = t, this.registerListeners()
                }(_e = _ = _ || {}).NOT_LOADED = "NOT_LOADED", _e.APPENDING = "APPENDING", _e.PARTIAL = "PARTIAL", _e.OK = "OK";
                var D = ((ne = k.prototype)._registerListeners = function () {
                  var t = this.hls;
                  t.on(p.a.BUFFER_APPENDED, this.onBufferAppended, this), t.on(p.a.FRAG_BUFFERED, this.onFragBuffered, this), t.on(p.a.FRAG_LOADED, this.onFragLoaded, this)
                }, ne._unregisterListeners = function () {
                  var t = this.hls;
                  t.off(p.a.BUFFER_APPENDED, this.onBufferAppended, this), t.off(p.a.FRAG_BUFFERED, this.onFragBuffered, this), t.off(p.a.FRAG_LOADED, this.onFragLoaded, this)
                }, ne.destroy = function () {
                  this.fragments = Object.create(null), this.timeRanges = Object.create(null), this._unregisterListeners()
                }, ne.getAppendedFrag = function (t, e) {
                  var r = this.activeFragment;
                  return r ? void 0 !== r.appendedPTS && r.start <= t && t <= r.appendedPTS ? r : this.getBufferedFrag(t, e) : null
                }, ne.getBufferedFrag = function (t, e) {
                  for (var r = this.fragments, i = Object.keys(r), n = i.length; n--;) {
                    var a = r[i[n]];
                    if ((null == a ? void 0 : a.body.type) === e && a.buffered) {
                      a = a.body;
                      if (a.start <= t && t <= a.end) return a
                    }
                  }
                  return null
                }, ne.detectEvictedFragments = function (r, i) {
                  var n = this;
                  Object.keys(this.fragments).forEach(function (t) {
                    var e = n.fragments[t];
                    e && e.buffered && ((t = e.range[r]) && t.time.some(function (t) {
                      t = !n.isTimeBuffered(t.startPTS, t.endPTS, i);
                      return t && n.removeFragment(e.body), t
                    }))
                  })
                }, ne.detectPartialFragments = function (e) {
                  var r, i = this,
                    n = this.timeRanges,
                    t = this.fragments;
                  !n || "initSegment" === e.sn || (r = t[w(e)]) && (r.buffered = !0, Object.keys(n).forEach(function (t) {
                    e.elementaryStreams[t] && (r.range[t] = i.getBufferedTimes(e, n[t]))
                  }))
                }, ne.getBufferedTimes = function (t, e) {
                  for (var r = [], i = !1, n = 0; n < e.length; n++) {
                    var a = t.start,
                      s = t.end,
                      o = t.minEndPTS || s,
                      l = t.maxStartPTS || a,
                      u = e.start(n) - this.bufferPadding,
                      h = e.end(n) + this.bufferPadding;
                    if (u <= l && o <= h) {
                      r.push({
                        startPTS: Math.max(a, e.start(n)),
                        endPTS: Math.min(s, e.end(n))
                      });
                      break
                    }
                    if (a < h && u < s) r.push({
                      startPTS: Math.max(a, e.start(n)),
                      endPTS: Math.min(s, e.end(n))
                    }), i = !0;
                    else if (s <= u) break
                  }
                  return {
                    time: r,
                    partial: i
                  }
                }, ne.getPartialFragment = function (e) {
                  var r, i, n = null,
                    a = 0,
                    s = this.bufferPadding,
                    o = this.fragments;
                  return Object.keys(o).forEach(function (t) {
                    t = o[t];
                    t && C(t) && (r = t.body.start - s, i = t.body.end + s, r <= e && e <= i && (i = Math.min(e - r, i - e), a <= i && (n = t.body, a = i)))
                  }), n
                }, ne.getState = function (t) {
                  t = w(t), t = this.fragments[t];
                  return t ? t.buffered ? C(t) ? _.PARTIAL : _.OK : _.APPENDING : _.NOT_LOADED
                }, ne.isTimeBuffered = function (t, e, r) {
                  for (var i, n, a = 0; a < r.length; a++) {
                    if (i = r.start(a) - this.bufferPadding, n = r.end(a) + this.bufferPadding, i <= t && e <= n) return !0;
                    if (e <= i) return !1
                  }
                  return !1
                }, ne.onFragLoaded = function (t, e) {
                  e = e.frag;
                  "initSegment" === e.sn || e.bitrateTest || (this.fragments[w(e)] = {
                    body: e,
                    range: Object.create(null),
                    buffered: !1
                  })
                }, ne.onBufferAppended = function (t, e) {
                  var i = this,
                    n = e.frag,
                    a = e.timeRanges;
                  this.activeFragment = n, this.timeRanges = a, Object.keys(a).forEach(function (t) {
                    var e = a[t];
                    i.detectEvictedFragments(t, e);
                    for (var r = 0; r < e.length; r++) n.appendedPTS = Math.max(e.end(r), n.appendedPTS || 0)
                  })
                }, ne.onFragBuffered = function (t, e) {
                  this.detectPartialFragments(e.frag)
                }, ne.hasFragment = function (t) {
                  t = w(t);
                  return !!this.fragments[t]
                }, ne.removeFragment = function (t) {
                  t = w(t);
                  delete this.fragments[t]
                }, ne.removeAllFragments = function () {
                  this.fragments = Object.create(null)
                }, k);

                function k(t) {
                  this.activeFragment = null, this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.bufferPadding = .2, this.hls = void 0, this.hls = t, this._registerListeners()
                }

                function C(t) {
                  var e;
                  return t.buffered && (null !== (e = t.range.video) && void 0 !== e && e.partial || null !== (t = t.range.audio) && void 0 !== t && t.partial)
                }

                function w(t) {
                  return t.type + "_" + t.level + "_" + t.urlId + "_" + t.sn
                }
                var e = ((Qt = F.prototype).destroy = function () {
                    this.onHandlerDestroying(), this.onHandlerDestroyed()
                  }, Qt.onHandlerDestroying = function () {
                    this.clearNextTick(), this.clearInterval()
                  }, Qt.onHandlerDestroyed = function () {}, Qt.hasInterval = function () {
                    return !!this._tickInterval
                  }, Qt.hasNextTick = function () {
                    return !!this._tickTimer
                  }, Qt.setInterval = function (t) {
                    return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, t), !0)
                  }, Qt.clearInterval = function () {
                    return !!this._tickInterval && (self.clearInterval(this._tickInterval), !(this._tickInterval = null))
                  }, Qt.clearNextTick = function () {
                    return !!this._tickTimer && (self.clearTimeout(this._tickTimer), !(this._tickTimer = null))
                  }, Qt.tick = function () {
                    this._tickCallCount++, 1 === this._tickCallCount && (this.doTick(), 1 < this._tickCallCount && (this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)), this._tickCallCount = 0)
                  }, Qt.doTick = function () {}, F),
                  x = {
                    length: 0,
                    start: function () {
                      return 0
                    },
                    end: function () {
                      return 0
                    }
                  },
                  P = (O.isBuffered = function (t, e) {
                    try {
                      if (t)
                        for (var r = O.getBuffered(t), i = 0; i < r.length; i++)
                          if (e >= r.start(i) && e <= r.end(i)) return !0
                    } catch (t) {}
                    return !1
                  }, O.bufferInfo = function (t, e, r) {
                    try {
                      if (t) {
                        for (var i = O.getBuffered(t), n = [], a = 0; a < i.length; a++) n.push({
                          start: i.start(a),
                          end: i.end(a)
                        });
                        return this.bufferedInfo(n, e, r)
                      }
                    } catch (t) {}
                    return {
                      len: 0,
                      start: e,
                      end: e,
                      nextStart: void 0
                    }
                  }, O.bufferedInfo = function (t, e, r) {
                    t.sort(function (t, e) {
                      return t.start - e.start || e.end - t.end
                    });
                    var i = [];
                    if (r)
                      for (var n = 0; n < t.length; n++) {
                        var a, s = i.length;
                        s ? (a = i[s - 1].end, t[n].start - a < r ? t[n].end > a && (i[s - 1].end = t[n].end) : i.push(t[n])) : i.push(t[n])
                      } else i = t;
                    for (var o, l = 0, u = e, h = e, d = 0; d < i.length; d++) {
                      var c = i[d].start,
                        f = i[d].end;
                      if (c <= e + r && e < f) u = c, l = (h = f) - e;
                      else if (e + r < c) {
                        o = c;
                        break
                      }
                    }
                    return {
                      len: l,
                      start: u || 0,
                      end: h || 0,
                      nextStart: o
                    }
                  }, O.getBuffered = function (t) {
                    try {
                      return t.buffered
                    } catch (t) {
                      return H.b.log("failed to get media.buffered", t), x
                    }
                  }, O);

                function O() {}

                function F() {
                  this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this)
                }

                function I(t, e, r) {
                  switch (e) {
                  case "audio":
                    t.audioGroupIds || (t.audioGroupIds = []), t.audioGroupIds.push(r);
                    break;
                  case "text":
                    t.textGroupIds || (t.textGroupIds = []), t.textGroupIds.push(r)
                  }
                }

                function M(t, e) {
                  var r, i = e.startPTS;
                  Object(B.a)(i) ? (r = 0, (i = e.sn > t.sn ? (r = i - t.start, t) : (r = t.start - i, e)).duration !== r && (i.duration = r)) : e.sn > t.sn ? t.cc === e.cc && t.minEndPTS ? e.start = t.start + (t.minEndPTS - t.start) : e.start = t.start + t.duration : e.start = Math.max(t.start - e.duration, 0)
                }

                function N(t, e, r, i, n, a) {
                  var s, o = r,
                    l = i,
                    u = e.startPTS,
                    h = e.endPTS;
                  Object(B.a)(u) && (s = Math.abs(u - r), Object(B.a)(e.deltaPTS) ? e.deltaPTS = Math.max(s, e.deltaPTS) : e.deltaPTS = s, o = Math.max(r, u), r = Math.min(r, u), l = Math.min(i, h), i = Math.max(i, h), n = Math.min(n, e.startDTS), a = Math.max(a, e.endDTS));
                  u = i - r, h = r - e.start;
                  e.appendedPTS = i, e.start = e.startPTS = r, e.maxStartPTS = o, e.startDTS = n, e.endPTS = i, e.minEndPTS = l, e.endDTS = a, e.duration = u;
                  var d, u = e.sn;
                  if (!t || u < t.startSN || u > t.endSN) return 0;
                  var u = u - t.startSN,
                    c = t.fragments;
                  for (c[u] = e, d = u; 0 < d; d--) M(c[d], c[d - 1]);
                  for (d = u; d < c.length - 1; d++) M(c[d], c[d + 1]);
                  return t.fragmentHint && M(c[c.length - 1], t.fragmentHint), t.PTSKnown = t.alignedSliding = !0, h
                }

                function U(t, u) {
                  var e;
                  u.initSegment && t.initSegment && (u.initSegment = t.initSegment);
                  var h, d = 0,
                    c = (null === (e = t.fragments[t.fragments.length - 1]) || void 0 === e ? void 0 : e.cc) || null;
                  if (function (t, e) {
                      for (var r = e.skippedSegments, i = Math.max(t.startSN, e.startSN) - e.startSN, n = (r ? e.endSN : Math.min(t.endSN, e.endSN)) - e.startSN, a = e.startSN - t.startSN, s = i; s <= n; s++) {
                        var o = t.fragments[a + s],
                          l = e.fragments[s];
                        r && !l && s < r && (l = e.fragments[s] = o), o && l && (l = l, d = (o = o).cc - l.cc, Object(B.a)(o.startPTS) && Object(B.a)(o.endPTS) && (l.start = l.startPTS = o.startPTS, l.startDTS = o.startDTS, l.appendedPTS = o.appendedPTS, l.maxStartPTS = o.maxStartPTS, o.hasParts || (l.endPTS = o.endPTS, l.endDTS = o.endDTS, l.minEndPTS = o.minEndPTS, l.duration = o.endPTS - o.startPTS), l.backtracked = o.backtracked, l.dropped = o.dropped, h = l, 0 === u.startSN && null !== c && (l.cc += c + 1), u.PTSKnown = u.alignedSliding = !0), l.stats = o.stats, l.loader = o.loader, l.urlId = o.urlId)
                      }
                    }(t, u), u.skippedSegments && (u.deltaUpdateFailed = u.fragments.some(function (t) {
                      return !t
                    }), u.deltaUpdateFailed)) {
                    H.b.warn("[" + this.constructor.name + "] Previous playlist missing segments skipped in delta playlist");
                    for (var r = u.skippedSegments; r--;) u.fragments.shift();
                    u.startSN = u.fragments[0].sn, u.startCC = u.fragments[0].cc
                  }
                  var i = u.fragments;
                  if (d) {
                    H.b.log("discontinuity sliding from playlist, take drift into account");
                    for (var n = 0; n < i.length; n++) i[n].cc += d
                  }
                  u.skippedSegments && (u.initSegment || (u.initSegment = t.initSegment), u.startCC = u.fragments[0].cc), h ? N(u, h, h.startPTS, h.endPTS, h.startDTS, h.endDTS) : X(t, u), i.length && (u.totalduration = u.edge - i[0].start)
                }

                function X(t, e) {
                  var r = e.startSN + e.skippedSegments - t.startSN,
                    t = t.fragments,
                    i = e.fragments;
                  if (!(r < 0 || r >= t.length)) {
                    var n = t[r].start;
                    if (n) {
                      for (var a = e.skippedSegments; a < i.length; a++) i[a].start += n;
                      e.fragmentHint && (e.fragmentHint.start += n)
                    }
                  }
                }

                function $(t, e, r, i, n) {
                  void 0 === i && (i = 0), void 0 === n && (n = -1), this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.transmuxing = {
                    start: 0,
                    executeStart: 0,
                    executeEnd: 0,
                    end: 0
                  }, this.buffering = {
                    audio: {
                      start: 0,
                      executeStart: 0,
                      executeEnd: 0,
                      end: 0
                    },
                    video: {
                      start: 0,
                      executeStart: 0,
                      executeEnd: 0,
                      end: 0
                    },
                    audiovideo: {
                      start: 0,
                      executeStart: 0,
                      executeEnd: 0,
                      end: 0
                    }
                  }, this.level = t, this.sn = e, this.id = r, this.size = i, this.part = n
                }

                function Q(t, e) {
                  t && (e = t.start + e, t.start = t.startPTS = e, t.endPTS = e + t.duration)
                }

                function J(t, e) {
                  for (var r = e.fragments, i = 0, n = r.length; i < n; i++) Q(r[i], t);
                  e.fragmentHint && Q(e.fragmentHint, t), e.alignedSliding = !0
                }

                function Z(t, e, r) {
                  var i, n, a, s, o;
                  e && (a = t, s = r, (o = e).details && (s.endCC > s.startCC || a && a.cc < s.startCC) && (null != (a = function () {
                    var t = o.details.fragments,
                      e = s.fragments;
                    if (e.length && t.length) {
                      e = function (t, e) {
                        for (var r = null, i = 0, n = t.length; i < n; i++) {
                          var a = t[i];
                          if (a && a.cc === e) {
                            r = a;
                            break
                          }
                        }
                        return r
                      }(t, e[0].cc);
                      if (e && (!e || e.startPTS)) return e;
                      H.b.log("No frag in previous level to align on")
                    } else H.b.log("No fragments to align")
                  }()) && a.start && (H.b.log("Adjusting PTS using last level due to CC increase within current level " + s.url), J(a.start, s))), !r.alignedSliding && e.details && (i = r, (n = e.details).fragments.length && i.hasProgramDateTime && n.hasProgramDateTime && (t = n.fragments[0].programDateTime, (n = ((a = i.fragments[0].programDateTime) - t) / 1e3 + n.fragments[0].start) && Object(B.a)(n) && (H.b.log("Adjusting PTS using programDateTime delta " + (a - t) + "ms, sliding:" + n.toFixed(3) + " " + i.url + " "), J(n, i)))), r.alignedSliding || !e.details || r.skippedSegments || X(e.details, r))
                }
                var tt = function (t, e) {
                  for (var r, i, n = 0, a = t.length - 1; n <= a;) {
                    var s = e(i = t[r = (n + a) / 2 | 0]);
                    if (0 < s) n = 1 + r;
                    else {
                      if (!(s < 0)) return i;
                      a = r - 1
                    }
                  }
                  return null
                };

                function et(t, e, r) {
                  void 0 === t && (t = 0), void 0 === e && (e = 0);
                  e = Math.min(e, r.duration + (r.deltaPTS || 0));
                  return r.start + r.duration - e <= t ? 1 : r.start - e > t && r.start ? -1 : 0
                }
                var rt = r(13);
                var it = "STOPPED",
                  nt = "IDLE",
                  at = "KEY_LOADING",
                  st = "FRAG_LOADING",
                  ot = "FRAG_LOADING_WAITING_RETRY",
                  lt = "PARSING",
                  ut = "ERROR",
                  ht = "WAITING_LEVEL",
                  dt = function (i) {
                    var t;

                    function e(t, e) {
                      var r;
                      return (r = i.call(this) || this).hls = void 0, r.fragPrevious = null, r.fragCurrent = null, r.fragmentTracker = void 0, r.transmuxer = null, r._state = it, r.media = void 0, r.mediaBuffer = void 0, r.config = void 0, r.lastCurrentTime = 0, r.nextLoadPosition = 0, r.startPosition = 0, r.loadedmetadata = !1, r.fragLoadError = 0, r.levels = null, r.fragmentLoader = void 0, r.levelLastLoaded = null, r.startFragRequested = !1, r.decrypter = void 0, r.initPTS = [], r.mildomFragmentRequestManager = null, r.logPrefix = "", r.hls = t, r.fragmentTracker = e, r.config = t.config, r.decrypter = new rt.a(t, t.config), r
                    }
                    r = i, (t = e).prototype = Object.create(r.prototype), (t.prototype.constructor = t).__proto__ = r;
                    var r = e.prototype;
                    return r.doTick = function () {
                        this.onTickEnd()
                      }, r.onTickEnd = function () {}, r.startLoad = function (t) {}, r.stopLoad = function () {
                        var t = this.fragCurrent;
                        t && (t.loader && t.loader.abort(), this.fragmentTracker.removeFragment(t)), this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = it
                      }, r._streamEnded = function (t, e) {
                        var r = this.fragCurrent,
                          i = this.fragmentTracker;
                        if (e.live && !this.hls.isMildomLiveEnd || !r || r.backtracked || r.sn !== e.endSN || t.nextStart) return !1;
                        r = i.getState(r);
                        return r === _.PARTIAL || r === _.OK
                      }, r.onMediaSeeking = function () {
                        var t = this.config,
                          e = this.fragCurrent,
                          r = this.media,
                          i = this.mediaBuffer,
                          n = this.state,
                          a = r ? r.currentTime : null,
                          i = P.bufferInfo(i || r, a, t.maxBufferHole);
                        this.log("media seeking to " + (Object(B.a)(a) ? a.toFixed(3) : a) + ", state: " + n), "ENDED" === n ? (i.len || (this.fragPrevious = null, this.fragCurrent = null), this.state = nt) : e && !i.len && (i = t.maxFragLookUpTolerance, t = e.start - i, i = e.start + e.duration + i, (a < t || i < a) && (e.loader && (this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), e.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.log("seeking outside of buffer while fragment load in progress, cancel fragment load"), this.mildomFragmentRequestManager && this.mildomFragmentRequestManager.abort(), this.state = nt)), r && (this.lastCurrentTime = a), this.loadedmetadata || (this.nextLoadPosition = this.startPosition = a), this.tick()
                      }, r.onMediaEnded = function () {
                        this.startPosition = this.lastCurrentTime = 0
                      }, r.onHandlerDestroying = function () {
                        this.stopLoad(), i.prototype.onHandlerDestroying.call(this)
                      }, r.onHandlerDestroyed = function () {
                        this.state = it, i.prototype.onHandlerDestroyed.call(this)
                      }, r._loadFragForPlayback = function (r, t) {
                        var i = this;
                        this._doFragLoad(r, t, function (t) {
                          return i._fragLoadAborted(r) ? (i.warn("Fragment " + r.sn + " of level " + r.level + " was aborted during progressive download."), void i.fragmentTracker.removeFragment(r)) : (r.stats.chunkCount++, void(i.mildomFragmentRequestManager ? i.mildomFragmentRequestManager.enquePendingFragParse(r, i._handleFragmentLoadProgress.bind(i, t)) : i._handleFragmentLoadProgress(t)))
                        }).then(function (t) {
                          i.fragLoadError = 0;
                          var e = i._fragLoadAborted(r);
                          t && !e && (i.log("Loaded fragment " + r.sn + " of level " + r.level), i.hls.trigger(p.a.FRAG_LOADED, t), i._handleFragmentLoadComplete(t))
                        })
                      }, r._loadInitSegment = function (a) {
                        var s = this;
                        this._doFragLoad(a).then(function (t) {
                          if (!t || s._fragLoadAborted(a) || !s.levels) throw new Error("init load aborted");
                          return t
                        }).then(function (r) {
                          var i = s.hls,
                            t = r.payload,
                            e = a.decryptdata;
                          if (t && 0 < t.byteLength && e && e.key && e.iv && "AES-128" === e.method) {
                            var n = performance.now();
                            return s.decrypter.webCryptoDecrypt(new Uint8Array(t), e.key.buffer, e.iv.buffer).then(function (t) {
                              var e = performance.now();
                              return i.trigger(p.a.FRAG_DECRYPTED, {
                                frag: a,
                                payload: t,
                                stats: {
                                  tstart: n,
                                  tdecrypt: e
                                }
                              }), r.payload = t, r
                            })
                          }
                          return r
                        }).then(function (t) {
                          var e = s.fragCurrent,
                            r = s.hls,
                            i = s.levels;
                          if (!i) throw new Error("init load aborted, missing levels");
                          var n = i[a.level].details.initSegment,
                            i = a.stats;
                          s.state = nt, s.fragLoadError = 0, n.data = new Uint8Array(t.payload), i.parsing.start = i.buffering.start = self.performance.now(), i.parsing.end = i.buffering.end = self.performance.now(), t.frag === e && r.trigger(p.a.FRAG_BUFFERED, {
                            stats: i,
                            frag: e,
                            id: a.type
                          }), s.tick()
                        }).catch(function (t) {
                          H.b.warn(t)
                        })
                      }, r._fragLoadAborted = function (t) {
                        if (this.mildomFragmentRequestManager) return this.mildomFragmentRequestManager.isFragAborted(t);
                        var e = this.fragCurrent;
                        return !t || !e || t.level !== e.level || t.sn !== e.sn
                      }, r._handleFragmentLoadComplete = function (t) {
                        var e, r = this.transmuxer;
                        r && (e = t.frag, t = (t = t.part) ? t.index : -1, (t = new $(e.level, e.sn, e.stats.chunkCount + 1, 0, t)).transmuxing.start = performance.now(), r.flush(t))
                      }, r._handleFragmentLoadProgress = function (t) {}, r._doFragLoad = function (e, t, r) {
                        var i = this;
                        return void 0 === t && (t = null), this.state = st, this.hls.trigger(p.a.FRAG_LOADING, {
                          frag: e,
                          targetBufferTime: t
                        }), this.fragmentLoader.load(e, t, r).catch(function (t) {
                          t = t.data;
                          return t && t.details === g.a.INTERNAL_ABORTED ? i.handleFragLoadAborted(e, t.part) : i.hls.trigger(p.a.ERROR, t), null
                        })
                      }, r._handleTransmuxerFlush = function (t) {
                        var e, r = this.getCurrentContext(t);
                        !r || this.state !== lt && this.hls.config.mildomFragMaxParallelLoadNum <= 1 ? this.fragCurrent || (this.state = nt) : (e = r.frag, t = r.partIndex, r = r.level, e && (e.stats.parsing.end = performance.now(), this.updateLevelTiming(e, r), this.state = "PARSED", this.hls.trigger(p.a.FRAG_PARSED, {
                          frag: e,
                          partIndex: t
                        })))
                      }, r.getCurrentContext = function (t) {
                        var e = this.levels,
                          r = this.mildomFragmentRequestManager ? this.mildomFragmentRequestManager.currentParseFrag : this.fragCurrent,
                          i = t.level,
                          n = t.sn;
                        if (!e || !e[i]) return this.warn("Levels object was unset while buffering fragment " + n + " of level " + i + ". The current chunk will not be buffered."), null;
                        var a = e[i],
                          i = function () {
                            if (!a || !a.details) return null;
                            var t = a.details;
                            return t.fragments[n - t.startSN]
                          }();
                        return this._fragLoadAborted(i) ? null : {
                          frag: r,
                          partIndex: t.part,
                          level: a
                        }
                      }, r.bufferFragmentData = function (t, e, r) {
                        var i, n, a;
                        t && this.state === lt && (i = t.data1, n = t.data2, (a = (a = i) && n ? Object(s.a)(i, n) : a) && a.length && (r = {
                          type: t.type,
                          data: a,
                          frag: e,
                          chunkMeta: r
                        }, this.hls.trigger(p.a.BUFFER_APPENDING, r), this.tick()))
                      }, r.getNextFragment = function (t, e) {
                        var r = this.config,
                          i = this.startFragRequested,
                          n = e.fragments,
                          a = n.length;
                        if (!a) return null;
                        var s, o = n[0].start,
                          l = e.edge;
                        if (e.initSegment && !e.initSegment.data) s = e.initSegment;
                        else if (e.live) {
                          r = r.initialLiveManifestSize;
                          if (a < r) return this.warn("Not enough fragments to start playback (have: " + a + ", need: " + r + ")"), null;
                          e.PTSKnown || i || (s = this.getInitialLiveFragment(e, n))
                        } else t < o && (s = n[0]);
                        return s = s || this.getFragmentAtPosition(t, l, e)
                      }, r.getInitialLiveFragment = function (t, e) {
                        var r, i = this.config,
                          n = this.fragPrevious,
                          a = null;
                        return n && (t.hasProgramDateTime ? (this.log("Live playlist, switching playlist, load frag with same PDT: " + n.programDateTime), a = function (t, e, r) {
                          if (null === e || !Array.isArray(t) || !t.length || !Object(B.a)(e)) return null;
                          if (e < (t[0].programDateTime || 0)) return null;
                          if (e >= (t[t.length - 1].endProgramDateTime || 0)) return null;
                          r = r || 0;
                          for (var i, n, a, s = 0; s < t.length; ++s) {
                            var o = t[s];
                            if (i = e, n = r, a = o, n = 1e3 * Math.min(r, a.duration + (a.deltaPTS || 0)), (a.endProgramDateTime || 0) - n > i) return o
                          }
                          return null
                        }(e, n.endProgramDateTime, i.maxFragLookUpTolerance)) : ((i = n.sn + 1) >= t.startSN && i <= t.endSN && (t = e[i - t.startSN], n.cc === t.cc && this.log("Live playlist, switching playlist, load frag with next SN: " + (a = t).sn)), a || (r = n.cc, (a = tt(e, function (t) {
                          return t.cc < r ? 1 : t.cc > r ? -1 : 0
                        })) && this.log("Live playlist, switching playlist, load frag with same CC: " + a.sn)))), a
                      }, r.getFragmentAtPosition = function (t, e, r) {
                        var i = this.config,
                          n = this.fragPrevious,
                          a = r.fragments,
                          s = i.maxFragLookUpTolerance,
                          i = t < e ? function (t, e, r) {
                            void 0 === e && (e = 0), void 0 === r && (r = 0);
                            var i = null;
                            return n ? i = t[n.sn - t[0].sn + 1] : 0 === e && 0 === t[0].start && (i = t[0]), (!i || 0 !== et(e, r, i)) && tt(t, et.bind(null, e, r)) || i
                          }(a, t, e - s < t ? 0 : s) : a[a.length - 1];
                        return i && (e = i.sn - r.startSN, t = n && i.level === n.level, s = a[e - 1], a = a[1 + e], n && i.sn === n.sn && (t && !i.backtracked ? i.sn < r.endSN ? this.fragmentTracker.getState(i = a) !== _.OK && this.log("SN just loaded, load next one: " + i.sn) : i = null : i.backtracked && (null != a && a.backtracked ? (this.warn("Already backtracked from fragment " + a.sn + ", will not backtrack to fragment " + i.sn + ". Loading fragment " + a.sn), i = a) : (i.dropped = 0, s ? (i = s).backtracked = !0 : e && (i = null))))), i
                      }, r.synchronizeToLiveEdge = function (t) {
                        var e = this.config,
                          r = this.media,
                          i = this.hls.liveSyncPosition,
                          n = r.currentTime;
                        if (null !== i && null != r && r.readyState && r.duration > i && n < i) {
                          var a = void 0 !== e.liveMaxLatencyDuration ? e.liveMaxLatencyDuration : e.liveMaxLatencyDurationCount * t.targetduration,
                            s = t.fragments[0].start,
                            t = t.edge;
                          if (n < Math.max(s - e.maxFragLookUpTolerance, t - a)) return this.warn("Playback: " + n.toFixed(3) + " is located too far from the end of live sliding playlist: " + t + ", reset currentTime to : " + i.toFixed(3)), (!this.loadedmetadata || 1 < this.hls.config.mildomFragMaxParallelLoadNum) && (this.nextLoadPosition = i), r.currentTime = i
                        }
                        return null
                      }, r.alignPlaylists = function (t, e) {
                        var r = this.levels,
                          i = this.levelLastLoaded,
                          r = null !== i ? r[i] : null,
                          i = 0;
                        return e && 0 < t.fragments.length ? (i = t.fragments[0].start, t.alignedSliding && Object(B.a)(i) ? this.log("Live playlist sliding:" + i.toFixed(3)) : i || (this.warn("[" + this.constructor.name + "] Live playlist - outdated PTS, unknown sliding"), Z(this.fragPrevious, r, t))) : (this.log("Live playlist - first load, unknown sliding"), Z(this.fragPrevious, r, t)), i
                      }, r.waitForCdnTuneIn = function (t) {
                        return t.live && t.canBlockReload && t.tuneInGoal > Math.max(t.partHoldBack, 3 * t.partTarget)
                      }, r.setStartPosition = function (t, e) {
                        var r; - 1 !== this.startPosition && -1 !== this.lastCurrentTime || (r = t.startTimeOffset, Object(B.a)(r) ? (r < 0 && (this.log("Negative start time offset " + r + ", count from end of last fragment"), r = e + t.totalduration + r), this.log("Start time offset found in playlist, adjust startPosition to " + r), this.startPosition = r) : t.live ? (this.startPosition = this.hls.liveSyncPosition || e, this.log("Configure startPosition to " + this.startPosition)) : this.startPosition = 0, this.lastCurrentTime = this.startPosition), this.nextLoadPosition = this.startPosition
                      }, r.getLoadPosition = function () {
                        var t = this.media,
                          e = 0;
                        return this.loadedmetadata ? e = t.currentTime : this.nextLoadPosition && (e = this.nextLoadPosition), e
                      }, r.handleFragLoadAborted = function (e, t) {
                        var r = this.transmuxer;
                        r && "initSegment" !== e.sn && r.flush(new $(e.level, e.sn, e.stats.chunkCount + 1, 0, t ? t.index : -1)), Object.keys(e.elementaryStreams).forEach(function (t) {
                          e.elementaryStreams[t] = null
                        }), this.log("Fragment " + e.sn + " of level " + e.level + " was aborted, flushing transmuxer & resetting nextLoadPosition to " + this.nextLoadPosition), this.mildomFragmentRequestManager && this.mildomFragmentRequestManager.onFragLoadAborted(e)
                      }, r.updateLevelTiming = function (i, n) {
                        var a = this,
                          s = n.details;
                        Object.keys(i.elementaryStreams).forEach(function (t) {
                          var e, r = i.elementaryStreams[t];
                          r && (e = N(s, i, r.startPTS, r.endPTS, r.startDTS, r.endDTS), a.hls.trigger(p.a.LEVEL_PTS_UPDATED, {
                            details: s,
                            level: n,
                            drift: e,
                            type: t,
                            start: r.startPTS,
                            end: r.endPTS
                          }))
                        })
                      }, r.log = function (t) {
                        H.b.log(this.logPrefix + ": " + t)
                      }, r.warn = function (t) {
                        H.b.warn(this.logPrefix + ": " + t)
                      },
                      function (t, e) {
                        for (var r = 0; r < e.length; r++) {
                          var i = e[r];
                          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                      }(e.prototype, [{
                        key: "state",
                        set: function (t) {
                          var e = this._state;
                          e !== t && (this._state = t, this.log(e + "->" + t))
                        },
                        get: function () {
                          return this._state
                        }
                      }]), e
                  }(e),
                  ct = r(16),
                  ft = r(8);

                function gt() {
                  return self.MediaSource || self.WebKitMediaSource
                }
                var mt = r(12),
                  vt = gt() || {
                    isTypeSupported: function () {
                      return !1
                    }
                  },
                  pt = ((pe = yt.prototype).destroy = function () {
                    var t = this.worker;
                    t ? (t.removeEventListener("message", this.onwmsg), t.terminate(), this.worker = null) : (e = this.transmuxer) && (e.destroy(), this.transmuxer = null);
                    var e = this.observer;
                    e && e.removeAllListeners(), this.observer = null
                  }, pe.push = function (t, e, r, i, n, a, s, o, l) {
                    var u, h = this,
                      d = this.currentTransmuxSession,
                      c = this.transmuxer,
                      f = this.worker,
                      g = n.start,
                      m = n.decryptdata,
                      v = this.frag;
                    d && d.sn === o.sn && d.level === o.level || (n.stats.parsing.start = performance.now(), u = !(v && n.cc === v.cc), d = !(v && n.level === v.level), v = !(!v || n.sn !== v.sn + 1), H.b.log("[transmuxer-interface, " + n.type + "]: Starting new transmux session for fragment " + n.sn + ", of level " + n.level + ":\n        discontinuity: " + u + "\n        trackSwitch: " + d + "\n        contiguous: " + (v = !d && v) + "\n        accurateTimeOffset: " + s + "\n        timeOffset: " + g), this.currentTransmuxSession = o, l = new ft.a(r, i, new Uint8Array(e), a, l), g = new ft.b(u, v, s, d, g), this.configureTransmuxer(l, g)), this.frag = n, f ? f.postMessage({
                      cmd: "demux",
                      data: t,
                      decryptdata: m,
                      chunkMeta: o
                    }, t instanceof ArrayBuffer ? [t] : []) : c && (o = c.push(t, m, o), Object(ft.d)(o) ? o.then(function (t) {
                      h.handleTransmuxComplete(t)
                    }) : this.handleTransmuxComplete(o))
                  }, pe.flush = function (e) {
                    var r = this,
                      t = this.transmuxer,
                      i = this.worker;
                    this.currentTransmuxSession = null, e.transmuxing.start = performance.now(), i ? i.postMessage({
                      cmd: "flush",
                      chunkMeta: e
                    }) : t && (t = t.flush(e), Object(ft.d)(t) ? t.then(function (t) {
                      r.handleFlushResult(t, e)
                    }) : this.handleFlushResult(t, e))
                  }, pe.handleFlushResult = function (t, e) {
                    var r = this;
                    t.forEach(function (t) {
                      r.handleTransmuxComplete(t)
                    }), this.onFlush(e)
                  }, pe.onWorkerMessage = function (t) {
                    var e = t.data,
                      r = this.hls;
                    switch (e.event) {
                    case "init":
                      self.URL.revokeObjectURL(this.worker.objectURL);
                      break;
                    case "transmuxComplete":
                      this.handleTransmuxComplete(e.data);
                      break;
                    case "flush":
                      this.onFlush(e.data);
                      break;
                    default:
                      e.data = e.data || {}, e.data.frag = this.frag, e.data.id = this.id, r.trigger(e.event, e.data)
                    }
                  }, pe.configureTransmuxer = function (t, e) {
                    var r = this.worker,
                      i = this.transmuxer;
                    r ? r.postMessage({
                      cmd: "configure",
                      config: t,
                      state: e
                    }) : i && i.configure(t, e)
                  }, pe.handleTransmuxComplete = function (t) {
                    t.chunkMeta.transmuxing.end = performance.now(), this.onTransmuxComplete(t)
                  }, yt);

                function yt(r, t, e, i) {
                  var n = this;
                  this.hls = void 0, this.id = void 0, this.observer = void 0, this.frag = void 0, this.worker = void 0, this.onwmsg = void 0, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.currentTransmuxSession = null, this.hls = r, this.id = t, this.onTransmuxComplete = e, this.onFlush = i;
                  var a = r.config,
                    e = function (t, e) {
                      (e = e || {}).frag = n.frag, e.id = n.id, r.trigger(t, e)
                    };
                  this.observer = new mt.EventEmitter, this.observer.on(p.a.FRAG_DECRYPTED, e), this.observer.on(p.a.ERROR, e);
                  var s, i = {
                      mp4: vt.isTypeSupported("video/mp4"),
                      mpeg: vt.isTypeSupported("audio/mpeg"),
                      mp3: vt.isTypeSupported('audio/mp4; codecs="mp3"')
                    },
                    e = navigator.vendor;
                  if (a.enableWorker && "undefined" != typeof Worker) {
                    H.b.log("demuxing in webworker");
                    try {
                      s = this.worker = ct(17), this.onwmsg = this.onWorkerMessage.bind(this), s.addEventListener("message", this.onwmsg), s.onerror = function (t) {
                        r.trigger(p.a.ERROR, {
                          type: g.b.OTHER_ERROR,
                          details: g.a.INTERNAL_EXCEPTION,
                          fatal: !0,
                          event: "demuxerWorker",
                          err: {
                            message: t.message + " (" + t.filename + ":" + t.lineno + ")"
                          }
                        })
                      }, s.postMessage({
                        cmd: "init",
                        typeSupported: i,
                        vendor: e,
                        id: t,
                        config: JSON.stringify(a),
                        debug: a.debug
                      })
                    } catch (r) {
                      H.b.warn("Error in worker:", r), H.b.error("Error while initializing DemuxerWorker, fallback to inline"), s && self.URL.revokeObjectURL(s.objectURL), this.transmuxer = new ft.c(this.observer, i, a, e), this.worker = null
                    }
                  } else this.transmuxer = new ft.c(this.observer, i, a, e)
                }
                var Et = function (t) {
                    for (var e = "", r = t.length, i = 0; i < r; i++) e += "[" + t.start(i).toFixed(3) + "," + t.end(i).toFixed(3) + "]";
                    return e
                  },
                  bt = ((Nt = St.prototype).poll = function (t) {
                    var e = this.config,
                      r = this.media,
                      i = this.stalled,
                      n = r.currentTime,
                      a = r.seeking,
                      s = this.seeking && !a,
                      o = !this.seeking && a,
                      l = self.performance.now();
                    if (this.seeking = a, n === t) {
                      if ((o || s) && (this.stalled = null), !r.paused && !r.ended && 0 !== r.playbackRate && P.getBuffered(r).length) {
                        var u = P.bufferInfo(r, n, 0),
                          t = 0 < u.len,
                          o = u.nextStart || 0;
                        if (t || o) {
                          if (a) {
                            s = 2 < u.len, t = !o || 2 < o - n && !this.fragmentTracker.getPartialFragment(n);
                            if (s || t) return;
                            this.moved = !1
                          }
                          if (!this.moved && null !== this.stalled) {
                            var h, o = Math.max(o, u.start || 0) - n,
                              d = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null,
                              d = null != d && null !== (h = d.details) && void 0 !== h && h.live ? 2 * d.details.targetduration : 2;
                            if (0 < o && o <= d) return void this._trySkipBufferHole(null)
                          }
                          null !== i ? (d = l - i, !a && 1e3 <= d && this._reportStall(u.len), e = P.bufferInfo(r, n, e.maxBufferHole), this._tryFixBufferStall(e, d)) : this.stalled = l
                        }
                      }
                    } else this.moved = !0, null !== i && (this.stallReported && (i = self.performance.now() - i, H.b.warn("playback not stuck anymore @" + n + ", after " + Math.round(i) + "ms"), this.stallReported = !1, this.stalled && this.hls.trigger(p.a.MILDOM_STALL_RECOVER, {
                      stallDuration: Math.round(self.performance.now() - this.stalled)
                    })), this.stalled = null, this.nudgeRetry = 0)
                  }, Nt._tryFixBufferStall = function (t, e) {
                    var r = this.config,
                      i = this.fragmentTracker,
                      n = this.media.currentTime,
                      n = i.getPartialFragment(n);
                    n && this._trySkipBufferHole(n) || t.len > r.maxBufferHole && e > 1e3 * r.highBufferWatchdogPeriod && (H.b.warn("Trying to nudge playhead over buffer-hole"), this.stalled = null, this._tryNudgeBuffer())
                  }, Nt._reportStall = function (t) {
                    var e = this.hls,
                      r = this.media;
                    this.stallReported || (this.stallReported = !0, H.b.warn("Playback stalling at @" + r.currentTime + " due to low buffer (buffer=" + t + ")"), e.trigger(p.a.ERROR, {
                      type: g.b.MEDIA_ERROR,
                      details: g.a.BUFFER_STALLED_ERROR,
                      fatal: !1,
                      buffer: t
                    }))
                  }, Nt._trySkipBufferHole = function (t) {
                    for (var e = this.config, r = this.hls, i = this.media, n = i.currentTime, a = 0, s = P.getBuffered(i), o = 0; o < s.length; o++) {
                      var l = s.start(o);
                      if (n + e.maxBufferHole >= a && n < l) {
                        l = Math.max(l + .05, i.currentTime + .1);
                        return H.b.warn("skipping hole, adjusting currentTime from " + n + " to " + l), this.moved = !0, this.stalled = null, i.currentTime = l, t && r.trigger(p.a.ERROR, {
                          type: g.b.MEDIA_ERROR,
                          details: g.a.BUFFER_SEEK_OVER_HOLE,
                          fatal: !1,
                          reason: "fragment loaded with buffer holes, seeking from " + n + " to " + l,
                          frag: t
                        }), l
                      }
                      a = s.end(o)
                    }
                    return 0
                  }, Nt._tryNudgeBuffer = function () {
                    var t = this.config,
                      e = this.hls,
                      r = this.media,
                      i = r.currentTime,
                      n = (this.nudgeRetry || 0) + 1;
                    (this.nudgeRetry = n) < t.nudgeMaxRetry ? (n = i + n * t.nudgeOffset, H.b.warn("Nudging 'currentTime' from " + i + " to " + n), r.currentTime = n, e.trigger(p.a.ERROR, {
                      type: g.b.MEDIA_ERROR,
                      details: g.a.BUFFER_NUDGE_ON_STALL,
                      fatal: !1
                    })) : (H.b.error("Playhead still not moving while enough data buffered @" + i + " after " + t.nudgeMaxRetry + " nudges"), e.trigger(p.a.ERROR, {
                      type: g.b.MEDIA_ERROR,
                      details: g.a.BUFFER_STALLED_ERROR,
                      fatal: !0
                    }))
                  }, St);

                function St(t, e, r, i) {
                  this.config = void 0, this.media = void 0, this.fragmentTracker = void 0, this.hls = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.config = t, this.media = e, this.fragmentTracker = r, this.hls = i
                }

                function _t(t) {
                  var r = "function" == typeof Map ? new Map : void 0;
                  return (_t = function (t) {
                    if (null === t || -1 === Function.toString.call(t).indexOf("[native code]")) return t;
                    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                    if (void 0 !== r) {
                      if (r.has(t)) return r.get(t);
                      r.set(t, e)
                    }

                    function e() {
                      return Lt(t, arguments, At(this).constructor)
                    }
                    return e.prototype = Object.create(t.prototype, {
                      constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                      }
                    }), Tt(e, t)
                  })(t)
                }

                function Lt(t, e, r) {
                  return (Lt = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                      return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
                    } catch (t) {
                      return !1
                    }
                  }() ? Reflect.construct : function (t, e, r) {
                    var i = [null];
                    i.push.apply(i, e);
                    i = new(Function.bind.apply(t, i));
                    return r && Tt(i, r.prototype), i
                  }).apply(null, arguments)
                }

                function Tt(t, e) {
                  return (Tt = Object.setPrototypeOf || function (t, e) {
                    return t.__proto__ = e, t
                  })(t, e)
                }

                function At(t) {
                  return (At = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                  })(t)
                }
                var Rt = ((se = Dt.prototype).abort = function (t) {
                  this.loader && (1 < this.config.mildomFragMaxParallelLoadNum && this.loader.context.frag.sn !== t.sn || (console.log("Abort frag loader " + this.loader.context.url, this.loader), this.loader.abort()))
                }, se.load = function (a, t, s) {
                  var o = this,
                    e = a.url;
                  if (!e) return Promise.reject(new Ct({
                    type: g.b.NETWORK_ERROR,
                    details: g.a.INTERNAL_EXCEPTION,
                    fatal: !1,
                    frag: a,
                    networkDetails: null
                  }, "Fragment does not have a " + (e ? "part list" : "url")));
                  var r = this.config,
                    i = r.fLoader,
                    e = r.loader;
                  this.abort(a);
                  var n, l = this.loader = a.loader = new(i || e)(r),
                    u = {
                      timeout: r.fragLoadingTimeOut,
                      maxRetry: 0,
                      retryDelay: 0,
                      maxRetryDelay: r.fragLoadingMaxRetryTimeout,
                      highWaterMark: 0
                    },
                    h = (e = (n = void 0 === n ? null : n) || a, r = {
                      frag: a,
                      part: n,
                      responseType: "arraybuffer",
                      url: e.url,
                      rangeStart: 0,
                      rangeEnd: 0
                    }, n = e.byteRangeStartOffset, e = e.byteRangeEndOffset, Object(B.a)(n) && Object(B.a)(e) && (r.rangeStart = n, r.rangeEnd = e), r);
                  return new Promise(function (n, i) {
                    l.stats = a.stats, l.load(h, u, {
                      onSuccess: function (t, e, r, i) {
                        o.resetLoader(a, l), n({
                          frag: a,
                          payload: t.data,
                          networkDetails: i
                        })
                      },
                      onError: function (t, e, r) {
                        o.resetLoader(a, l), i(new Ct({
                          type: g.b.NETWORK_ERROR,
                          details: g.a.FRAG_LOAD_ERROR,
                          fatal: !1,
                          frag: a,
                          response: t,
                          networkDetails: r
                        }))
                      },
                      onAbort: function (t, e, r) {
                        o.resetLoader(a, l), i(new Ct({
                          type: g.b.NETWORK_ERROR,
                          details: g.a.INTERNAL_ABORTED,
                          fatal: !1,
                          frag: a,
                          networkDetails: r
                        }))
                      },
                      onTimeout: function (t, e, r) {
                        o.resetLoader(a, l), i(new Ct({
                          type: g.b.NETWORK_ERROR,
                          details: g.a.FRAG_LOAD_TIMEOUT,
                          fatal: !1,
                          frag: a,
                          networkDetails: r
                        }))
                      },
                      onProgress: function (t, e, r, i) {
                        s && s({
                          frag: a,
                          payload: r,
                          networkDetails: i
                        })
                      }
                    })
                  })
                }, se.resetLoader = function (t, e) {
                  t.loader = null, this.loader === e && (self.clearTimeout(this.partLoadTimeout), this.nextPartIndex = -1, this.loader = null)
                }, Dt);

                function Dt(t) {
                  this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.nextPartIndex = -1, this.config = t
                }
                var kt, Ct = (kt = _t(Error), Se = kt, (_e = Pt).prototype = Object.create(Se.prototype), (_e.prototype.constructor = _e).__proto__ = Se, Pt),
                  wt = ((ne = xt.prototype).destory = function () {
                    var t = this.hls;
                    t.off(p.a.FRAG_LOADING, this.onFragLoading, this), t.off(p.a.FRAG_BUFFERED, this.onFragBuffered, this), t.off(p.a.ERROR, this.onError, this)
                  }, ne.getNextFragment = function (t, e) {
                    var r = this.findFragment(t, e),
                      t = !this.hasAvaiableConnection(),
                      e = r && 0 < this.loadingFrags.length && r.sn <= this.loadingFrags[this.loadingFrags.length - 1].sn;
                    return r = t || e ? null : r
                  }, ne.getLatestRequestFrag = function () {
                    return 0 < this.loadingFrags.length ? this.loadingFrags[this.loadingFrags.length - 1] : null
                  }, ne.removePendingFrag = function (e) {
                    this.loadingFrags = this.loadingFrags.filter(function (t) {
                      return t.sn !== e.sn
                    })
                  }, ne.hasAvaiableConnection = function () {
                    return 0 < this.hls.config.mildomFragMaxParallelLoadNum - this.loadingFrags.length
                  }, ne.onFragLoadAborted = function (t) {
                    this.removePendingFrag(t), this.abortedFrags.push(t), H.b.log("[mildom-fragment-request-manager]: remove frag " + t.sn + " due to load aborted, current loading pending frags[" + this.loadingFrags.map(function (t) {
                      return t.sn
                    }).join(",") + "]")
                  }, ne.enquePendingFragParse = function (t, e) {
                    this.removePendingFrag(t), H.b.log("[mildom-fragment-request-manager]: remove frag " + (null == t ? void 0 : t.sn) + " due to loaded, current loading pending frags[" + this.loadingFrags.map(function (t) {
                      return t.sn
                    }).join(",") + "]"), this.pendingFragParse.push({
                      frag: t,
                      parse: e
                    }), this.pendingFragParse.sort(function (t, e) {
                      return t.frag.sn - e.frag.sn
                    }), this.comusePendingParse()
                  }, ne.abort = function () {
                    var e = this;
                    this.loadingFrags.forEach(function (t) {
                      t.loader && (t.loader.abort(), e.abortedFrags.push(t))
                    }), this.loadingFrags = [], this.pendingFragParse = [], this.currentParseFrag = null, H.b.log("[mildom-fragment-request-manager]: abort all request")
                  }, ne.comusePendingParse = function () {
                    var t;
                    this.pendingFragParse.length <= 0 || (t = this.pendingFragParse.shift(), this.currentParseFrag = t.frag, H.b.log("[mildom-fragment-request-manager]: consume frag " + this.currentParseFrag.sn), t.parse())
                  }, ne.onFragLoading = function (t, e) {
                    var r = e.frag;
                    0 === this.loadingFrags.filter(function (t) {
                      return t.sn === r.sn
                    }).length && (this.loadingFrags.push(r), this.loadingFrags.sort(function (t, e) {
                      return t.sn - e.sn
                    })), H.b.log("[mildom-fragment-request-manager]: current loading pending frags[" + this.loadingFrags.map(function (t) {
                      return t.sn
                    }).join(",") + "]")
                  }, ne.onFragBuffered = function (t, e) {
                    e = e.frag;
                    0 < this.pendingFragParse.length && this.pendingFragParse[0].frag.sn === e.sn + 1 && this.comusePendingParse()
                  }, ne.onError = function (t, e) {
                    switch (e.details) {
                    case g.a.FRAG_LOAD_ERROR:
                    case g.a.FRAG_LOAD_TIMEOUT:
                      e.frag && (this.removePendingFrag(e.frag), H.b.log("[mildom-fragment-request-manager]: remove frag " + e.frag.sn + " due to error, current pending frags[" + this.loadingFrags.map(function (t) {
                        return t.sn
                      }).join(",") + "]"))
                    }
                  }, ne.isFragAborted = function (e) {
                    return !e || 0 !== this.abortedFrags.filter(function (t) {
                      return t.sn === e.sn
                    }).length
                  }, xt);

                function xt(t, e) {
                  this.loadingFrags = [], this.pendingFragParse = [], this.abortedFrags = [], this.hls = void 0, this.findFragment = void 0, this.currentParseFrag = null, this.hls = t, this.findFragment = e, t.on(p.a.FRAG_LOADING, this.onFragLoading, this), t.on(p.a.FRAG_BUFFERED, this.onFragBuffered, this), t.on(p.a.ERROR, this.onError, this)
                }

                function Pt(t) {
                  for (var e, r = arguments.length, i = new Array(1 < r ? r - 1 : 0), n = 1; n < r; n++) i[n - 1] = arguments[n];
                  return (e = kt.call.apply(kt, [this].concat(i)) || this).data = void 0, e.data = t, e
                }
                var Ot, Ft = function (i) {
                  var t;

                  function e(t, e) {
                    var r;
                    return (r = i.call(this, t, e) || this).audioCodecSwap = !1, r.bitrateTest = !1, r.gapController = null, r.level = -1, r._forceStartLoad = !1, r.retryDate = 0, r.altAudio = !1, r.audioOnly = !1, r.fragPlaying = null, r.previouslyPaused = !1, r.immediateSwitch = !1, r.onvplaying = null, r.onvseeking = null, r.onvseeked = null, r.onvended = null, r.fragLastKbps = 0, r.stalled = !1, r.audioCodecSwitch = !1, r.videoBuffer = null, r.logPrefix = "[stream-controller]", r.fragmentLoader = new Rt(t.config), r.fragmentTracker = e, r.state = it, r.mildomFragmentRequestManager = 1 < t.config.mildomFragMaxParallelLoadNum ? new wt(t, r.getNextFragment.bind(function (t) {
                      if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      return t
                    }(r))) : null, r._registerListeners(), r
                  }
                  r = i, (t = e).prototype = Object.create(r.prototype), (t.prototype.constructor = t).__proto__ = r;
                  var r = e.prototype;
                  return r._registerListeners = function () {
                      var t = this.hls;
                      t.on(p.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(p.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(p.a.MANIFEST_LOADING, this.onManifestLoading, this), t.on(p.a.MANIFEST_PARSED, this.onManifestParsed, this), t.on(p.a.LEVEL_LOADING, this.onLevelLoading, this), t.on(p.a.LEVEL_LOADED, this.onLevelLoaded, this), t.on(p.a.KEY_LOADED, this.onKeyLoaded, this), t.on(p.a.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.on(p.a.ERROR, this.onError, this), t.on(p.a.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.on(p.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.on(p.a.BUFFER_CREATED, this.onBufferCreated, this), t.on(p.a.BUFFER_FLUSHED, this.onBufferFlushed, this), t.on(p.a.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(p.a.FRAG_BUFFERED, this.onFragBuffered, this)
                    }, r._unregisterListeners = function () {
                      var t = this.hls;
                      t.off(p.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(p.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(p.a.MANIFEST_LOADING, this.onManifestLoading, this), t.off(p.a.MANIFEST_PARSED, this.onManifestParsed, this), t.off(p.a.LEVEL_LOADED, this.onLevelLoaded, this), t.off(p.a.KEY_LOADED, this.onKeyLoaded, this), t.off(p.a.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), t.off(p.a.ERROR, this.onError, this), t.off(p.a.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), t.off(p.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.off(p.a.BUFFER_CREATED, this.onBufferCreated, this), t.off(p.a.BUFFER_FLUSHED, this.onBufferFlushed, this), t.off(p.a.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(p.a.FRAG_BUFFERED, this.onFragBuffered, this)
                    }, r.onHandlerDestroying = function () {
                      this._unregisterListeners(), this.mildomFragmentRequestManager && this.mildomFragmentRequestManager.destory()
                    }, r.startLoad = function (t) {
                      var e, r, i;
                      this.levels ? (e = this.lastCurrentTime, r = this.hls, this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, this.startFragRequested || (-1 === (i = r.startLevel) && (r.config.testBandwidth ? this.bitrateTest = !(i = 0) : i = r.nextAutoLevel), this.level = r.nextLoadLevel = i, this.loadedmetadata = !1), 0 < e && -1 === t && (this.log("Override startPosition with lastCurrentTime @" + e.toFixed(3)), t = e), this.state = nt, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = t, this.tick()) : (this._forceStartLoad = !0, this.state = it)
                    }, r.stopLoad = function () {
                      this._forceStartLoad = !1, i.prototype.stopLoad.call(this)
                    }, r.doTick = function () {
                      switch (this.state) {
                      case nt:
                        this.doTickIdle();
                        break;
                      case st:
                        null !== (t = this.mildomFragmentRequestManager) && void 0 !== t && t.hasAvaiableConnection() && this.doTickIdle();
                        break;
                      case ht:
                        var t = this.levels,
                          e = this.level,
                          e = null == t || null === (r = t[e]) || void 0 === r ? void 0 : r.details;
                        if (!e || e.live && this.levelLastLoaded !== this.level) break;
                        if (this.waitForCdnTuneIn(e)) break;
                        this.state = nt;
                        break;
                      case ot:
                        var r = self.performance.now(),
                          e = this.retryDate;
                        (!e || e <= r || null !== (r = this.media) && void 0 !== r && r.seeking) && (this.log("retryDate reached, switch back to IDLE state"), this.state = nt)
                      }
                      this.onTickEnd()
                    }, r.onTickEnd = function () {
                      i.prototype.onTickEnd.call(this), this.checkBuffer(), this.checkFragmentChanged()
                    }, r.doTickIdle = function () {
                      var t = this.hls,
                        e = this.levelLastLoaded,
                        r = this.levels,
                        i = this.media,
                        n = t.config,
                        a = t.nextLoadLevel;
                      if (null !== e && (i || !(this.startFragRequested && n.mildomFragMaxParallelLoadNum <= 1) && n.startFragPrefetch) && (!this.altAudio || !this.audioOnly) && r && r[a]) {
                        var s = r[a],
                          e = this.getLoadPosition();
                        if (Object(B.a)(e)) {
                          var r = s.maxBitrate,
                            r = r ? Math.max(8 * n.maxBufferSize / r, n.maxBufferLength) : n.maxBufferLength;
                          r = Math.min(r, n.maxMaxBufferLength);
                          var n = e < n.maxBufferHole ? Math.max(2, n.maxBufferHole) : n.maxBufferHole,
                            n = P.bufferInfo(this.mediaBuffer || i, e, n);
                          if (!(n.len >= r)) {
                            this.level = t.nextLoadLevel = a;
                            t = s.details;
                            if (!t || this.state === ht || t.live && this.levelLastLoaded !== a) this.state = ht;
                            else {
                              if (this._streamEnded(n, t)) {
                                if (this.hls.config.mildomRealtimePlaybackMode && !(1 < this.media.playbackRate || t.isMildomLiveEnd)) return;
                                var o = {
                                  isLiveEnd: t.isMildomLiveEnd
                                };
                                return this.altAudio && (o.type = "video"), this.hls.trigger(p.a.BUFFER_EOS, o), void(this.state = "ENDED")
                              }
                              var l, s = n.end,
                                o = this.mildomFragmentRequestManager ? this.mildomFragmentRequestManager.getNextFragment(this.nextLoadPosition, t) : this.getNextFragment(s, t);
                              (o = o && this.fragmentTracker.getState(o) === _.OK && this.nextLoadPosition > s ? this.getNextFragment(this.nextLoadPosition, t) : o) && ("identity" !== (null === (n = o.decryptdata) || void 0 === n ? void 0 : n.keyFormat) || null !== (l = o.decryptdata) && void 0 !== l && l.key ? ((null === (l = this.fragCurrent) || void 0 === l ? void 0 : l.sn) !== o.sn && this.log("Loading fragment " + o.sn + " of [" + t.startSN + "-" + t.endSN + "], level " + a + ", " + (this.loadedmetadata ? "currentTime" : "nextLoadPosition") + ": " + parseFloat(e.toFixed(3)) + ", bufferInfo.end: " + parseFloat(s.toFixed(3))), this.loadFragment(o, s)) : (this.log("Loading key for " + o.sn + " of [" + t.startSN + "-" + t.endSN + "], level " + a), this.loadKey(o)))
                            }
                          }
                        }
                      }
                    }, r.loadKey = function (t) {
                      this.state = at, this.hls.trigger(p.a.KEY_LOADING, {
                        frag: t
                      })
                    }, r.loadFragment = function (t, e) {
                      var r = this.fragmentTracker.getState(t);
                      this.fragCurrent = t, Object(B.a)(t.sn) && !this.bitrateTest && (this.nextLoadPosition = t.start + t.duration), t.backtracked || r === _.NOT_LOADED || r === _.PARTIAL ? "initSegment" === t.sn ? this._loadInitSegment(t) : this.bitrateTest ? (t.bitrateTest = !0, this.log("Fragment " + t.sn + " of level " + t.level + " is being downloaded to test bitrate and will not be buffered"), this._loadBitrateTestFrag(t)) : (this.startFragRequested = !0, this._loadFragForPlayback(t, e)) : r === _.APPENDING ? this._reduceMaxBufferLength(t.duration) && this.fragmentTracker.removeFragment(t) : 0 === (null === (t = this.media) || void 0 === t ? void 0 : t.buffered.length) && this.fragmentTracker.removeAllFragments()
                    }, r.getAppendedFrag = function (t) {
                      return this.fragmentTracker.getAppendedFrag(t, v.MAIN)
                    }, r.getBufferedFrag = function (t) {
                      return this.fragmentTracker.getBufferedFrag(t, v.MAIN)
                    }, r.followingBufferedFrag = function (t) {
                      return t ? this.getBufferedFrag(t.end + .5) : null
                    }, r.immediateLevelSwitch = function () {
                      var t;
                      this.log("immediateLevelSwitch"), this.immediateSwitch || (this.immediateSwitch = !0, (t = this.media) ? (e = t.paused) || t.pause() : e = !0, this.previouslyPaused = e);
                      var e = this.fragCurrent;
                      null != e && e.loader && e.loader.abort(), this.fragCurrent = null, this.mildomFragmentRequestManager && this.mildomFragmentRequestManager.abort(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY)
                    }, r.immediateLevelSwitchEnd = function () {
                      var t = this.media;
                      P.getBuffered(t).length && (this.immediateSwitch = !1, 0 < t.currentTime && P.isBuffered(t, t.currentTime) && (t.currentTime -= 1e-4), this.previouslyPaused || t.play())
                    }, r.nextLevelSwitch = function () {
                      var t, e, r, i = this.levels,
                        n = this.media;
                      null != n && n.readyState && ((t = this.getAppendedFrag(n.currentTime)) && 1 < t.start && this.flushMainBuffer(0, t.start - 1), r = !n.paused && i ? (r = i[this.hls.nextLoadLevel], (e = this.fragLastKbps) && this.fragCurrent ? this.fragCurrent.duration * r.maxBitrate / (1e3 * e) + 1 : 0) : 0, !(e = this.getBufferedFrag(n.currentTime + r)) || (n = this.followingBufferedFrag(e)) && (null != (r = this.fragCurrent) && r.loader && r.loader.abort(), this.fragCurrent = null, r = n.maxStartPTS || n.start, n = Math.max(e.end, r + Math.min(this.config.maxFragLookUpTolerance, n.duration)), this.flushMainBuffer(n, Number.POSITIVE_INFINITY)))
                    }, r.flushMainBuffer = function (t, e) {
                      e = {
                        startOffset: t,
                        endOffset: e,
                        type: this.altAudio ? "video" : null
                      };
                      this.fragLoadError = 0, this.hls.trigger(p.a.BUFFER_FLUSHING, e)
                    }, r.onMediaAttached = function (t, e) {
                      var r = this.media = this.mediaBuffer = e.media;
                      this.onvplaying = this.onMediaPlaying.bind(this), this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), r.addEventListener("playing", this.onvplaying), r.addEventListener("seeking", this.onvseeking), r.addEventListener("seeked", this.onvseeked), r.addEventListener("ended", this.onvended);
                      e = this.config;
                      this.levels && e.autoStartLoad && this.hls.startLoad(e.startPosition), this.gapController = new bt(e, r, this.fragmentTracker, this.hls)
                    }, r.onMediaDetaching = function () {
                      var t = this.levels,
                        e = this.media;
                      null != e && e.ended && (this.log("MSE detaching and video ended, reset startPosition"), this.startPosition = this.lastCurrentTime = 0), t && t.forEach(function (t) {
                        t.details && t.details.fragments.forEach(function (t) {
                          t.backtracked = !1
                        })
                      }), e && (e.removeEventListener("playing", this.onvplaying), e.removeEventListener("seeking", this.onvseeking), e.removeEventListener("seeked", this.onvseeked), e.removeEventListener("ended", this.onvended), this.onvplaying = this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad()
                    }, r.onMediaPlaying = function () {
                      this.tick()
                    }, r.onMediaSeeked = function () {
                      var t = this.media,
                        t = t ? t.currentTime : null;
                      Object(B.a)(t) && this.log("Media seeked to " + t.toFixed(3)), this.tick()
                    }, r.onManifestLoading = function () {
                      this.log("Trigger BUFFER_RESET"), this.hls.trigger(p.a.BUFFER_RESET, void 0), this.fragmentTracker.removeAllFragments(), this.stalled = !1, this.startPosition = this.lastCurrentTime = 0, this.fragPlaying = null
                    }, r.onManifestParsed = function (t, e) {
                      var r, i = !1,
                        n = !1;
                      e.levels.forEach(function (t) {
                        (r = t.audioCodec) && (-1 !== r.indexOf("mp4a.40.2") && (i = !0), -1 !== r.indexOf("mp4a.40.5") && (n = !0))
                      }), this.audioCodecSwitch = i && n, this.audioCodecSwitch && this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC"), this.levels = e.levels, this.startFragRequested = !1
                    }, r.onLevelLoading = function (t, e) {
                      var r = this.levels;
                      !r || this.state !== nt || (!(r = r[e.level]).details || r.details.live && this.levelLastLoaded !== e.level || this.waitForCdnTuneIn(r.details)) && (this.state = ht)
                    }, r.onLevelLoaded = function (t, e) {
                      var r = this.levels,
                        i = e.level,
                        n = e.details,
                        a = n.totalduration;
                      if (r) {
                        this.log("Level " + i + " loaded [" + n.startSN + "," + n.endSN + "], cc [" + n.startCC + ", " + n.endCC + "] duration:" + a);
                        a = this.fragCurrent;
                        !a || this.state !== st && this.state !== ot || a.level !== e.level && a.loader && (this.state = nt, a.loader.abort());
                        e = r[i], a = 0;
                        if (n.live || null !== (r = e.details) && void 0 !== r && r.live) {
                          if (n.deltaUpdateFailed) return;
                          a = this.alignPlaylists(n, e.details)
                        }
                        if (e.details = n, this.levelLastLoaded = i, this.hls.trigger(p.a.LEVEL_UPDATED, {
                            details: n,
                            level: i
                          }), this.state === ht) {
                          if (this.waitForCdnTuneIn(n)) return;
                          this.state = nt
                        }
                        this.startFragRequested ? n.live && this.synchronizeToLiveEdge(n) : this.setStartPosition(n, a), this.tick()
                      } else this.warn("Levels were reset while loading level " + i)
                    }, r.onKeyLoaded = function () {
                      this.state === at && (this.state = nt, this.tick())
                    }, r._handleFragmentLoadProgress = function (t) {
                      var e, r, i, n, a = t.frag,
                        s = t.part,
                        o = t.payload,
                        l = this.levels,
                        u = this.media;
                      l ? (e = (n = l[a.level]).details, r = n.videoCodec, i = !(null != u && u.seeking) && (e.PTSKnown || !e.live), l = (null === (t = e.initSegment) || void 0 === t ? void 0 : t.data) || new Uint8Array(0), u = this._getAudioCodec(n), t = this.transmuxer = this.transmuxer || new pt(this.hls, v.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), (n = new $(a.level, a.sn, a.stats.chunkCount, o.byteLength, s ? s.index : -1)).transmuxing.start = performance.now(), s = this.initPTS[a.cc], t.push(o, l, u, r, a, e.totalduration, i, n, s)) : this.warn("Levels were reset while fragment load was in progress. Fragment " + a.sn + " of level " + a.level + " will not be buffered")
                    }, r.resetTransmuxer = function () {
                      this.transmuxer && (this.transmuxer.destroy(), this.transmuxer = null)
                    }, r.onAudioTrackSwitching = function (t, e) {
                      var r, i = this.altAudio,
                        n = !!e.url,
                        e = e.id;
                      n || (this.mediaBuffer !== this.media ? (this.log("Switching on main audio, use media.buffered to schedule main fragment loading"), this.mediaBuffer = this.media, null != (r = this.fragCurrent) && r.loader && (this.log("Switching to main audio track, cancel main fragment load"), r.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.resetTransmuxer(), this.state = nt) : this.audioOnly && this.resetTransmuxer(), r = this.hls, i && r.trigger(p.a.BUFFER_FLUSHING, {
                        startOffset: 0,
                        endOffset: Number.POSITIVE_INFINITY,
                        type: "audio"
                      }), r.trigger(p.a.AUDIO_TRACK_SWITCHED, {
                        id: e
                      }))
                    }, r.onAudioTrackSwitched = function (t, e) {
                      var r = e.id,
                        e = !!this.hls.audioTracks[r].url;
                      !e || (r = this.videoBuffer) && this.mediaBuffer !== r && (this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading"), this.mediaBuffer = r), this.altAudio = e, this.tick()
                    }, r.onBufferCreated = function (t, e) {
                      var r, i = e.tracks,
                        n = !1;
                      for (r in i) {
                        var a, s, o, l = i[r];
                        "main" === l.id ? (o = l, "video" === (s = r) && (a = i[r]) && (this.videoBuffer = a.buffer)) : n = !0
                      }
                      n && o ? (this.log("Alternate track found, use " + s + ".buffered to schedule main fragment loading"), this.mediaBuffer = o.buffer) : this.mediaBuffer = this.media
                    }, r.onFragBuffered = function (t, e) {
                      var r, i = e.frag;
                      i && "main" !== i.type || (this._fragLoadAborted(i) ? this.warn("Fragment " + i.sn + " of level " + i.level + " finished buffering, but was aborted. state: " + this.state) : (r = this.mediaBuffer || this.media, e = i.stats, this.fragPrevious = i, this.fragLastKbps = Math.round(8 * e.total / (e.buffering.end - e.loading.first)), this.log("Buffered fragment " + i.sn + " of level " + i.level + ". PTS:[" + i.startPTS + "," + i.endPTS + "],DTS:[" + i.startDTS + "/" + i.endDTS + "], Buffered: " + Et(P.getBuffered(r))), this.state = nt, this.tick()))
                    }, r.onError = function (t, e) {
                      var r = e.frag || this.fragCurrent;
                      if (!r || "main" === r.type) {
                        var i, n = !!this.media && P.isBuffered(this.media, this.media.currentTime) && P.isBuffered(this.media, this.media.currentTime + .5);
                        switch (e.details) {
                        case g.a.FRAG_LOAD_ERROR:
                        case g.a.FRAG_LOAD_TIMEOUT:
                        case g.a.KEY_LOAD_ERROR:
                        case g.a.KEY_LOAD_TIMEOUT:
                          e.fatal || (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry ? (i = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout), this.warn("Fragment " + (null == r ? void 0 : r.sn) + " of level " + (null == r ? void 0 : r.level) + " failed to load, retrying in " + i + "ms"), this.retryDate = self.performance.now() + i, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.fragLoadError++, this.state = ot) : (H.b.error("[stream-controller]: " + e.details + " reaches max retry, redispatch as fatal ..."), e.fatal = !0, this.state = ut));
                          break;
                        case g.a.LEVEL_LOAD_ERROR:
                        case g.a.LEVEL_LOAD_TIMEOUT:
                          this.state !== ut && (e.fatal ? (this.warn("" + e.details), this.state = ut) : e.levelRetry || this.state !== ht || (this.state = nt));
                          break;
                        case g.a.BUFFER_FULL_ERROR:
                          "main" !== e.parent || this.state !== lt && "PARSED" !== this.state || (n ? (this._reduceMaxBufferLength(this.config.maxBufferLength), this.state = nt) : (this.warn("buffer full error also media.currentTime is not buffered, flush everything"), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY)))
                        }
                      }
                    }, r._reduceMaxBufferLength = function (t) {
                      var e = this.config;
                      return e.maxMaxBufferLength >= t && (e.maxMaxBufferLength /= 2, this.warn("Reduce max buffer length to " + e.maxMaxBufferLength + "s"), !0)
                    }, r.checkBuffer = function () {
                      var t, e = this.media,
                        r = this.gapController;
                      e && r && e.readyState && (t = P.getBuffered(e), !this.loadedmetadata && t.length ? (this.loadedmetadata = !0, this._seekToStartPos()) : this.immediateSwitch ? this.immediateLevelSwitchEnd() : r.poll(this.lastCurrentTime), this.lastCurrentTime = e.currentTime)
                    }, r.onFragLoadEmergencyAborted = function () {
                      this.state = nt, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tick()
                    }, r.onBufferFlushed = function (t, e) {
                      var r = e.type,
                        e = (r === G.a.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
                      e && r !== G.a.AUDIO && this.fragmentTracker.detectEvictedFragments(r, P.getBuffered(e)), this.fragPrevious = null, this.state = nt
                    }, r.onLevelsUpdated = function (t, e) {
                      this.levels = e.levels
                    }, r.swapAudioCodec = function () {
                      this.audioCodecSwap = !this.audioCodecSwap
                    }, r._seekToStartPos = function () {
                      var t, e = this.media,
                        r = e.currentTime,
                        i = this.startPosition;
                      r !== i && 0 <= i && (e.seeking ? H.b.log("could not seek to " + i + ", already seeking at " + r) : (0 < (t = ((t = P.getBuffered(e)).length ? t.start(0) : 0) - i) && t < this.config.maxBufferHole && (H.b.log("adjusting start position by " + t + " to match buffer start"), this.startPosition = i += t), this.log("seek to target start position " + i + " from current time " + r), e.currentTime = i))
                    }, r._getAudioCodec = function (t) {
                      t = this.config.defaultAudioCodec || t.audioCodec;
                      return this.audioCodecSwap && (this.log("Swapping playlist audio codec"), t = t && (-1 !== t.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5")), t
                    }, r._loadBitrateTestFrag = function (r) {
                      var i = this;
                      this._doFragLoad(r).then(function (t) {
                        var e = i.hls;
                        !t || e.nextLoadLevel || i._fragLoadAborted(r) || (i.fragLoadError = 0, i.state = nt, i.startFragRequested = !1, i.bitrateTest = !1, r.bitrateTest = !1, (t = r.stats).parsing.start = t.parsing.end = t.buffering.start = t.buffering.end = self.performance.now(), e.trigger(p.a.FRAG_BUFFERED, {
                          stats: t,
                          frag: r,
                          id: "main"
                        }), i.tick())
                      })
                    }, r._handleTransmuxComplete = function (t) {
                      var e, r = "main",
                        i = this.hls,
                        n = t.remuxResult,
                        a = t.chunkMeta,
                        s = this.getCurrentContext(a);
                      if (s) {
                        var o, l, u = s.frag,
                          h = s.level,
                          d = n.video,
                          c = n.text,
                          t = n.id3,
                          s = n.initSegment,
                          n = this.altAudio ? void 0 : n.audio;
                        if (this.state = lt, s && (s.tracks && (this._bufferInitSegment(h, s.tracks, u, a), i.trigger(p.a.FRAG_PARSING_INIT_SEGMENT, {
                            frag: u,
                            id: r,
                            tracks: s.tracks
                          })), o = s.initPTS, l = s.timescale, Object(B.a)(o) && (this.initPTS[u.cc] = o, i.trigger(p.a.INIT_PTS_FOUND, {
                            frag: u,
                            id: r,
                            initPTS: o,
                            timescale: l
                          }))), d) {
                          if (h.details && (o = u, l = d.dropped, h = h.details.startSN, l ? (o.dropped = l, o.backtracked ? (H.b.warn("[stream-controller]: Fragment " + o.sn + " of level " + o.level + " already backtracked and will be appended with a gap"), o.backtracked = !1) : o.sn === h ? (H.b.warn("[stream-controller]: Fragment " + o.sn + " of level " + o.level + " is missing " + o.dropped + " video frame(s); this is the start fragment and will be appended with a gap"), 0) : (H.b.warn("[stream-controller]: Fragment " + o.sn + " of level " + o.level + " is missing " + o.dropped + " video frame(s); backtracking to find a keyframe"), 1)) : o.backtracked = !1)) return this.resetTransmuxer(), void this.backtrack(u, d.startPTS);
                          u.setElementaryStreamInfo(d.type, d.startPTS, d.endPTS, d.startDTS, d.endDTS), this.bufferFragmentData(d, u, a)
                        }
                        n && (u.setElementaryStreamInfo(G.a.AUDIO, n.startPTS, n.endPTS, n.startDTS, n.endDTS), this.bufferFragmentData(n, u, a)), null != t && null !== (e = t.samples) && void 0 !== e && e.length && (t = {
                          frag: u,
                          id: r,
                          samples: t.samples
                        }, i.trigger(p.a.FRAG_PARSING_METADATA, t)), c && (c = {
                          frag: u,
                          id: r,
                          samples: c.samples
                        }, i.trigger(p.a.FRAG_PARSING_USERDATA, c))
                      } else this.warn("The loading context changed while buffering fragment " + a.sn + " of level " + a.level + ". This chunk will not be buffered.")
                    }, r._bufferInitSegment = function (t, i, n, a) {
                      var e, r, s, o, l = this;
                      this.state === lt && (this.audioOnly = !!i.audio && !i.video, this.altAudio && !this.audioOnly && delete i.audio, e = i.audio, r = i.video, e && (s = t.audioCodec, o = navigator.userAgent.toLowerCase(), s && this.audioCodecSwap && (this.log("Swapping playlist audio codec"), s = -1 !== s.indexOf("mp4a.40.5") ? "mp4a.40.2" : "mp4a.40.5"), this.audioCodecSwitch && 1 !== e.metadata.channelCount && -1 === o.indexOf("firefox") && (s = "mp4a.40.5"), -1 !== o.indexOf("android") && "audio/mpeg" !== e.container && this.log("Android: force audio codec to " + (s = "mp4a.40.2")), e.levelCodec = s, e.id = "main"), r && (r.levelCodec = t.videoCodec, r.id = "main"), this.hls.trigger(p.a.BUFFER_CODECS, i), Object.keys(i).forEach(function (t) {
                        var e = i[t],
                          r = e.initSegment;
                        l.log("Main track:" + t + ",container:" + e.container + ",codecs[level/parsed]=[" + e.levelCodec + "/" + e.codec + "]"), r && l.hls.trigger(p.a.BUFFER_APPENDING, {
                          type: t,
                          data: r,
                          frag: n,
                          chunkMeta: a
                        })
                      }), this.tick())
                    }, r.backtrack = function (t, e) {
                      this.fragmentTracker.removeFragment(t), t.backtracked = !0, this.nextLoadPosition = e, this.state = nt, this.fragPrevious = t, this.tick()
                    }, r.checkFragmentChanged = function () {
                      var t, e, r = this.media;
                      r && 1 < r.readyState && !1 === r.seeking && (t = r.currentTime, P.isBuffered(r, t) ? e = this.getAppendedFrag(t) : P.isBuffered(r, t + .1) && (e = this.getAppendedFrag(t + .1)), e && (t = e, this.fragPlaying && (t.sn === this.fragPlaying.sn || t.level === this.fragPlaying.level) || (this.hls.trigger(p.a.FRAG_CHANGED, {
                        frag: t
                      }), e = t.level, this.fragPlaying && this.fragPlaying.level === e || this.hls.trigger(p.a.LEVEL_SWITCHED, {
                        level: e
                      }), this.fragPlaying = t)))
                    },
                    function (t, e) {
                      for (var r = 0; r < e.length; r++) {
                        var i = e[r];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                      }
                    }(e.prototype, [{
                      key: "nextLevel",
                      get: function () {
                        var t = this.nextBufferedFrag;
                        return t ? t.level : -1
                      }
                    }, {
                      key: "currentLevel",
                      get: function () {
                        var t = this.media;
                        if (t) {
                          t = this.getAppendedFrag(t.currentTime);
                          if (t) return t.level
                        }
                        return -1
                      }
                    }, {
                      key: "nextBufferedFrag",
                      get: function () {
                        var t = this.media;
                        if (t) {
                          t = this.getAppendedFrag(t.currentTime);
                          return this.followingBufferedFrag(t)
                        }
                        return null
                      }
                    }, {
                      key: "forceStartLoad",
                      get: function () {
                        return this._forceStartLoad
                      }
                    }]), e
                }(dt);
                (Qt = Ot = Ot || {}).No = "", Qt.Yes = "YES", Qt.v2 = "v2";
                var It = (jt.prototype.addDirectives = function (t) {
                    var e = new self.URL(t),
                      t = e.searchParams;
                    return t.set("_HLS_msn", this.msn.toString()), void 0 !== this.part && t.set("_HLS_part", this.part.toString()), this.skip && t.set("_HLS_skip", this.skip), t.sort(), e.search = t.toString(), e.toString()
                  }, jt),
                  Mt = (function (t, e) {
                    for (var r = 0; r < e.length; r++) {
                      var i = e[r];
                      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                  }(Gt.prototype, [{
                    key: "maxBitrate",
                    get: function () {
                      return Math.max(this.realBitrate, this.bitrate)
                    }
                  }, {
                    key: "uri",
                    get: function () {
                      return this.url[this.urlId] || ""
                    }
                  }]), Gt),
                  Nt = ((pe = Ht.prototype).destroy = function () {
                    this.clearTimer()
                  }, pe.clearTimer = function () {
                    clearTimeout(this.timer), this.timer = -1
                  }, pe.startLoad = function () {
                    this.canLoad = !0, this.retryCount = 0, this.loadPlaylist()
                  }, pe.stopLoad = function () {
                    this.canLoad = !1, this.clearTimer()
                  }, pe.switchParams = function (t, e) {
                    var r = null == e ? void 0 : e.renditionReports;
                    if (r)
                      for (var i = 0; i < r.length; i++) {
                        var n = r[i],
                          a = "" + n.URI;
                        if (a === t.substr(-a.length)) {
                          var s = parseInt(n["LAST-MSN"]),
                            a = parseInt(n["LAST-PART"]);
                          if (e && this.hls.config.lowLatencyMode && (n = Math.min(e.age - e.partTarget, e.targetduration), void 0 !== a && n > e.partTarget && (a += 1)), Object(B.a)(s)) return new It(s, Object(B.a)(a) ? a : void 0, Ot.No)
                        }
                      }
                  }, pe.loadPlaylist = function (t) {}, pe.shouldLoadTrack = function (t) {
                    return this.canLoad && t && !!t.url && (!t.details || t.details.live)
                  }, pe.playlistLoaded = function (t, e, r) {
                    var i = this,
                      n = e.details,
                      a = e.stats;
                    if (n.live) {
                      if (n.reloaded(r), r && H.b.log("[" + this.constructor.name + "] live playlist " + t + " " + (n.advanced ? "REFRESHED " + n.lastPartSn + "-" + n.lastPartIndex : "MISSED")), r && 0 < n.fragments.length && U(r, n), this.canLoad) {
                        if (n.canBlockReload && n.endSN && n.advanced) {
                          var s, o, l = this.hls.config.lowLatencyMode,
                            u = n.lastPartIndex,
                            h = l ? (s = -1 !== u ? n.lastPartSn : n.endSN + 1, -1 !== u ? u + 1 : void 0) : (s = -1 !== u ? n.lastPartSn + 1 : n.endSN + 1, -1 !== u ? 0 : void 0),
                            d = Math.min(n.age - n.partTarget, 1.5 * n.targetduration);
                          0 < d && (r && d > r.tuneInGoal ? (H.b.warn("[" + this.constructor.name + "] CDN Tune-in goal increased from: " + r.tuneInGoal + " to: " + d + " with playlist age: " + n.age), d = 0) : (s += o = Math.floor(d / n.targetduration), void 0 !== h && (h += Math.round(d % n.targetduration / n.partTarget)), H.b.log("[" + this.constructor.name + "] CDN Tune-in age: " + n.age + " goal: " + d + " skip sn " + o + " to part " + h)), n.tuneInGoal = d);
                          var d = (l = n.canSkipUntil, u = n.canSkipDateRanges, o = n.endSN, l && s - o < l ? u ? Ot.v2 : Ot.Yes : Ot.No);
                          return null !== (o = e.deliveryDirectives) && void 0 !== o && o.skip && n.deltaUpdateFailed && (s = e.deliveryDirectives.msn, h = e.deliveryDirectives.part, d = Ot.No), void this.loadPlaylist(new It(s, h, d))
                        }
                        a = Math.min(this.hls.config.mildomLevelMaxReloadInterval, (l = a, o = 1e3 * (u = n).levelTargetDuration, e = o / 2, s = u.lastModified ? +new Date - u.lastModified : 0, h = 0 < s && s < 3 * o, d = l ? l.loading.end - l.loading.start : 0, a = o, n = u.availabilityDelay, !1 === u.updated ? h ? (l = 333 * u.misses, a = Math.max(Math.min(e, 2 * d), l), u.availabilityDelay = (u.availabilityDelay || 0) + a) : a = e : a = h ? (n = Math.min(n || o / 2, s), (u.availabilityDelay = n) + o - s) : o - d, Math.round(a)));
                        H.b.log("[" + this.constructor.name + "] reload live playlist " + t + " in " + Math.round(a) + " ms"), this.timer = self.setTimeout(function () {
                          return i.loadPlaylist()
                        }, a)
                      }
                    } else this.clearTimer()
                  }, pe.retryLoadingOrFail = function (t) {
                    var e, r = this,
                      i = this.hls.config,
                      n = this.retryCount < i.levelLoadingMaxRetry;
                    return n ? (this.retryCount++, -1 < t.details.indexOf("LoadTimeOut") && null !== (e = t.context) && void 0 !== e && e.deliveryDirectives ? (H.b.warn("[" + this.constructor.name + "]: retry playlist loading #" + this.retryCount + ' after "' + t.details + '"'), this.loadPlaylist()) : (i = Math.min(Math.pow(2, this.retryCount) * i.levelLoadingRetryDelay, i.levelLoadingMaxRetryTimeout), this.timer = self.setTimeout(function () {
                      return r.loadPlaylist()
                    }, i), H.b.warn("[" + this.constructor.name + "]: retry playlist loading #" + this.retryCount + " in " + i + ' ms after "' + t.details + '"'))) : (H.b.error(this.constructor.name + ']: cannot recover from error "' + t.details + '"'), this.clearTimer(), t.fatal = !0), n
                  }, Ht),
                  Ut = ((se = Bt.prototype)._registerListeners = function () {
                    var t = this.hls;
                    t.on(p.a.FRAG_PARSED, this.onFragParsed, this), t.on(p.a.FRAG_CHANGED, this.onFragChanged, this)
                  }, se._unregisterListeners = function () {
                    var t = this.hls;
                    t.off(p.a.FRAG_PARSED, this.onFragParsed, this), t.off(p.a.FRAG_CHANGED, this.onFragChanged, this)
                  }, se.handleRealtimePlaybackModeloadPlaylist = function (t) {
                    var e, r, i = this;
                    this.hls.config.mildomRealtimePlaybackMode && this.hls.levels && (e = 10 <= (e = null != (e = this.hls.levels[this.hls.levels.length - 1]) && e.details ? e.details.fragments : []).length ? e[e.length - 10] : null, r = this, e ? t.sn >= e.sn ? (H.b.debug("start load live playback m3u8"), this.loadPlaylistIntervalTimer || (this.loadPlaylistIntervalTimer = self.setInterval(function () {
                      return i.realtimePlaybackModeloadPlaylist(r)
                    }, 3e3))) : (clearInterval(this.loadPlaylistIntervalTimer), this.loadPlaylistIntervalTimer = void 0) : (clearInterval(this.loadPlaylistIntervalTimer), this.loadPlaylistIntervalTimer = self.setInterval(function () {
                      return i.realtimePlaybackModeloadPlaylist(r)
                    }, 3e3)))
                  }, se.realtimePlaybackModeloadPlaylist = function (t) {
                    var e;
                    t.levels && t.levels[t.level] && t.levels[t.level].details && null !== (e = t.levels[t.level].details) && void 0 !== e && e.isMildomLiveEnd && (clearInterval(t.loadPlaylistIntervalTimer), t.loadPlaylistIntervalTimer = void 0), t.loadPlaylist()
                  }, se.onFragParsed = function (t, e) {
                    e = e.frag;
                    this.handleRealtimePlaybackModeloadPlaylist(e)
                  }, se.onFragChanged = function (t, e) {
                    e = e.frag;
                    this.handleRealtimePlaybackModeloadPlaylist(e)
                  }, se.switchToRealtimePlaybackLoadMode = function (t) {
                    this.hls.config.mildomRealtimePlaybackMode && (t.live = !1)
                  }, se.run = function () {
                    this._registerListeners()
                  }, se.destroy = function () {
                    this._unregisterListeners()
                  }, Bt);

                function Bt(t, e) {
                  this.loadPlaylistIntervalTimer = void 0, this.hls = void 0, this.loadPlaylist = void 0, this.hls = t, this.loadPlaylist = e
                }

                function Ht(t) {
                  this.hls = void 0, this.timer = -1, this.canLoad = !1, this.retryCount = 0, this.hls = t
                }

                function Gt(t) {
                  this.attrs = void 0, this.audioCodec = void 0, this.audioGroupIds = void 0, this.bitrate = void 0, this.details = void 0, this.fragmentError = !1, this.height = void 0, this.id = void 0, this.loadError = 0, this.loaded = void 0, this.name = void 0, this.realBitrate = 0, this.textGroupIds = void 0, this.url = void 0, this.urlId = 0, this.videoCodec = void 0, this.width = void 0, this.unknownCodecs = void 0, this.url = [t.url], this.attrs = t.attrs, this.bitrate = t.bitrate, this.details = t.details, this.id = t.id || 0, this.name = t.name, this.width = t.width || 0, this.height = t.height || 0, this.audioCodec = t.audioCodec, this.videoCodec = t.videoCodec, this.unknownCodecs = t.unknownCodecs
                }

                function jt(t, e, r) {
                  this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = t, this.part = e, this.skip = r
                }

                function Vt() {
                  return (Vt = Object.assign || function (t) {
                    for (var e = 1; e < arguments.length; e++) {
                      var r, i = arguments[e];
                      for (r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
                    }
                    return t
                  }).apply(this, arguments)
                }
                var zt = /chrome|firefox/.test(navigator.userAgent.toLowerCase()),
                  qt = function (r) {
                    var t;

                    function e(t) {
                      var e;
                      return (e = r.call(this, t) || this)._levels = [], e._firstLevel = -1, e._startLevel = void 0, e.currentLevelIndex = -1, e.manualLevelIndex = -1, e.mildomLevelController = void 0, e.onParsedComplete = void 0, e._registerListeners(), t && (e.mildomLevelController = new Ut(t, e.loadPlaylist.bind(function (t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                      }(e))), e.mildomLevelController.run()), e
                    }
                    i = r, (t = e).prototype = Object.create(i.prototype), (t.prototype.constructor = t).__proto__ = i;
                    var i = e.prototype;
                    return i._registerListeners = function () {
                        var t = this.hls;
                        t.on(p.a.MANIFEST_LOADED, this.onManifestLoaded, this), t.on(p.a.LEVEL_LOADED, this.onLevelLoaded, this), t.on(p.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.on(p.a.FRAG_LOADED, this.onFragLoaded, this), t.on(p.a.ERROR, this.onError, this)
                      }, i._unregisterListeners = function () {
                        var t = this.hls;
                        t.off(p.a.MANIFEST_LOADED, this.onManifestLoaded, this), t.off(p.a.LEVEL_LOADED, this.onLevelLoaded, this), t.off(p.a.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), t.off(p.a.FRAG_LOADED, this.onFragLoaded, this), t.off(p.a.ERROR, this.onError, this)
                      }, i.destroy = function () {
                        r.prototype.destroy.call(this), this._unregisterListeners(), this.manualLevelIndex = -1, this.mildomLevelController && this.mildomLevelController.destroy()
                      }, i.startLoad = function () {
                        this._levels.forEach(function (t) {
                          t.loadError = 0
                        }), r.prototype.startLoad.call(this)
                      }, i.onManifestLoaded = function (t, e) {
                        var r, i, n = [],
                          a = [],
                          s = [],
                          o = {},
                          l = !1,
                          u = !1;
                        if (e.levels.forEach(function (t) {
                            var e = t.attrs;
                            l = l || !!t.videoCodec, u = u || !!t.audioCodec, zt && t.audioCodec && -1 !== t.audioCodec.indexOf("mp4a.40.34") && (t.audioCodec = void 0), (i = o[t.bitrate]) ? i.url.push(t.url) : (i = new Mt(t), o[t.bitrate] = i, n.push(i)), e && (e.AUDIO && I(i, "audio", e.AUDIO), e.SUBTITLES && I(i, "text", e.SUBTITLES))
                          }), n = (n = l && u ? n.filter(function (t) {
                            return !!t.videoCodec
                          }) : n).filter(function (t) {
                            var e = t.audioCodec,
                              t = t.videoCodec;
                            return (!e || d(e, "audio")) && (!t || d(t, "video"))
                          }), this.hls.config.mildomFilterLevels && (n = this.hls.config.mildomFilterLevels(n)), e.audioTracks && (a = e.audioTracks.filter(function (t) {
                            return !t.audioCodec || d(t.audioCodec, "audio")
                          })).forEach(function (t, e) {
                            t.id = e
                          }), e.subtitles && (s = e.subtitles.map(function (t, e) {
                            return Vt({
                              id: e
                            }, t)
                          })), 0 < n.length) {
                          r = n[0].bitrate, n.sort(function (t, e) {
                            return t.bitrate - e.bitrate
                          }), this._levels = n;
                          for (var h = 0; h < n.length; h++)
                            if (n[h].bitrate === r) {
                              this._firstLevel = h, H.b.log("[level-controller]: manifest loaded, " + n.length + " level(s) found, first bitrate: " + r);
                              break
                            }
                          a = {
                            levels: n,
                            audioTracks: a,
                            subtitleTracks: s,
                            firstLevel: this._firstLevel,
                            stats: e.stats,
                            audio: u,
                            video: l,
                            altAudio: !(u && !l) && a.some(function (t) {
                              return !!t.url
                            })
                          };
                          this.hls.trigger(p.a.MANIFEST_PARSED, a), this.onParsedComplete()
                        } else this.hls.trigger(p.a.ERROR, {
                          type: g.b.MEDIA_ERROR,
                          details: g.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                          fatal: !0,
                          url: e.url,
                          reason: "no level with compatible codecs found in manifest"
                        })
                      }, i.onError = function (t, e) {
                        if (e.fatal) e.type === g.b.NETWORK_ERROR && this.clearTimer();
                        else {
                          var r, i = !1,
                            n = !1,
                            a = !0;
                          switch (e.details) {
                          case g.a.FRAG_LOAD_ERROR:
                          case g.a.FRAG_LOAD_TIMEOUT:
                          case g.a.KEY_LOAD_ERROR:
                          case g.a.KEY_LOAD_TIMEOUT:
                            r = e.frag.level, n = !0;
                            break;
                          case g.a.LEVEL_LOAD_ERROR:
                          case g.a.LEVEL_LOAD_TIMEOUT:
                            e.context && (e.context.deliveryDirectives && (a = !1), r = e.context.level), i = !0;
                            break;
                          case g.a.REMUX_ALLOC_ERROR:
                            r = e.level, i = !0
                          }
                          void 0 !== r && this.recoverLevel(e, r, i, n, a)
                        }
                      }, i.recoverLevel = function (t, e, r, i, n) {
                        var a = t.details,
                          s = this._levels[e];
                        if (s.loadError++, s.fragmentError = i, r) {
                          if (!this.retryLoadingOrFail(t)) return void(this.currentLevelIndex = -1);
                          t.levelRetry = !0
                        }
                        n && (r || i) && (1 < (r = s.url.length) && s.loadError < r ? (s.urlId = (s.urlId + 1) % r, s.details = void 0, H.b.warn("[level-controller]: " + a + " for level " + e + ": switching to redundant URL-id " + s.urlId)) : (-1 === this.manualLevelIndex && (e = 0 === e ? this._levels.length - 1 : e - 1, this.currentLevelIndex !== e && (i = !1, H.b.warn("[level-controller]: " + a + ": switch to " + e), this.hls.nextAutoLevel = this.currentLevelIndex = e)), i && (H.b.warn("[level-controller]: " + a + ": reload a fragment"), this.currentLevelIndex = -1)))
                      }, i.onFragLoaded = function (t, e) {
                        e = e.frag;
                        void 0 === e || "main" !== e.type || void 0 !== (e = this._levels[e.level]) && (e.fragmentError = !1, e.loadError = 0)
                      }, i.onLevelLoaded = function (t, e) {
                        var r = e.level,
                          i = e.details,
                          n = this._levels[r];
                        this.mildomLevelController && this.mildomLevelController.switchToRealtimePlaybackLoadMode(i), n ? (H.b.log("[level-controller]: level " + r + " loaded [" + i.startSN + "-" + i.endSN + "]"), r === this.currentLevelIndex && (n.fragmentError || (n.loadError = 0, this.retryCount = 0), this.playlistLoaded(r, e, n.details))) : H.b.warn("[level-controller]: Invalid level index:", r)
                      }, i.onAudioTrackSwitched = function (t, e) {
                        var r = this.hls.levels[this.currentLevelIndex];
                        if (r && r.audioGroupIds) {
                          for (var i = -1, n = this.hls.audioTracks[e.id].groupId, a = 0; a < r.audioGroupIds.length; a++)
                            if (r.audioGroupIds[a] === n) {
                              i = a;
                              break
                            }
                          i !== r.urlId && (r.urlId = i, this.startLoad())
                        }
                      }, i.loadPlaylist = function (t) {
                        var e = this.currentLevelIndex,
                          r = this._levels[e];
                        if (this.canLoad && r && 0 < r.url.length) {
                          var i = r.urlId,
                            r = r.url[i];
                          if (t) try {
                            r = t.addDirectives(r)
                          } catch (t) {
                            H.b.warn("[level-controller] Could not construct new URL with HLS Delivery Directives: " + t)
                          }
                          H.b.log("[level-controller]: Attempt loading level index " + e + (t ? " at sn " + t.msn + " part " + t.part : "") + " with URL-id " + i + " " + r), this.clearTimer(), this.hls.trigger(p.a.LEVEL_LOADING, {
                            url: r,
                            level: e,
                            id: i,
                            deliveryDirectives: t || null
                          })
                        }
                      }, i.removeLevel = function (r, i) {
                        var t = this._levels.filter(function (t, e) {
                          return e !== r || 1 < t.url.length && void 0 !== i && (t.url = t.url.filter(function (t, e) {
                            return e !== i
                          }), !(t.urlId = 0))
                        }).map(function (t, e) {
                          var r = t.details;
                          return null != r && r.fragments && r.fragments.forEach(function (t) {
                            t.level = e
                          }), t
                        });
                        this._levels = t, this.hls.trigger(p.a.LEVELS_UPDATED, {
                          levels: t
                        })
                      },
                      function (t, e) {
                        for (var r = 0; r < e.length; r++) {
                          var i = e[r];
                          i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                      }(e.prototype, [{
                        key: "levels",
                        get: function () {
                          return 0 === this._levels.length ? null : this._levels
                        }
                      }, {
                        key: "level",
                        get: function () {
                          return this.currentLevelIndex
                        },
                        set: function (t) {
                          var e, r, i = this._levels;
                          this.currentLevelIndex === t && null !== (r = i[t]) && void 0 !== r && r.details || (t < 0 || t >= i.length ? this.hls.trigger(p.a.ERROR, {
                            type: g.b.OTHER_ERROR,
                            details: g.a.LEVEL_SWITCH_ERROR,
                            level: t,
                            fatal: !1,
                            reason: "invalid level idx"
                          }) : (this.clearTimer(), r = i[e = this.currentLevelIndex], i = i[t], H.b.log("[level-controller]: switching to level " + t + " from " + e), this.currentLevelIndex = t, this.hls.trigger(p.a.LEVEL_SWITCHING, Vt({}, i, {
                            level: t
                          })), (t = i.details) && !t.live || (r = this.switchParams(i.uri, null == r ? void 0 : r.details), this.loadPlaylist(r))))
                        }
                      }, {
                        key: "manualLevel",
                        get: function () {
                          return this.manualLevelIndex
                        },
                        set: function (t) {
                          this.manualLevelIndex = t, void 0 === this._startLevel && (this._startLevel = t), -1 !== t && (this.level = t)
                        }
                      }, {
                        key: "firstLevel",
                        get: function () {
                          return this._firstLevel
                        },
                        set: function (t) {
                          this._firstLevel = t
                        }
                      }, {
                        key: "startLevel",
                        get: function () {
                          if (void 0 !== this._startLevel) return this._startLevel;
                          var t = this.hls.config.startLevel;
                          return void 0 !== t ? t : this._firstLevel
                        },
                        set: function (t) {
                          this._startLevel = t
                        }
                      }, {
                        key: "nextLoadLevel",
                        get: function () {
                          return -1 !== this.manualLevelIndex ? this.manualLevelIndex : this.hls.nextAutoLevel
                        },
                        set: function (t) {
                          this.level = t, -1 === this.manualLevelIndex && (this.hls.nextAutoLevel = t)
                        }
                      }]), e
                  }(Nt),
                  Kt = ((_e = Xt.prototype).sample = function (t, e) {
                    var r = Math.pow(this.alpha_, t);
                    this.estimate_ = e * (1 - r) + r * this.estimate_, this.totalWeight_ += t
                  }, _e.getTotalWeight = function () {
                    return this.totalWeight_
                  }, _e.getEstimate = function () {
                    if (this.alpha_) {
                      var t = 1 - Math.pow(this.alpha_, this.totalWeight_);
                      if (t) return this.estimate_ / t
                    }
                    return this.estimate_
                  }, Xt),
                  Wt = ((Se = Yt.prototype).update = function (t, e) {
                    var r = this.slow_,
                      i = this.fast_;
                    this.slow_.halfLife !== t && (this.slow_ = new Kt(t, r.getEstimate(), r.getTotalWeight())), this.fast_.halfLife !== e && (this.fast_ = new Kt(e, i.getEstimate(), i.getTotalWeight()))
                  }, Se.sample = function (t, e) {
                    t = (t = Math.max(t, this.minDelayMs_)) / 1e3, e = 8 * e / t;
                    this.fast_.sample(t, e), this.slow_.sample(t, e)
                  }, Se.canEstimate = function () {
                    var t = this.fast_;
                    return t && t.getTotalWeight() >= this.minWeight_
                  }, Se.getEstimate = function () {
                    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_
                  }, Se.destroy = function () {}, Yt);

                function Yt(t, e, r) {
                  this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = .001, this.minDelayMs_ = 50, this.slow_ = new Kt(t), this.fast_ = new Kt(e)
                }

                function Xt(t, e, r) {
                  void 0 === e && (e = 0), void 0 === r && (r = 0), this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = t, this.alpha_ = t ? Math.exp(Math.log(.5) / t) : 0, this.estimate_ = e, this.totalWeight_ = r
                }
                var $t = self.performance,
                  dt = ((ne = re.prototype).registerListeners = function () {
                    var t = this.hls;
                    t.on(p.a.FRAG_LOADING, this.onFragLoading, this), t.on(p.a.FRAG_LOADED, this.onFragLoaded, this), t.on(p.a.FRAG_BUFFERED, this.onFragBuffered, this), t.on(p.a.LEVEL_LOADED, this.onLevelLoaded, this), t.on(p.a.ERROR, this.onError, this)
                  }, ne.unregisterListeners = function () {
                    var t = this.hls;
                    t.off(p.a.FRAG_LOADING, this.onFragLoading, this), t.off(p.a.FRAG_LOADED, this.onFragLoaded, this), t.off(p.a.FRAG_BUFFERED, this.onFragBuffered, this), t.off(p.a.LEVEL_LOADED, this.onLevelLoaded, this), t.off(p.a.ERROR, this.onError, this)
                  }, ne.destroy = function () {
                    this.unregisterListeners(), this.clearTimer()
                  }, ne.onFragLoading = function (t, e) {
                    e = e.frag;
                    "main" === e.type && (this.timer || (this.fragCurrent = e, this.timer = self.setInterval(this.onCheck, 100)))
                  }, ne.onLevelLoaded = function (t, e) {
                    var r = this.hls.config;
                    e.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD), 0 === this.mildomBootTime && (this.mildomBootTime = $t.now())
                  }, ne._abandonRulesCheck = function () {
                    var t = this.fragCurrent,
                      e = this.hls,
                      r = e.autoLevelEnabled,
                      i = e.config,
                      n = e.media;
                    if (t && n) {
                      var a = t.loader;
                      if (!a || a.stats.aborted) return H.b.warn("frag loader destroy or aborted, disarm abandonRules"), this.clearTimer(), void(this._nextAutoLevel = -1);
                      if (r && !n.paused && n.playbackRate && n.readyState) {
                        var s = a.stats,
                          o = $t.now() - s.loading.start,
                          l = Math.abs(n.playbackRate);
                        if (!(o <= 500 * t.duration / l)) {
                          var u = e.levels,
                            h = e.minAutoLevel,
                            d = u[t.level],
                            r = s.total || Math.max(s.loaded, Math.round(t.duration * d.maxBitrate / 8)),
                            c = Math.max(1, s.bwEstimate ? s.bwEstimate / 8 : 1e3 * s.loaded / o),
                            d = (r - s.loaded) / c,
                            r = n.currentTime,
                            f = (P.bufferInfo(n, r, i.maxBufferHole).end - r) / l;
                          if (!(f >= 2 * t.duration / l || d <= f)) {
                            for (var g = Number.POSITIVE_INFINITY, m = t.level - 1; h < m; m--) {
                              var v = u[m].maxBitrate;
                              if ((g = t.duration * v / (6.4 * c)) < f) break
                            }
                            d <= g || (l = this.bwEstimator.getEstimate(), H.b.warn("Fragment " + t.sn + " of level " + t.level + " is loading too slowly and will cause an underbuffer; aborting and switching to level " + m + "\n      Current BW estimate: " + (Object(B.a)(l) ? (l / 1024).toFixed(3) : "Unknown") + " Kb/s\n      Estimated load time for current fragment: " + d.toFixed(3) + " s\n      Estimated load time for the next fragment: " + g.toFixed(3) + " s\n      Time to underbuffer: " + f.toFixed(3) + " s"), e.nextLoadLevel = m, this.bwEstimator.sample(o, s.loaded), a.abort(), this.clearTimer(), e.trigger(p.a.FRAG_LOAD_EMERGENCY_ABORTED, {
                              frag: t,
                              stats: s
                            }))
                          }
                        }
                      }
                    }
                  }, ne.onFragLoaded = function (t, e) {
                    var r, i, n = e.frag,
                      a = n.stats;
                    "main" === n.type && Object(B.a)(n.sn) && (this.clearTimer(), this.lastLoadedFragLevel = n.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate && (i = ((r = this.hls.levels[n.level]).loaded ? r.loaded.bytes : 0) + a.loaded, a = (r.loaded ? r.loaded.duration : 0) + n.duration, r.loaded = {
                      bytes: i,
                      duration: a
                    }, r.realBitrate = Math.round(8 * i / a)), n.bitrateTest && (e = {
                      stats: e.frag.stats,
                      frag: e.frag
                    }, this.onFragBuffered(p.a.FRAG_BUFFERED, e)))
                  }, ne.onFragBuffered = function (t, e) {
                    var r = e.frag,
                      i = r.stats;
                    i.aborted || "main" !== r.type || "initSegment" === r.sn || r.bitrateTest || (e = i.parsing.end - i.loading.start, this.bwEstimator.sample(e, i.loaded), i.bwEstimate = this.bwEstimator.getEstimate(), r.bitrateTest ? this.bitrateTestDelay = e / 1e3 : this.bitrateTestDelay = 0)
                  }, ne.onError = function (t, e) {
                    switch (e.details) {
                    case g.a.FRAG_LOAD_ERROR:
                    case g.a.FRAG_LOAD_TIMEOUT:
                      this.clearTimer()
                    }
                  }, ne.clearTimer = function () {
                    self.clearInterval(this.timer), this.timer = void 0
                  }, ne._findBestLevel = function (t, e, r, i, n, a, s, o, l) {
                    for (var u = n; i <= u; u--) {
                      var h = l[u];
                      if (h) {
                        var d = h.details,
                          c = (null == d ? void 0 : d.averagetargetduration) || e,
                          f = !!d && d.live,
                          g = void 0,
                          h = l[u].maxBitrate,
                          d = h * c / (g = u <= t ? s * r : o * r);
                        if (H.b.trace("level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: " + u + "/" + Math.round(g) + "/" + h + "/" + c + "/" + a + "/" + d), h < g && (!d || f && !this.bitrateTestDelay || d < a)) return u
                      }
                    }
                    return -1
                  }, function (t, e) {
                    for (var r = 0; r < e.length; r++) {
                      var i = e[r];
                      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                    }
                  }(re.prototype, [{
                    key: "nextAutoLevel",
                    get: function () {
                      var t = this._nextAutoLevel,
                        e = this.bwEstimator;
                      if (!(-1 === t || e && e.canEstimate())) return t;
                      e = this._nextABRAutoLevel;
                      return -1 !== t && (e = Math.min(t, e)), e = 0 !== this.mildomBootTime && $t.now() - this.mildomBootTime <= 1e4 ? Math.min(this.lastLoadedFragLevel, e) : e
                    },
                    set: function (t) {
                      this._nextAutoLevel = t
                    }
                  }, {
                    key: "_nextABRAutoLevel",
                    get: function () {
                      var t = this.fragCurrent,
                        e = this.hls,
                        r = this.lastLoadedFragLevel,
                        i = e.maxAutoLevel,
                        n = e.levels,
                        a = e.config,
                        s = e.minAutoLevel,
                        o = e.media,
                        l = t ? t.duration : 0,
                        u = o ? o.currentTime : 0,
                        h = o && 0 !== o.playbackRate ? Math.abs(o.playbackRate) : 1,
                        d = this.bwEstimator ? this.bwEstimator.getEstimate() : a.abrEwmaDefaultEstimate,
                        c = (P.bufferInfo(o, u, a.maxBufferHole).end - u) / h,
                        e = this._findBestLevel(r, l, d, s, i, c, a.abrBandWidthFactor, a.abrBandWidthUpFactor, n);
                      if (0 <= e) return e;
                      H.b.trace("rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering");
                      t = l ? Math.min(l, a.maxStarvationDelay) : a.maxStarvationDelay, o = a.abrBandWidthFactor, u = a.abrBandWidthUpFactor;
                      return c || (h = this.bitrateTestDelay) && (t = (l ? Math.min(l, a.maxLoadingDelay) : a.maxLoadingDelay) - h, H.b.trace("bitrate test took " + Math.round(1e3 * h) + "ms, set first fragment max fetchDuration to " + Math.round(1e3 * t) + " ms"), o = u = 1), e = this._findBestLevel(r, l, d, s, i, c + t, o, u, n), Math.max(e, 0)
                    }
                  }]), re),
                  Qt = r(10),
                  Jt = ((pe = ee.prototype).append = function (t, e) {
                    var r = this.queues[e];
                    r.push(t), 1 === r.length && this.buffers[e] && this.executeNext(e)
                  }, pe.insertAbort = function (t, e) {
                    this.queues[e].unshift(t), this.executeNext(e, !0)
                  }, pe.appendBlocker = function (t) {
                    var e, r = new Promise(function (t) {
                      e = t
                    });
                    return this.append({
                      execute: e,
                      onStart: function () {},
                      onComplete: function () {},
                      onError: function () {}
                    }, t), r
                  }, pe.executeNext = function (t, e) {
                    var r = this.buffers,
                      i = this.queues,
                      n = r[t],
                      r = i[t];
                    if (r.length) {
                      i = r[0];
                      try {
                        i.execute()
                      } catch (t) {
                        H.b.warn("[buffer-operation-queue]: Unhandled exception executing the current operation"), i.onError(t), n && n.updating || r.shift()
                      }
                    }
                  }, pe.shiftAndExecuteNext = function (t) {
                    this.queues[t].shift(), this.executeNext(t)
                  }, pe.current = function (t) {
                    return this.queues[t][0]
                  }, ee),
                  Zt = gt(),
                  Nt = ((se = te.prototype).destroy = function () {
                    this.unregisterListeners()
                  }, se.registerListeners = function () {
                    var t = this.hls;
                    t.on(p.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(p.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(p.a.MANIFEST_PARSED, this.onManifestParsed, this), t.on(p.a.BUFFER_RESET, this.onBufferReset, this), t.on(p.a.BUFFER_APPENDING, this.onBufferAppending, this), t.on(p.a.BUFFER_CODECS, this.onBufferCodecs, this), t.on(p.a.BUFFER_EOS, this.onBufferEos, this), t.on(p.a.BUFFER_FLUSHING, this.onBufferFlushing, this), t.on(p.a.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this), t.on(p.a.LEVEL_UPDATED, this.onLevelUpdated, this), t.on(p.a.FRAG_PARSED, this.onFragParsed, this)
                  }, se.unregisterListeners = function () {
                    var t = this.hls;
                    t.off(p.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(p.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(p.a.MANIFEST_PARSED, this.onManifestParsed, this), t.off(p.a.BUFFER_RESET, this.onBufferReset, this), t.off(p.a.BUFFER_APPENDING, this.onBufferAppending, this), t.off(p.a.BUFFER_CODECS, this.onBufferCodecs, this), t.off(p.a.BUFFER_EOS, this.onBufferEos, this), t.off(p.a.BUFFER_FLUSHING, this.onBufferFlushing, this), t.off(p.a.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this), t.off(p.a.LEVEL_UPDATED, this.onLevelUpdated, this), t.off(p.a.FRAG_PARSED, this.onFragParsed, this)
                  }, se._initSourceBuffer = function () {
                    this.sourceBuffer = {}, this.operationQueue = new Jt(this.sourceBuffer), this.listeners = {
                      audio: [],
                      video: [],
                      audiovideo: []
                    }
                  }, se.onManifestParsed = function (t, e) {
                    var r = 2;
                    (!e.audio || e.video) && e.altAudio || (r = 1), this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = r, H.b.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected")
                  }, se.onMediaAttaching = function (t, e) {
                    var r = this.media = e.media;
                    r && Zt && ((e = this.mediaSource = new Zt).addEventListener("sourceopen", this._onMediaSourceOpen), e.addEventListener("sourceended", this._onMediaSourceEnded), e.addEventListener("sourceclose", this._onMediaSourceClose), r.src = self.URL.createObjectURL(e), this._objectUrl = r.src)
                  }, se.onMediaDetaching = function () {
                    H.b.log("media source detaching");
                    var t = this.media,
                      e = this.mediaSource,
                      r = this._objectUrl;
                    if (e) {
                      if ("open" === e.readyState) try {
                        e.endOfStream()
                      } catch (t) {
                        H.b.warn("onMediaDetaching:" + t.message + " while calling endOfStream")
                      }
                      this.onBufferReset(), e.removeEventListener("sourceopen", this._onMediaSourceOpen), e.removeEventListener("sourceended", this._onMediaSourceEnded), e.removeEventListener("sourceclose", this._onMediaSourceClose), t && (r && self.URL.revokeObjectURL(r), t.src === r ? (t.removeAttribute("src"), t.load()) : H.b.warn("media.src was changed by a third party - skip cleanup")), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}
                    }
                    this.hls.trigger(p.a.MEDIA_DETACHED, void 0)
                  }, se.onBufferReset = function () {
                    var r = this,
                      i = this.sourceBuffer;
                    this.getSourceBufferTypes().forEach(function (t) {
                      var e = i[t];
                      try {
                        e && (r.removeBufferListeners(t), r.mediaSource && r.mediaSource.removeSourceBuffer(e), i[t] = void 0)
                      } catch (e) {
                        H.b.warn("Failed to reset the " + t + " buffer", e)
                      }
                    }), this._initSourceBuffer()
                  }, se.onBufferCodecs = function (t, e) {
                    var r = this;
                    Object.keys(this.sourceBuffer).length || (Object.keys(e).forEach(function (t) {
                      r.pendingTracks[t] = e[t]
                    }), this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && "open" === this.mediaSource.readyState && this.checkPendingTracks())
                  }, se.onBufferAppending = function (t, e) {
                    var n = this,
                      r = this.hls,
                      i = this.operationQueue,
                      a = e.data,
                      s = e.type,
                      o = e.frag,
                      l = e.chunkMeta,
                      u = l.buffering[s],
                      h = o.stats.buffering,
                      e = performance.now();
                    u.start = e, h.start || (h.start = e), i.append({
                      execute: function () {
                        u.executeStart = performance.now(), n.appendExecutor(a, s)
                      },
                      onStart: function () {
                        H.b.debug("[buffer-controller]: " + s + " SourceBuffer updatestart")
                      },
                      onComplete: function () {
                        H.b.debug("[buffer-controller]: " + s + " SourceBuffer updateend");
                        var t = performance.now();
                        u.executeEnd = u.end = t, h.first || (h.first = t);
                        var e, r = n.sourceBuffer,
                          i = {};
                        for (e in r) i[e] = P.getBuffered(r[e]);
                        n.appendError = 0, n.hls.trigger(p.a.BUFFER_APPENDED, {
                          parent: o.type,
                          timeRanges: i,
                          frag: o,
                          chunkMeta: l
                        })
                      },
                      onError: function (t) {
                        H.b.error("[buffer-controller]: Error encountered while trying to append to the " + s + " SourceBuffer", t);
                        var e = {
                          type: g.b.MEDIA_ERROR,
                          parent: o.type,
                          details: g.a.BUFFER_APPEND_ERROR,
                          err: t,
                          fatal: !1
                        };
                        t.code === DOMException.QUOTA_EXCEEDED_ERR ? e.details = g.a.BUFFER_FULL_ERROR : (n.appendError++, e.details = g.a.BUFFER_APPEND_ERROR, n.appendError > r.config.appendErrorMaxRetry && (H.b.log("[buffer-controller]: Failed " + r.config.appendErrorMaxRetry + " times to append segment in sourceBuffer"), e.fatal = !0)), r.trigger(p.a.ERROR, e)
                      }
                    }, s)
                  }, se.onBufferFlushing = function (t, r) {
                    function e(e) {
                      return {
                        execute: i.removeExecutor.bind(i, e, r.startOffset, r.endOffset),
                        onStart: function () {
                          H.b.debug("[buffer-controller]: Started flushing " + r.startOffset + " -> " + r.endOffset + " for " + e + " Source Buffer")
                        },
                        onComplete: function () {
                          H.b.debug("[buffer-controller]: Finished flushing " + r.startOffset + " -> " + r.endOffset + " for " + e + " Source Buffer"), i.hls.trigger(p.a.BUFFER_FLUSHED, {
                            type: e
                          })
                        },
                        onError: function (t) {
                          H.b.warn("[buffer-controller]: Failed to remove from " + e + " SourceBuffer", t)
                        }
                      }
                    }
                    var i = this,
                      n = this.operationQueue;
                    r.type ? n.append(e(r.type), r.type) : (n.append(e("audio"), "audio"), n.append(e("video"), "video"))
                  }, se.onFragParsed = function (t, e) {
                    var r = this,
                      i = e.frag,
                      n = [];
                    i.elementaryStreams[G.a.AUDIOVIDEO] ? n.push("audiovideo") : (i.elementaryStreams[G.a.AUDIO] && n.push("audio"), i.elementaryStreams[G.a.VIDEO] && n.push("video"));
                    e = function () {
                      i.stats.buffering.end = self.performance.now(), r.hls.trigger(p.a.FRAG_BUFFERED, {
                        frag: i,
                        stats: i.stats,
                        id: i.type
                      })
                    };
                    if (0 === n.length) return H.b.warn("Fragments must have at least one ElementaryStreamType set. type: " + i.type + " level: " + i.level + " sn: " + i.sn), void e();
                    this.blockBuffers(e, n), this.flushLiveBackBuffer()
                  }, se.onBufferEos = function (t, e) {
                    var r, i, n = this;
                    for (r in this.sourceBuffer) e.type && e.type !== r || (i = this.sourceBuffer[r]) && !i.ended && (i.ended = !0, H.b.log("[buffer-controller]: " + r + " sourceBuffer now EOS"));
                    H.b.log("[buffer-controller: End of stream signalled, enqueuing end of stream operation"), this.blockBuffers(function () {
                      var t = n.mediaSource;
                      t && "open" === t.readyState && (H.b.log("[buffer-controller]: Signaling end of stream"), t.endOfStream())
                    })
                  }, se.onLevelUpdated = function (t, e) {
                    var r = e.details;
                    r.fragments.length && (this._levelTargetDuration = r.levelTargetDuration, this._live = r.live, e = r.fragments[0].start + r.totalduration, H.b.log("[buffer-controller]: Duration update required; enqueueing duration change operation"), this.getSourceBufferTypes().length ? this.blockBuffers(this.updateMediaElementDuration.bind(this, e)) : (this.updateMediaElementDuration(e), this.hls.config.liveDurationInfinity && this.updateSeekableRange(r)))
                  }, se.onLevelPtsUpdated = function (t, e) {
                    var r, i = this.operationQueue,
                      n = this.sourceBuffer,
                      a = this.tracks,
                      s = e.type,
                      a = a.audio;
                    "audio" !== s || a && "audio/mpeg" !== a.container || (r = n[s]) && (Math.abs(r.timestampOffset - e.start) < .1 || (n = {
                      execute: this.abortExecutor.bind(this, s),
                      onStart: function () {
                        H.b.debug("[buffer-controller]: Starting abort on source buffer " + s)
                      },
                      onComplete: function () {
                        r && (H.b.log("[buffer-controller]: Updating audio SourceBuffer timestampOffset to " + e.start), r.timestampOffset = e.start)
                      },
                      onError: function (t) {
                        H.b.warn("[buffer-controller]: Failed to abort the audio SourceBuffer", t)
                      }
                    }, i.insertAbort(n, s), this.hls.config.liveDurationInfinity && this.updateSeekableRange(e.details)))
                  }, se.flushLiveBackBuffer = function () {
                    var r, i = this.hls,
                      t = this._levelTargetDuration,
                      e = this._live,
                      n = this.media,
                      a = this.sourceBuffer;
                    n && e && null !== t && (e = i.config.liveBackBufferLength, !Object(B.a)(e) || e < 0 || (r = n.currentTime - Math.max(e, t), this.getSourceBufferTypes().forEach(function (t) {
                      var e = a[t];
                      !e || 0 < (e = P.getBuffered(e)).length && r > e.start(0) && (i.trigger(p.a.LIVE_BACK_BUFFER_REACHED, {
                        bufferEnd: r
                      }), i.trigger(p.a.BUFFER_FLUSHING, {
                        startOffset: 0,
                        endOffset: r,
                        type: t
                      }))
                    })))
                  }, se.updateMediaElementDuration = function (t) {
                    var e, r, i, n, a, s;
                    this.media && this.mediaSource && "open" === this.mediaSource.readyState && (e = this.hls, r = this._live, s = this.media, i = this.mediaSource, n = this._msDuration, a = s.duration, s = n, null === n && (this._msDuration = s = i.duration), r && e.config.liveDurationInfinity ? (H.b.log("[buffer-controller]: Media Source duration is set to Infinity"), this._msDuration = i.duration = 1 / 0) : (s < t && a < t || !Object(B.a)(a)) && (H.b.log("[buffer-controller]: Updating Media Source duration to " + t.toFixed(3)), this._msDuration = i.duration = t))
                  }, se.updateSeekableRange = function (t) {
                    var e = this.mediaSource,
                      r = t.fragments;
                    r.length && null != e && e.setLiveSeekableRange && (t = (r = r[0].start) + t.totalduration, e.setLiveSeekableRange(r, t))
                  }, se.checkPendingTracks = function () {
                    var t = this.bufferCodecEventsExpected,
                      e = this.operationQueue,
                      r = this.pendingTracks,
                      i = Object.keys(r).length;
                    (i && !t || 2 === i) && (this.createSourceBuffers(r), this.pendingTracks = {}, Object.keys(this.sourceBuffer).forEach(function (t) {
                      e.executeNext(t)
                    }))
                  }, se.createSourceBuffers = function (t) {
                    var e, r = this.sourceBuffer,
                      i = this.mediaSource;
                    if (!i) throw Error("createSourceBuffers called when mediaSource was null");
                    for (e in t)
                      if (!r[e]) {
                        var n = t[e];
                        if (!n) throw Error("source buffer exists for track " + e + ", however track does not");
                        var a = n.levelCodec || n.codec,
                          s = n.container + ";codecs=" + a;
                        H.b.log("creating sourceBuffer(" + s + ")");
                        try {
                          var o = r[e] = i.addSourceBuffer(s),
                            l = e;
                          this.addBufferListener(l, "updatestart", this._onSBUpdateStart), this.addBufferListener(l, "updateend", this._onSBUpdateEnd), this.addBufferListener(l, "error", this._onSBUpdateError), this.tracks[e] = {
                            buffer: o,
                            codec: a,
                            container: n.container,
                            levelCodec: n.levelCodec,
                            id: n.id
                          }
                        } catch (t) {
                          H.b.error("error while trying to add sourceBuffer:" + t.message), this.hls.trigger(p.a.ERROR, {
                            type: g.b.MEDIA_ERROR,
                            details: g.a.BUFFER_ADD_CODEC_ERROR,
                            fatal: !1,
                            error: t,
                            mimeType: s
                          })
                        }
                      }
                    this.hls.trigger(p.a.BUFFER_CREATED, {
                      tracks: this.tracks
                    })
                  }, se._onSBUpdateStart = function (t) {
                    this.operationQueue.current(t).onStart()
                  }, se._onSBUpdateEnd = function (t) {
                    var e = this.operationQueue;
                    e.current(t).onComplete(), e.shiftAndExecuteNext(t)
                  }, se._onSBUpdateError = function (t, e) {
                    H.b.error("[buffer-controller]: " + t + " SourceBuffer error", e), this.hls.trigger(p.a.ERROR, {
                      type: g.b.MEDIA_ERROR,
                      details: g.a.BUFFER_APPENDING_ERROR,
                      fatal: !1
                    });
                    t = this.operationQueue.current(t);
                    t && t.onError(e)
                  }, se.removeExecutor = function (t, e, r) {
                    var i = this.media,
                      n = this.operationQueue,
                      a = this.sourceBuffer[t];
                    if (!i || !a) return H.b.warn("[buffer-controller]: Attempting to remove from the " + t + " SourceBuffer, but it does not exist"), void n.shiftAndExecuteNext(t);
                    e = Math.max(0, e), r = Math.min(i.duration, r);
                    e < r ? (H.b.log("[buffer-controller]: Removing [" + e + "," + r + "] from the " + t + " SourceBuffer"), a.remove(e, r)) : n.shiftAndExecuteNext(t)
                  }, se.appendExecutor = function (t, e) {
                    var r = this.operationQueue,
                      i = this.sourceBuffer[e];
                    if (!i) return H.b.warn("[buffer-controller]: Attempting to append to the " + e + " SourceBuffer, but it does not exist"), void r.shiftAndExecuteNext(e);
                    i.ended = !1, i.appendBuffer(t)
                  }, se.abortExecutor = function (t) {
                    var e = this.operationQueue,
                      r = this.sourceBuffer[t];
                    if (!r) return H.b.warn("[buffer-controller]: Attempting to abort to the " + t + " SourceBuffer, but it does not exist"), void e.shiftAndExecuteNext(t);
                    H.b.log("[buffer-controller]: Aborting the " + t + " SourceBuffer");
                    e = r.updating;
                    r.abort(), e || this._onSBUpdateEnd(t)
                  }, se.blockBuffers = function (t, e) {
                    var r, i, n = this;
                    (e = void 0 === e ? this.getSourceBufferTypes() : e).length ? (r = this.operationQueue, i = e.map(function (t) {
                      return r.appendBlocker(t)
                    }), Promise.all(i).then(function () {
                      t(), e.forEach(function (t) {
                        var e = n.sourceBuffer[t];
                        e && e.updating || r.shiftAndExecuteNext(t)
                      })
                    })) : t()
                  }, se.getSourceBufferTypes = function () {
                    return Object.keys(this.sourceBuffer)
                  }, se.addBufferListener = function (t, e, r) {
                    var i = this.sourceBuffer[t];
                    i && (r = r.bind(this, t), this.listeners[t].push({
                      event: e,
                      listener: r
                    }), i.addEventListener(e, r))
                  }, se.removeBufferListeners = function (t) {
                    var e = this.sourceBuffer[t];
                    e && this.listeners[t].forEach(function (t) {
                      e.removeEventListener(t.event, t.listener)
                    })
                  }, te);

                function te(t) {
                  var i = this;
                  this._msDuration = null, this._levelTargetDuration = null, this._live = !1, this._objectUrl = null, this.operationQueue = void 0, this.listeners = void 0, this.hls = void 0, this.bufferCodecEventsExpected = 0, this._bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.appendError = 0, this.tracks = {}, this.pendingTracks = {}, this.sourceBuffer = void 0, this._onMediaSourceOpen = function () {
                    var t = i.hls,
                      e = i.media,
                      r = i.mediaSource;
                    H.b.log("media source opened"), e ? t.trigger(p.a.MEDIA_ATTACHED, {
                      media: e
                    }) : H.b.log("[buffer-controller]: Media source opened, and no media was attached"), r && r.removeEventListener("sourceopen", i._onMediaSourceOpen), i.checkPendingTracks()
                  }, this._onMediaSourceClose = function () {
                    H.b.log("[buffer-controller]: Media source closed")
                  }, this._onMediaSourceEnded = function () {
                    H.b.log("[buffer-controller]: Media source ended")
                  }, this.hls = t, this._initSourceBuffer(), this.registerListeners()
                }

                function ee(t) {
                  this.buffers = void 0, this.queues = {
                    video: [],
                    audio: [],
                    audiovideo: []
                  }, this.buffers = t
                }

                function re(t) {
                  this.hls = void 0, this.lastLoadedFragLevel = 0, this._nextAutoLevel = -1, this.timer = void 0, this.onCheck = this._abandonRulesCheck.bind(this), this.fragCurrent = null, this.bitrateTestDelay = 0, this.mildomBootTime = 0, this.bwEstimator = void 0;
                  t = (this.hls = t).config;
                  this.bwEstimator = new Wt(t.abrEwmaSlowVoD, t.abrEwmaFastVoD, t.abrEwmaDefaultEstimate), this.mildomBootTime = 0, this.registerListeners()
                }

                function ie(t, e) {
                  for (var r = 0; r < e.length; r++) {
                    var i = e[r];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                  }
                }
                var ne = ((_e = ce.prototype).setStreamController = function (t) {
                    this.streamController = t
                  }, _e.destroy = function () {
                    this.unregisterListener(), this.hls.config.capLevelToPlayerSize && (this.media = null, this.clientRect = null, this.stopCapping())
                  }, _e.registerListeners = function () {
                    var t = this.hls;
                    t.on(p.a.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.on(p.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.on(p.a.MANIFEST_PARSED, this.onManifestParsed, this), t.on(p.a.LEVELS_UPDATED, this.onLevelsUpdated, this), t.on(p.a.BUFFER_CODECS, this.onBufferCodecs, this), t.on(p.a.MEDIA_DETACHING, this.onMediaDetaching, this)
                  }, _e.unregisterListener = function () {
                    var t = this.hls;
                    t.off(p.a.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), t.off(p.a.MEDIA_ATTACHING, this.onMediaAttaching, this), t.off(p.a.MANIFEST_PARSED, this.onManifestParsed, this), t.off(p.a.LEVELS_UPDATED, this.onLevelsUpdated, this), t.off(p.a.BUFFER_CODECS, this.onBufferCodecs, this), t.off(p.a.MEDIA_DETACHING, this.onMediaDetaching, this)
                  }, _e.onFpsDropLevelCapping = function (t, e) {
                    ce.isLevelAllowed(e.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(e.droppedLevel)
                  }, _e.onMediaAttaching = function (t, e) {
                    this.media = e.media instanceof HTMLVideoElement ? e.media : null
                  }, _e.onManifestParsed = function (t, e) {
                    var r = this.hls;
                    this.restrictedLevels = [], this.levels = e.levels, this.firstLevel = e.firstLevel, r.config.capLevelToPlayerSize && e.video && this.startCapping()
                  }, _e.onBufferCodecs = function (t, e) {
                    this.hls.config.capLevelToPlayerSize && e.video && this.startCapping()
                  }, _e.onLevelsUpdated = function (t, e) {
                    this.levels = e.levels
                  }, _e.onMediaDetaching = function () {
                    this.stopCapping()
                  }, _e.detectPlayerSize = function () {
                    var t, e;
                    this.media && 0 < this.mediaHeight && 0 < this.mediaWidth && ((t = this.levels ? this.levels.length : 0) && ((e = this.hls).autoLevelCapping = this.getMaxLevel(t - 1), e.autoLevelCapping > this.autoLevelCapping && this.streamController && this.streamController.nextLevelSwitch(), this.autoLevelCapping = e.autoLevelCapping))
                  }, _e.getMaxLevel = function (r) {
                    var i = this;
                    if (!this.levels) return -1;
                    var t = this.levels.filter(function (t, e) {
                      return ce.isLevelAllowed(e, i.restrictedLevels) && e <= r
                    });
                    return this.clientRect = null, ce.getMaxLevelByMediaSize(t, this.mediaWidth, this.mediaHeight)
                  }, _e.startCapping = function () {
                    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize())
                  }, _e.stopCapping = function () {
                    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (self.clearInterval(this.timer), this.timer = void 0)
                  }, _e.getDimensions = function () {
                    if (this.clientRect) return this.clientRect;
                    var t, e = this.media,
                      r = {
                        width: 0,
                        height: 0
                      };
                    return e && (t = e.getBoundingClientRect(), r.width = t.width, r.height = t.height, r.width || r.height || (r.width = t.right - t.left || e.width || 0, r.height = t.bottom - t.top || e.height || 0)), this.clientRect = r
                  }, ce.isLevelAllowed = function (t, e) {
                    return -1 === (e = void 0 === e ? [] : e).indexOf(t)
                  }, ce.getMaxLevelByMediaSize = function (t, e, r) {
                    if (!t || t && !t.length) return -1;
                    for (var i, n = t.length - 1, a = 0; a < t.length; a += 1) {
                      var s = t[a];
                      if ((s.width >= e || s.height >= r) && (!(i = t[a + 1]) || s.width !== i.width || s.height !== i.height)) {
                        n = a;
                        break
                      }
                    }
                    return n
                  }, Se = [{
                    key: "contentScaleFactor",
                    get: function () {
                      var t = 1;
                      try {
                        t = self.devicePixelRatio
                      } catch (t) {}
                      return t
                    }
                  }], ie((_e = ce).prototype, [{
                    key: "mediaWidth",
                    get: function () {
                      return this.getDimensions().width * ce.contentScaleFactor
                    }
                  }, {
                    key: "mediaHeight",
                    get: function () {
                      return this.getDimensions().height * ce.contentScaleFactor
                    }
                  }]), ie(_e, Se), ce),
                  ae = self.performance,
                  se = ((pe = de.prototype).setStreamController = function (t) {
                    this.streamController = t
                  }, pe.registerListeners = function () {
                    this.hls.on(p.a.MEDIA_ATTACHING, this.onMediaAttaching, this)
                  }, pe.unregisterListeners = function () {
                    this.hls.off(p.a.MEDIA_ATTACHING, this.onMediaAttaching)
                  }, pe.destroy = function () {
                    this.timer && clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null
                  }, pe.onMediaAttaching = function (t, e) {
                    var r = this.hls.config;
                    r.capLevelOnFPSDrop && (e = e.media instanceof self.HTMLVideoElement ? e.media : null, (this.media = e) && "function" == typeof e.getVideoPlaybackQuality && (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setTimeout(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod))
                  }, pe.checkFPS = function (t, e, r) {
                    var i, n, a, s, o = ae.now();
                    e && (this.lastTime && (a = o - this.lastTime, i = r - this.lastDroppedFrames, s = e - this.lastDecodedFrames, n = 1e3 * i / a, (a = this.hls).trigger(p.a.FPS_DROP, {
                      currentDropped: i,
                      currentDecoded: s,
                      totalDroppedFrames: r
                    }), 0 < n && i > a.config.fpsDroppedMonitoringThreshold * s && (s = a.currentLevel, H.b.warn("drop FPS ratio greater than max allowed value for currentLevel: " + s), 0 < s && (-1 === a.autoLevelCapping || a.autoLevelCapping >= s) && (a.trigger(p.a.FPS_DROP_LEVEL_CAPPING, {
                      level: --s,
                      droppedLevel: a.currentLevel
                    }), a.autoLevelCapping = s, this.streamController.nextLevelSwitch()))), this.lastTime = o, this.lastDroppedFrames = r, this.lastDecodedFrames = e)
                  }, pe.checkFPSInterval = function () {
                    var t, e = this.media;
                    e && (this.isVideoPlaybackQualityAvailable ? (t = e.getVideoPlaybackQuality(), this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames)) : this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount))
                  }, de),
                  oe = r(9),
                  le = ((_e = he.prototype).destroy = function () {
                    this.loader = this.callbacks = null, this.abortInternal()
                  }, _e.abortInternal = function () {
                    this.stats.aborted = !0;
                    var t = this.loader;
                    t && 4 !== t.readyState && t.abort(), self.clearTimeout(this.requestTimeout), this.requestTimeout = -1, self.clearTimeout(this.retryTimeout), this.retryTimeout = -1
                  }, _e.abort = function () {
                    var t;
                    this.abortInternal(), null !== (t = this.callbacks) && void 0 !== t && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.loader)
                  }, _e.load = function (t, e, r) {
                    this.context = t, this.config = e, this.callbacks = r, Object(oe.b)(this.stats), this.stats.loading.start = performance.now(), this.retryDelay = e.retryDelay, this.loadInternal()
                  }, _e.loadInternal = function () {
                    var t = this.context,
                      e = this.loader = new self.XMLHttpRequest,
                      r = this.stats;
                    r.loading.first = 0, r.loaded = 0;
                    var i = this.xhrSetup;
                    try {
                      if (i) try {
                        i(e, t.url)
                      } catch (r) {
                        e.open("GET", t.url, !0), i(e, t.url)
                      }
                      e.readyState || e.open("GET", t.url, !0)
                    } catch (r) {
                      return void this.callbacks.onError({
                        code: e.status,
                        text: r.message
                      }, t, e)
                    }
                    t.rangeEnd && e.setRequestHeader("Range", "bytes=" + t.rangeStart + "-" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), this.config.timeout), e.send()
                  }, _e.readystatechange = function (t) {
                    var e, r = t.currentTarget,
                      i = r.readyState,
                      n = this.stats,
                      a = this.context,
                      s = this.config;
                    !n.aborted && 2 <= i && (self.clearTimeout(this.requestTimeout), 0 === n.loading.first && (n.loading.first = Math.max(performance.now(), n.loading.start)), 4 === i ? 200 <= (t = r.status) && t < 300 ? (n.loading.end = Math.max(performance.now(), n.loading.first), i = "arraybuffer" === a.responseType ? (e = r.response).byteLength : (e = r.responseText).length, n.loaded = n.total = i, (i = this.callbacks.onProgress) && i(n, a, e, r), e = {
                      url: r.responseURL,
                      data: e
                    }, this.callbacks.onSuccess(e, n, a, r)) : n.retry >= s.maxRetry || 400 <= t && t < 499 ? (H.b.error(t + " while loading " + a.url), this.callbacks.onError({
                      code: t,
                      text: r.statusText
                    }, a, r)) : (H.b.warn(t + " while loading " + a.url + ", retrying in " + this.retryDelay + "..."), this.loader = null, this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, s.maxRetryDelay), n.retry++) : this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), s.timeout))
                  }, _e.loadtimeout = function () {
                    H.b.warn("timeout while loading " + this.context.url);
                    var t = this.callbacks;
                    t && (this.abortInternal(), t.onTimeout(this.stats, this.context, this.loader))
                  }, _e.loadprogress = function (t) {
                    var e = this.stats;
                    e.loaded = t.loaded, t.lengthComputable && (e.total = t.total)
                  }, _e.getResponseHeader = function (t) {
                    if (this.loader) try {
                      return this.loader.getResponseHeader(t)
                    } catch (t) {}
                    return null
                  }, he),
                  ue = r(15);

                function he(t) {
                  this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = void 0, this.callbacks = null, this.context = void 0, this.loader = null, this.stats = void 0, this.xhrSetup = t ? t.xhrSetup : null, this.stats = new oe.a, this.retryDelay = 0
                }

                function de(t) {
                  this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = t, this.registerListeners()
                }

                function ce(t) {
                  this.autoLevelCapping = void 0, this.firstLevel = void 0, this.levels = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.hls = void 0, this.streamController = void 0, this.clientRect = void 0, this.hls = t, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.levels = [], this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners()
                }

                function fe(t) {
                  var r = "function" == typeof Map ? new Map : void 0;
                  return (fe = function (t) {
                    if (null === t || -1 === Function.toString.call(t).indexOf("[native code]")) return t;
                    if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                    if (void 0 !== r) {
                      if (r.has(t)) return r.get(t);
                      r.set(t, e)
                    }

                    function e() {
                      return ge(t, arguments, ve(this).constructor)
                    }
                    return e.prototype = Object.create(t.prototype, {
                      constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                      }
                    }), me(e, t)
                  })(t)
                }

                function ge(t, e, r) {
                  return (ge = function () {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                      return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0
                    } catch (t) {
                      return !1
                    }
                  }() ? Reflect.construct : function (t, e, r) {
                    var i = [null];
                    i.push.apply(i, e);
                    i = new(Function.bind.apply(t, i));
                    return r && me(i, r.prototype), i
                  }).apply(null, arguments)
                }

                function me(t, e) {
                  return (me = Object.setPrototypeOf || function (t, e) {
                    return t.__proto__ = e, t
                  })(t, e)
                }

                function ve(t) {
                  return (ve = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                  })(t)
                }
                var pe = ((Se = ye.prototype).destroy = function () {
                  this.loader = this.callbacks = null, this.abortInternal()
                }, Se.abortInternal = function () {
                  this.stats.aborted = !0, this.controller.abort()
                }, Se.abort = function () {
                  var t;
                  this.abortInternal(), null !== (t = this.callbacks) && void 0 !== t && t.onAbort && this.callbacks.onAbort(this.stats, this.context, this.response)
                }, Se.load = function (i, n, a) {
                  var s = this,
                    o = this.stats;
                  Object(oe.b)(o), o.loading.start = self.performance.now();
                  var t = function (t) {
                      t = {
                        method: "GET",
                        mode: "cors",
                        credentials: "same-origin",
                        signal: t
                      };
                      return i.rangeEnd && (t.headers = new self.Headers({
                        Range: "bytes=" + i.rangeStart + "-" + String(i.rangeEnd - 1)
                      })), t
                    }(this.controller.signal),
                    l = a.onProgress,
                    u = "arraybuffer" === i.responseType,
                    h = u ? "byteLength" : "length";
                  this.context = i, this.config = n, this.callbacks = a, this.request = this.fetchSetup(i, t), self.clearTimeout(this.requestTimeout), this.requestTimeout = self.setTimeout(function () {
                    s.abortInternal(), a.onTimeout(o, i, s.response)
                  }, n.timeout), self.fetch(this.request).then(function (t) {
                    if ((s.response = s.loader = t).ok) return o.loading.first = Math.max(self.performance.now(), o.loading.start), o.total = parseInt(t.headers.get("Content-Length") || "0"), l && Object(B.a)(n.highWaterMark) && s.loadProgressively(t, o, i, n.highWaterMark, l), u ? t.arrayBuffer() : t.text();
                    var e = t.status,
                      r = t.statusText;
                    throw new Le(r || "fetch, bad network response", e, t)
                  }).then(function (t) {
                    var e = s.response;
                    self.clearTimeout(s.requestTimeout), o.loading.end = Math.max(self.performance.now(), o.loading.first), o.loaded = o.total = t[h];
                    var r = {
                      url: e.url,
                      data: t
                    };
                    l && !Object(B.a)(n.highWaterMark) && l(o, i, t, e), a.onSuccess(r, o, i, e)
                  }).catch(function (t) {
                    var e;
                    self.clearTimeout(s.requestTimeout), o.aborted || (e = t.code || 0, a.onError({
                      code: e,
                      text: t.message
                    }, i, t.details))
                  })
                }, Se.getResponseHeader = function (t) {
                  if (this.response) try {
                    return this.response.headers.get(t)
                  } catch (t) {}
                  return null
                }, Se.loadProgressively = function (i, n, a, s, o) {
                  void 0 === s && (s = 0);
                  var l = new ue.a,
                    t = i.clone().body.getReader();
                  ! function r() {
                    t.read().then(function (t) {
                      var e;
                      t.done ? l.dataLength && o(n, a, l.flush(), i) : (t = (e = t.value).length, n.loaded += t, t < s || l.dataLength ? (l.push(e), l.dataLength >= s && o(n, a, l.flush(), i)) : o(n, a, e, i), r())
                    }).catch(function () {})
                  }()
                }, ye);

                function ye(t) {
                  this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = void 0, this.response = void 0, this.controller = void 0, this.context = void 0, this.config = void 0, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = t.fetchSetup || Ee, this.controller = new self.AbortController, this.stats = new oe.a
                }

                function Ee(t, e) {
                  return new self.Request(t.url, e)
                }
                var be, Se, _e, Le = (be = fe(Error), _e = be, (Se = Ae).prototype = Object.create(_e.prototype), (Se.prototype.constructor = Se).__proto__ = _e, Ae),
                  Te = pe;

                function Ae(t, e, r) {
                  return (t = be.call(this, t) || this).code = void 0, t.details = void 0, t.code = e, t.details = r, t
                }(pe = {}).WIDEVINE = "com.widevine.alpha", pe.PLAYREADY = "com.microsoft.playready";
                pe = "undefined" != typeof self && self.navigator && self.navigator.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;

                function Re() {
                  return (Re = Object.assign || function (t) {
                    for (var e = 1; e < arguments.length; e++) {
                      var r, i = arguments[e];
                      for (r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
                    }
                    return t
                  }).apply(this, arguments)
                }

                function De(e, t) {
                  var r, i = Object.keys(e);
                  return Object.getOwnPropertySymbols && (r = Object.getOwnPropertySymbols(e), t && (r = r.filter(function (t) {
                    return Object.getOwnPropertyDescriptor(e, t).enumerable
                  })), i.push.apply(i, r)), i
                }

                function ke(i) {
                  for (var t = 1; t < arguments.length; t++) {
                    var n = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? De(Object(n), !0).forEach(function (t) {
                      var e, r;
                      e = i, t = n[r = t], r in e ? Object.defineProperty(e, r, {
                        value: t,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                      }) : e[r] = t
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(n)) : De(Object(n)).forEach(function (t) {
                      Object.defineProperty(i, t, Object.getOwnPropertyDescriptor(n, t))
                    })
                  }
                  return i
                }
                var Ce = ke(ke(ke({
                    autoStartLoad: !0,
                    startPosition: -1,
                    defaultAudioCodec: void 0,
                    debug: !1,
                    capLevelOnFPSDrop: !1,
                    capLevelToPlayerSize: !1,
                    initialLiveManifestSize: 1,
                    maxBufferLength: 30,
                    maxBufferSize: 6e7,
                    maxBufferHole: .5,
                    highBufferWatchdogPeriod: 2,
                    nudgeOffset: .1,
                    nudgeMaxRetry: 3,
                    maxFragLookUpTolerance: .25,
                    liveSyncDurationCount: 3,
                    liveMaxLatencyDurationCount: 1 / 0,
                    liveSyncDuration: void 0,
                    liveMaxLatencyDuration: void 0,
                    minLiveSyncPlaybackRate: .75,
                    maxLiveSyncPlaybackRate: 1.5,
                    liveDurationInfinity: !1,
                    liveBackBufferLength: 1 / 0,
                    maxMaxBufferLength: 600,
                    enableWorker: !0,
                    enableSoftwareAES: !0,
                    manifestLoadingTimeOut: 1e4,
                    manifestLoadingMaxRetry: 1,
                    manifestLoadingRetryDelay: 1e3,
                    manifestLoadingMaxRetryTimeout: 64e3,
                    startLevel: void 0,
                    levelLoadingTimeOut: 1e4,
                    levelLoadingMaxRetry: 4,
                    levelLoadingRetryDelay: 1e3,
                    levelLoadingMaxRetryTimeout: 64e3,
                    fragLoadingTimeOut: 2e4,
                    fragLoadingMaxRetry: 6,
                    fragLoadingRetryDelay: 1e3,
                    fragLoadingMaxRetryTimeout: 64e3,
                    startFragPrefetch: !1,
                    fpsDroppedMonitoringPeriod: 5e3,
                    fpsDroppedMonitoringThreshold: .2,
                    appendErrorMaxRetry: 3,
                    loader: le,
                    fLoader: void 0,
                    pLoader: void 0,
                    xhrSetup: void 0,
                    licenseXhrSetup: void 0,
                    abrController: dt,
                    bufferController: Nt,
                    capLevelController: ne,
                    fpsController: se,
                    stretchShortVideoTrack: !1,
                    maxAudioFramesDrift: 1,
                    forceKeyFrameOnDiscontinuity: !0,
                    abrEwmaFastLive: 3,
                    abrEwmaSlowLive: 9,
                    abrEwmaFastVoD: 3,
                    abrEwmaSlowVoD: 9,
                    abrEwmaDefaultEstimate: 5e5,
                    abrBandWidthFactor: .95,
                    abrBandWidthUpFactor: .7,
                    abrMaxWithRealBitrate: !1,
                    maxStarvationDelay: 4,
                    maxLoadingDelay: 4,
                    minAutoBitrate: 0,
                    emeEnabled: !1,
                    widevineLicenseUrl: void 0,
                    drmSystemOptions: {},
                    requestMediaKeySystemAccessFunc: pe,
                    testBandwidth: !0,
                    progressive: !1,
                    lowLatencyMode: !1,
                    userConfig: {},
                    mildomLevelMaxReloadInterval: 2e3,
                    mildomFragMaxParallelLoadNum: 2,
                    mildomRealtimePlaybackMode: !1
                  }, {
                    cueHandler: Qt,
                    enableCEA708Captions: !1,
                    enableWebVTT: !1,
                    enableIMSC1: !1,
                    captionsTextTrack1Label: "English",
                    captionsTextTrack1LanguageCode: "en",
                    captionsTextTrack2Label: "Spanish",
                    captionsTextTrack2LanguageCode: "es",
                    captionsTextTrack3Label: "Unknown CC",
                    captionsTextTrack3LanguageCode: "",
                    captionsTextTrack4Label: "Unknown CC",
                    captionsTextTrack4LanguageCode: "",
                    renderTextTracksNatively: !0
                  }), {
                    mildomMaxBufferSizeThreshold: 1e4,
                    mildomBufferSizeLimitionDuration: 15e3,
                    mildomChasePositionBefore: 9e3,
                    mildomSpeedResetFactor: .2,
                    mildomSpeedDownRate: .92,
                    mildomSpeedUpRate: 1.08,
                    mildomSpeedUpMinBufferDuration: 15e3,
                    mildomSpeedMaxBufferSizeThreshold: 15e3,
                    mildomSpeedResetBufferSizeThreshold: 9e3,
                    mildomSpeedUpBufferGap: 8e3,
                    mildomSpeedResetBufferGap: 2e3
                  }), {}, {
                    subtitleStreamController: void 0,
                    subtitleTrackController: void 0,
                    timelineController: void 0,
                    audioStreamController: void 0,
                    audioTrackController: void 0,
                    emeController: void 0
                  }),
                  we = function () {
                    if (self.fetch && self.AbortController && self.ReadableStream && self.Request) try {
                      return new self.ReadableStream({}), !0
                    } catch (t) {}
                    return !1
                  }();
                var xe = r(6),
                  Pe = ((r = Oe.prototype).destroy = function () {
                    this._unregisterListeners()
                  }, r._registerListeners = function () {
                    var t = this.hls;
                    t.on(p.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.on(p.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.on(p.a.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.on(p.a.BUFFER_FLUSHING, this.onBufferFlushing, this)
                  }, r._unregisterListeners = function () {
                    var t = this.hls;
                    t.off(p.a.MEDIA_ATTACHED, this.onMediaAttached, this), t.off(p.a.MEDIA_DETACHING, this.onMediaDetaching, this), t.off(p.a.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), t.off(p.a.BUFFER_FLUSHING, this.onBufferFlushing, this)
                  }, r.onMediaAttached = function (t, e) {
                    this.media = e.media, this.media
                  }, r.onMediaDetaching = function () {
                    this.id3Track && (function (t) {
                      if (null != t && t.cues)
                        for ("disabled" === t.mode && (t.mode = "hidden"); 0 < t.cues.length;) t.removeCue(t.cues[0])
                    }(this.id3Track), this.id3Track = null, this.media = null)
                  }, r.getID3Track = function (t) {
                    if (this.media) {
                      for (var e = 0; e < t.length; e++) {
                        var r = t[e];
                        if ("metadata" === r.kind && "id3" === r.label) return function (t, e) {
                          var r;
                          try {
                            r = new Event("addtrack")
                          } catch (t) {
                            (r = document.createEvent("Event")).initEvent("addtrack", !1, !1)
                          }
                          r.track = t, e.dispatchEvent(r)
                        }(r, this.media), r
                      }
                      return this.media.addTextTrack("metadata", "id3")
                    }
                  }, r.onFragParsingMetadata = function (t, e) {
                    if (this.media) {
                      var r = e.frag,
                        i = e.samples;
                      this.id3Track || (this.id3Track = this.getID3Track(this.media.textTracks), this.id3Track.mode = "hidden");
                      for (var n = self.WebKitDataCue || self.VTTCue || self.TextTrackCue, a = 0; a < i.length; a++) {
                        var s = xe.c(i[a].data);
                        if (s) {
                          var o = i[a].pts,
                            l = a < i.length - 1 ? i[a + 1].pts : r.end;
                          l - o <= 0 && (l = o + .25);
                          for (var u = 0; u < s.length; u++) {
                            var h, d = s[u];
                            xe.e(d) || ((h = new n(o, l, "")).value = d, this.id3Track.addCue(h))
                          }
                        }
                      }
                    }
                  }, r.onBufferFlushing = function (t, e) {
                    var r = e.startOffset,
                      i = e.endOffset,
                      e = e.type;
                    if (!e || "audio" === e) {
                      var n = this.id3Track;
                      if (n && n.cues && n.cues.length)
                        for (var a = function (t, e, r) {
                            var i = [],
                              n = function (t, e) {
                                if (e < t[0].startTime) return 0;
                                if (e > t[t.length - 1].endTime) return -1;
                                for (var r = 0, i = t.length - 1; r <= i;) {
                                  var n = Math.floor((i + r) / 2);
                                  if (e < t[n].startTime) i = n - 1;
                                  else {
                                    if (!(e > t[n].startTime)) return n;
                                    r = n + 1
                                  }
                                }
                                return t[r].startTime - e < e - t[i].startTime ? r : i
                              }(t, e);
                            if (-1 < n)
                              for (var a = n, s = t.length; a < s; a++) {
                                var o = t[a];
                                if (o.startTime >= e && o.endTime <= r) i.push(o);
                                else if (o.startTime > r) return i
                              }
                            return i
                          }(n.cues, r, i), s = 0; s < a.length; s++) n.removeCue(a[s])
                    }
                  }, Oe);

                function Oe(t) {
                  this.hls = void 0, this.id3Track = null, this.media = null, this.hls = t, this._registerListeners()
                }
                var Fe, Ie = ((r = Me.prototype).destroy = function () {
                  this.unregisterListeners(), this.onMediaDetaching()
                }, r.registerListeners = function () {
                  this.hls.on(p.a.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(p.a.MEDIA_DETACHING, this.onMediaDetaching, this), this.hls.on(p.a.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(p.a.LEVEL_UPDATED, this.onLevelUpdated, this), this.hls.on(p.a.ERROR, this.onError, this)
                }, r.unregisterListeners = function () {
                  this.hls.off(p.a.MEDIA_ATTACHED, this.onMediaAttached), this.hls.off(p.a.MEDIA_DETACHING, this.onMediaDetaching), this.hls.off(p.a.MANIFEST_LOADING, this.onManifestLoading), this.hls.off(p.a.LEVEL_UPDATED, this.onLevelUpdated), this.hls.off(p.a.ERROR, this.onError)
                }, r.onMediaAttached = function (t, e) {
                  this.media = e.media, this.media.addEventListener("timeupdate", this.timeupdateHandler)
                }, r.onMediaDetaching = function () {
                  this.media && (this.media.removeEventListener("timeupdate", this.timeupdateHandler), this.media = null)
                }, r.onManifestLoading = function () {
                  this.levelDetails = null, this._latency = null, this.stallCount = 0
                }, r.onLevelUpdated = function (t, e) {
                  e = e.details;
                  (this.levelDetails = e).advanced && this.timeupdate(), !e.live && this.media && this.media.removeEventListener("timeupdate", this.timeupdateHandler)
                }, r.onError = function (t, e) {
                  e.details === g.a.BUFFER_STALLED_ERROR && (this.stallCount++, H.b.warn("[playback-rate-controller]: Stall detected, adjusting target latency"))
                }, r.timeupdate = function () {}, r.estimateLiveEdge = function () {
                  var t = this.levelDetails;
                  return null === t ? null : t.edge + t.age
                }, r.computeLatency = function () {
                  var t = this.estimateLiveEdge();
                  return null === t ? null : t - this.currentTime
                }, function (t, e) {
                  for (var r = 0; r < e.length; r++) {
                    var i = e[r];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                  }
                }(Me.prototype, [{
                  key: "latency",
                  get: function () {
                    return this._latency || 0
                  }
                }, {
                  key: "maxLatency",
                  get: function () {
                    var t = this.config,
                      e = this.levelDetails;
                    return void 0 !== t.liveMaxLatencyDuration ? t.liveMaxLatencyDuration : e ? t.liveMaxLatencyDurationCount * e.targetduration : 0
                  }
                }, {
                  key: "targetLatency",
                  get: function () {
                    var t = this.levelDetails;
                    if (null === t) return null;
                    var e = t.holdBack,
                      r = t.partHoldBack,
                      i = t.targetduration,
                      n = this.config,
                      a = n.liveSyncDuration,
                      s = n.liveSyncDurationCount,
                      o = n.lowLatencyMode,
                      n = this.hls.userConfig,
                      e = o && r || e;
                    if (n.liveSyncDuration || n.liveSyncDurationCount || 0 === e) {
                      for (var l = t.fragments, u = 0, h = l.length - s; h < l.length && l.length >= s; h++) u += l[h].duration;
                      u = u || s * i, e = void 0 !== a ? a : u
                    }
                    t = t.targetduration;
                    return e + Math.min(+this.stallCount, t)
                  }
                }, {
                  key: "liveSyncPosition",
                  get: function () {
                    var t = this.estimateLiveEdge(),
                      e = this.targetLatency;
                    return null === t || null === e || null === this.levelDetails ? null : Math.min(this.levelDetails.edge, t - e - this.edgeStalled)
                  }
                }, {
                  key: "edgeStalled",
                  get: function () {
                    var t = this.levelDetails;
                    if (null === t) return 0;
                    var e = 3 * (this.config.lowLatencyMode && t.partTarget || t.targetduration);
                    return Math.max(t.age - e, 0)
                  }
                }]), Me);

                function Me(t) {
                  var e = this;
                  this.hls = void 0, this.config = void 0, this.media = null, this.levelDetails = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this.timeupdateHandler = function () {
                    return e.timeupdate()
                  }, this.hls = t, this.config = t.config, this.registerListeners()
                }(r = Fe = Fe || {}).SPEED_UP = "speed_up", r.SPEED_RESET = "speed_reset", r.SPEED_DOWN = "speed_down";
                var Ne = function (r) {
                  var t;

                  function e(t) {
                    var e;
                    return (e = r.call(this) || this).hls = void 0, e.upperMaxBufferSizeTime = 0, e.mildomUpperSpeedMaxBufferSizeTimeStamp = 0, e.mildomSpeedResetTimeStamp = 0, e.hls = t, e.setInterval(100), e
                  }
                  i = r, (t = e).prototype = Object.create(i.prototype), (t.prototype.constructor = t).__proto__ = i;
                  var i = e.prototype;
                  return i.doTick = function () {
                    var t, e, r;
                    0 < this.hls.levels.length && (null != (e = this.hls.levels[0 < this.hls.currentLevel ? this.hls.currentLevel : 0].details) && e.live && this.hls.isRunning && (!this.hls.lowLatencyMode && null != e && e.averagetargetduration && (t = Math.round(1e3 * e.averagetargetduration), e = (r = this.hls.config).mildomSpeedUpBufferGap, r = r.mildomSpeedResetBufferGap, this.hls.config.mildomSpeedMaxBufferSizeThreshold = t + e, this.hls.config.mildomSpeedResetBufferSizeThreshold = t + r), this.chaseToLiveEdge()))
                  }, i.chaseToLiveEdge = function () {
                    var t = this.hls,
                      e = t.media,
                      r = t.config,
                      i = r.mildomSpeedMaxBufferSizeThreshold,
                      n = r.mildomSpeedUpRate,
                      a = r.mildomSpeedResetFactor,
                      t = r.mildomSpeedUpMinBufferDuration,
                      r = r.mildomSpeedResetBufferSizeThreshold;
                    !e || e.buffered.length <= 0 || e.played.length <= 0 || (i <= (i = 1e3 * (e.buffered.end(e.buffered.length - 1) - e.played.end(e.played.length - 1))) ? 0 === this.mildomUpperSpeedMaxBufferSizeTimeStamp && (this.mildomUpperSpeedMaxBufferSizeTimeStamp = performance.now()) : this.mildomUpperSpeedMaxBufferSizeTimeStamp = 0, 1 === e.playbackRate && 0 !== this.mildomUpperSpeedMaxBufferSizeTimeStamp && performance.now() - this.mildomUpperSpeedMaxBufferSizeTimeStamp >= t && !e.paused && (e.playbackRate = n, this.mildomUpperSpeedMaxBufferSizeTimeStamp = 0, this.hls.trigger(p.a.MILDOM_LATENCY_CONTROL, {
                      status: Fe.SPEED_UP,
                      playbackRate: n
                    })), 1 !== e.playbackRate && (i <= r ? 0 === this.mildomSpeedResetTimeStamp && (this.mildomSpeedResetTimeStamp = performance.now()) : this.mildomSpeedResetTimeStamp = 0, 0 !== this.mildomSpeedResetTimeStamp && performance.now() - this.mildomSpeedResetTimeStamp > a * t && (e.playbackRate = 1, this.mildomSpeedResetTimeStamp = 0, this.hls.trigger(p.a.MILDOM_LATENCY_CONTROL, {
                      status: Fe.SPEED_RESET,
                      playbackRate: 1
                    }))))
                  }, e
                }(e);

                function Ue(t, e) {
                  for (var r = 0; r < e.length; r++) {
                    var i = e[r];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                  }
                }

                function Be(t, e, r) {
                  return e && Ue(t.prototype, e), r && Ue(t, r), t
                }
                var He = function () {
                  function c(t) {
                    var e = this;
                    void 0 === t && (t = {}), this.config = void 0, this.userConfig = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new mt.EventEmitter, this._autoLevelCapping = void 0, this.abrController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.emeController = void 0, this.mildomLatencyController = null, this._isMildomLiveEnd = !1, this._media = null, this.url = null, this._isRunning = !1;
                    var r = this.config = function (t, e) {
                      if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) && (e.liveSyncDuration || e.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
                      if (void 0 !== e.liveMaxLatencyDurationCount && e.liveMaxLatencyDurationCount <= e.liveSyncDurationCount) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
                      if (void 0 !== e.liveMaxLatencyDuration && (e.liveMaxLatencyDuration <= e.liveSyncDuration || void 0 === e.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
                      return Re({}, t, e)
                    }(c.DefaultConfig, t);
                    this.userConfig = t, Object(H.a)(r.debug), this._autoLevelCapping = -1, this.progressive = r.progressive;
                    var i = this.abrController = new r.abrController(this),
                      n = new r.bufferController(this),
                      a = this.capLevelController = new r.capLevelController(this),
                      s = new r.fpsController(this),
                      o = new L(this),
                      l = new T(this),
                      u = new Pe(this),
                      h = this.levelController = new qt(this),
                      t = new D(this),
                      d = this.streamController = new Ft(this, t);
                    h.onParsedComplete = function () {
                      (r.autoStartLoad || d.forceStartLoad) && e.startLoad(r.startPosition)
                    }, a.setStreamController(d), s.setStreamController(d);
                    h = [h, d];
                    this.networkControllers = h;
                    u = [o, l, i, n, a, s, u, t];
                    this.audioTrackController = this.createController(r.audioTrackController, null, h), this.createController(r.audioStreamController, t, h), this.subtitleTrackController = this.createController(r.subtitleTrackController, null, h), this.createController(r.subtitleStreamController, t, h), this.createController(r.timelineController, null, u), this.emeController = this.createController(r.emeController, null, u), this.latencyController = this.createController(Ie, null, u), this.config.mildomRealtimePlaybackMode || (this.mildomLatencyController = this.createController(Ne, null, u)), this.coreComponents = u
                  }
                  c.isSupported = function () {
                    var t = gt();
                    if (!t) return !1;
                    var e = self.SourceBuffer || self.WebKitSourceBuffer,
                      t = t && "function" == typeof t.isTypeSupported && t.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'),
                      e = !e || e.prototype && "function" == typeof e.prototype.appendBuffer && "function" == typeof e.prototype.remove;
                    return !!t && !!e
                  }, Be(c, null, [{
                    key: "version",
                    get: function () {
                      return "1.0.0-alpha14"
                    }
                  }, {
                    key: "Events",
                    get: function () {
                      return p.a
                    }
                  }, {
                    key: "ErrorTypes",
                    get: function () {
                      return g.b
                    }
                  }, {
                    key: "ErrorDetails",
                    get: function () {
                      return g.a
                    }
                  }, {
                    key: "DefaultConfig",
                    get: function () {
                      return c.defaultConfig || Ce
                    },
                    set: function (t) {
                      c.defaultConfig = t
                    }
                  }]);
                  var t = c.prototype;
                  return t.createController = function (t, e, r) {
                    if (t) {
                      t = e ? new t(this, e) : new t(this);
                      return r && r.push(t), t
                    }
                    return null
                  }, t.on = function (i, n, t) {
                    var a = this;
                    this._emitter.on(i, function () {
                      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
                      if (a.config.debug) n.apply(this, e);
                      else try {
                        n.apply(this, e)
                      } catch (t) {
                        H.b.error("An internal error happened while handling event " + i + '. Error message: "' + t.message + '". Here is a stacktrace:', t), a.trigger(p.a.ERROR, {
                          type: g.b.OTHER_ERROR,
                          details: g.a.INTERNAL_EXCEPTION,
                          fatal: !1,
                          event: i,
                          error: t
                        })
                      }
                    }, t)
                  }, t.once = function (i, n, t) {
                    var a = this;
                    this._emitter.once(i, function () {
                      for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
                      if (a.config.debug) n.apply(this, e);
                      else try {
                        n.apply(this, e)
                      } catch (t) {
                        H.b.error("An internal error happened while handling event " + i + '. Error message: "' + t.message + '". Here is a stacktrace:', t), a.trigger(p.a.ERROR, {
                          type: g.b.OTHER_ERROR,
                          details: g.a.INTERNAL_EXCEPTION,
                          fatal: !1,
                          event: i,
                          error: t
                        })
                      }
                    }, t)
                  }, t.removeAllListeners = function (t) {
                    this._emitter.removeAllListeners(t)
                  }, t.off = function (t, e, r, i) {
                    this._emitter.off(t, e, r, i)
                  }, t.listeners = function (t) {
                    return this._emitter.listeners(t)
                  }, t.emit = function (t, e, r) {
                    return this._emitter.emit(t, e, r)
                  }, t.trigger = function (t, e) {
                    return this._emitter.emit(t, t, e)
                  }, t.listenerCount = function (t) {
                    return this._emitter.listenerCount(t)
                  }, t.destroy = function () {
                    H.b.log("destroy"), this.trigger(p.a.DESTROYING, void 0), this.detachMedia(), this.networkControllers.forEach(function (t) {
                      return t.destroy()
                    }), this.coreComponents.forEach(function (t) {
                      return t.destroy()
                    }), this.url = null, this.removeAllListeners(), this._autoLevelCapping = -1
                  }, t.attachMedia = function (t) {
                    H.b.log("attachMedia"), this._media = t, this.trigger(p.a.MEDIA_ATTACHING, {
                      media: t
                    })
                  }, t.detachMedia = function () {
                    H.b.log("detachMedia"), this.trigger(p.a.MEDIA_DETACHING, void 0), this._media = null
                  }, t.loadSource = function (t) {
                    this.stopLoad();
                    var e = this.media;
                    e && this.url && (this.detachMedia(), this.attachMedia(e)), t = i.buildAbsoluteURL(self.location.href, t, {
                      alwaysNormalize: !0
                    }), H.b.log("loadSource:" + t), this.url = t, this.trigger(p.a.MANIFEST_LOADING, {
                      url: t
                    })
                  }, t.startLoad = function (e) {
                    void 0 === e && (e = -1), this.isRunning = !0, this.isMildomLiveEnd = !1, H.b.log("startLoad(" + e + ")"), this.isMildomLiveEnd = !1, this.networkControllers.forEach(function (t) {
                      t.startLoad(e)
                    })
                  }, t.notifyMildomLiveEnd = function () {
                    this.isMildomLiveEnd = !0
                  }, t.stopLoad = function () {
                    this.isRunning = !1, H.b.log("stopLoad"), this.networkControllers.forEach(function (t) {
                      t.stopLoad()
                    })
                  }, t.swapAudioCodec = function () {
                    H.b.log("swapAudioCodec"), this.streamController.swapAudioCodec()
                  }, t.recoverMediaError = function () {
                    H.b.log("recoverMediaError");
                    var t = this._media;
                    this.detachMedia(), t && this.attachMedia(t)
                  }, t.removeLevel = function (t, e) {
                    this.levelController.removeLevel(t, e = void 0 === e ? 0 : e)
                  }, Be(c, [{
                    key: "levels",
                    get: function () {
                      return this.levelController.levels || []
                    }
                  }, {
                    key: "currentLevel",
                    get: function () {
                      return this.streamController.currentLevel
                    },
                    set: function (t) {
                      H.b.log("set currentLevel:" + t), this.loadLevel = t, this.streamController.immediateLevelSwitch()
                    }
                  }, {
                    key: "nextLevel",
                    get: function () {
                      return this.streamController.nextLevel
                    },
                    set: function (t) {
                      H.b.log("set nextLevel:" + t), this.levelController.manualLevel = t, this.streamController.nextLevelSwitch()
                    }
                  }, {
                    key: "loadLevel",
                    get: function () {
                      return this.levelController.level
                    },
                    set: function (t) {
                      H.b.log("set loadLevel:" + t), this.levelController.manualLevel = t
                    }
                  }, {
                    key: "nextLoadLevel",
                    get: function () {
                      return this.levelController.nextLoadLevel
                    },
                    set: function (t) {
                      this.levelController.nextLoadLevel = t
                    }
                  }, {
                    key: "firstLevel",
                    get: function () {
                      return Math.max(this.levelController.firstLevel, this.minAutoLevel)
                    },
                    set: function (t) {
                      H.b.log("set firstLevel:" + t), this.levelController.firstLevel = t
                    }
                  }, {
                    key: "startLevel",
                    get: function () {
                      return this.levelController.startLevel
                    },
                    set: function (t) {
                      H.b.log("set startLevel:" + t), -1 !== t && (t = Math.max(t, this.minAutoLevel)), this.levelController.startLevel = t
                    }
                  }, {
                    key: "capLevelToPlayerSize",
                    get: function () {
                      return this.config.capLevelToPlayerSize
                    },
                    set: function (t) {
                      t = !!t;
                      t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t)
                    }
                  }, {
                    key: "autoLevelCapping",
                    get: function () {
                      return this._autoLevelCapping
                    },
                    set: function (t) {
                      this._autoLevelCapping !== t && (H.b.log("set autoLevelCapping:" + t), this._autoLevelCapping = t)
                    }
                  }, {
                    key: "bandwidthEstimate",
                    get: function () {
                      return this.abrController.bwEstimator.getEstimate()
                    }
                  }, {
                    key: "autoLevelEnabled",
                    get: function () {
                      return -1 === this.levelController.manualLevel
                    }
                  }, {
                    key: "manualLevel",
                    get: function () {
                      return this.levelController.manualLevel
                    }
                  }, {
                    key: "minAutoLevel",
                    get: function () {
                      var t = this.levels,
                        e = this.config.minAutoBitrate;
                      if (!t) return 0;
                      for (var r = t.length, i = 0; i < r; i++)
                        if (t[i].maxBitrate > e) return i;
                      return 0
                    }
                  }, {
                    key: "maxAutoLevel",
                    get: function () {
                      var t = this.levels,
                        e = this.autoLevelCapping;
                      return -1 === e && t && t.length ? t.length - 1 : e
                    }
                  }, {
                    key: "nextAutoLevel",
                    get: function () {
                      return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel)
                    },
                    set: function (t) {
                      this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, t)
                    }
                  }, {
                    key: "audioTracks",
                    get: function () {
                      var t = this.audioTrackController;
                      return t ? t.audioTracks : []
                    }
                  }, {
                    key: "audioTrack",
                    get: function () {
                      var t = this.audioTrackController;
                      return t ? t.audioTrack : -1
                    },
                    set: function (t) {
                      var e = this.audioTrackController;
                      e && (e.audioTrack = t)
                    }
                  }, {
                    key: "subtitleTracks",
                    get: function () {
                      var t = this.subtitleTrackController;
                      return t ? t.subtitleTracks : []
                    }
                  }, {
                    key: "subtitleTrack",
                    get: function () {
                      var t = this.subtitleTrackController;
                      return t ? t.subtitleTrack : -1
                    },
                    set: function (t) {
                      var e = this.subtitleTrackController;
                      e && (e.subtitleTrack = t)
                    }
                  }, {
                    key: "progressive",
                    get: function () {
                      return this.config.progressive
                    },
                    set: function (t) {
                      ! function (t, e) {
                        var r = t.loader;
                        if (r !== Te && r !== le) return H.b.log("[config]: Custom loader detected, cannot enable progressive streaming"), t.progressive = !1;
                        e && we ? (t.loader = Te, t.progressive = !0, t.enableSoftwareAES = !0, H.b.log("[config]: Progressive streaming enabled, using FetchLoader")) : (t.loader = le, t.progressive = !1, H.b.log("[config]: Progressive streaming disabled, using XhrLoader"))
                      }(this.config, t)
                    }
                  }, {
                    key: "media",
                    get: function () {
                      return this._media
                    }
                  }, {
                    key: "subtitleDisplay",
                    get: function () {
                      var t = this.subtitleTrackController;
                      return !!t && t.subtitleDisplay
                    },
                    set: function (t) {
                      var e = this.subtitleTrackController;
                      e && (e.subtitleDisplay = t)
                    }
                  }, {
                    key: "isMildomLiveEnd",
                    get: function () {
                      return this._isMildomLiveEnd
                    },
                    set: function (t) {
                      this._isMildomLiveEnd = t
                    }
                  }, {
                    key: "lowLatencyMode",
                    get: function () {
                      return this.config.lowLatencyMode
                    },
                    set: function (t) {
                      this.config.lowLatencyMode = t
                    }
                  }, {
                    key: "liveSyncPosition",
                    get: function () {
                      return this.latencyController.liveSyncPosition
                    }
                  }, {
                    key: "latency",
                    get: function () {
                      return this.latencyController.latency
                    }
                  }, {
                    key: "maxLatency",
                    get: function () {
                      return this.latencyController.maxLatency
                    }
                  }, {
                    key: "targetLatency",
                    get: function () {
                      return this.latencyController.targetLatency
                    }
                  }, {
                    key: "isRunning",
                    set: function (t) {
                      this._isRunning = t
                    },
                    get: function () {
                      return this._isRunning
                    }
                  }]), c
                }();
                He.defaultConfig = void 0
              }]).default)
            })),
            _ = new(function () {
              function t() {
                s(this, t), u(this, "trace", [])
              }
              return o(t, [{
                key: "append",
                value: function (t) {
                  1e3 <= this.trace.length && this.trace.splice(0, 500), this.trace.push(t)
                }
              }, {
                key: "clear",
                value: function () {
                  this.trace = []
                }
              }]), t
            }());

          function L() {}
          var T, C = T = {
              trace: L,
              debug: L,
              log: L,
              warn: L,
              info: L,
              error: L
            },
            w = console;

          function x(t, e) {
            return e = "".concat((new Date).toISOString(), " | [").concat(t, "] > ").concat(e)
          }

          function P(i) {
            var n = w[i];
            return n ? function () {
              for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++) e[r] = arguments[r];
              e[0] = x(i, e[0]), _.append(e[0]), "1" === window.localStorage.hls_debug && (e[0] = x(i, e[0]), n.apply(w, e))
            } : L
          }
          var O, F, I = {
            trace: P("log"),
            debug: P("log"),
            log: P("log"),
            warn: P("warn"),
            info: P("log"),
            error: P("error")
          };
          ! function (e) {
            for (var t = arguments.length, r = new Array(1 < t ? t - 1 : 0), i = 1; i < t; i++) r[i - 1] = arguments[i];
            r.forEach(function (t) {
              C[t] = e[t] ? e[t].bind(e) : P(t)
            })
          }(I, "trace", "debug", "log", "info", "warn", "error");
          try {
            C.log()
          } catch (t) {
            C = T
          }

          function M(t, e, r) {
            try {
              if (t) {
                for (var i = t.buffered, n = [], a = 0; a < i.length; a += 1) n.push({
                  start: i.start(a),
                  end: i.end(a)
                });
                return function (t, e, r) {
                  var i, n, a, s, o, l = [];
                  for (t.sort(function (t, e) {
                      var r = t.start - e.start;
                      return r || e.end - t.end
                    }), o = 0; o < t.length; o += 1) {
                    var u, h = l.length;
                    h ? (u = l[h - 1].end, t[o].start - u < r ? t[o].end > u && (l[h - 1].end = t[o].end) : l.push(t[o])) : l.push(t[o])
                  }
                  for (i = o = 0, n = a = e; o < l.length; o += 1) {
                    var d = l[o].start,
                      c = l[o].end;
                    if (d <= e + r && e < c) n = d, i = (a = c) - e;
                    else if (e + r < d) {
                      s = d;
                      break
                    }
                  }
                  return {
                    len: i,
                    start: n,
                    end: a,
                    nextStart: s
                  }
                }(n, e, r)
              }
            } catch (t) {}
            return {
              len: 0,
              start: e,
              end: e,
              nextStart: void 0
            }
          }(nt = O = O || {}).INITIAL = "initial", nt.START = "start", nt.PLAYING = "playing", nt.PAUSED = "paused", nt.END = "end", nt.ERROR = "error", (X = F = F || {}).VIDEO_ATTACHED = "video_attached", X.AUTO_FORCE_MUTED = "auto_force_muted", X.AUTO_FORCE_PAUSED = "auto_force_paused", X.ERROR = "error", X.STALLED = "stalled", X.STALLED_RECOVER = "stalled_recover", X.STATUS_CHANGE = "status_change", X.FORCE_PAUSED = "force_paused", X.START = "start", X.SUCCESS = "success", X.DESTROY = "destroy", X.RESET = "reset";
          var N = function () {
              function e(t) {
                s(this, e), this.controller = t, u(this, "currentPlayStats", {
                  firstFrameData: {
                    startPlayTime: 0,
                    firstFrameShowTime: 0,
                    hlsManifestLoadCost: 0,
                    hlsLevelLoadCost: 0,
                    hlsTsLoadCost: 0
                  },
                  bufferSizes: []
                }), u(this, "watchInterval", void 0), u(this, "hlsFirstFrameManifestRequest", null), u(this, "hlsFirstFrameLevelRequest", null), u(this, "hlsFirstFrameTsRequest", null), this.watch = this.watch.bind(this), this.onStatusChange = this.onStatusChange.bind(this), this.onHlsManifestLoaded = this.onHlsManifestLoaded.bind(this), this.onHlsLevelLoaded = this.onHlsLevelLoaded.bind(this), this.onHlsFragLoaded = this.onHlsFragLoaded.bind(this), performance.addEventListener && performance.clearResourceTimings && performance.addEventListener("resourcetimingbufferfull", function () {
                  performance.clearResourceTimings()
                })
              }
              return o(e, [{
                key: "run",
                value: function () {
                  this.stop(), this.watchInterval = setInterval(this.watch, 1e3), this.controller.registerEvent(F.STATUS_CHANGE, this.onStatusChange), this.controller.registerHlsEvent(S.Events.MANIFEST_LOADED, this.onHlsManifestLoaded), this.controller.registerHlsEvent(S.Events.LEVEL_LOADED, this.onHlsLevelLoaded), this.controller.registerHlsEvent(S.Events.FRAG_LOADED, this.onHlsFragLoaded)
                }
              }, {
                key: "stop",
                value: function () {
                  this.resetStatsData(), this.hlsFirstFrameManifestRequest = null, this.hlsFirstFrameLevelRequest = null, this.hlsFirstFrameTsRequest = null, this.controller.unregisterEvent(F.STATUS_CHANGE, this.onStatusChange), this.controller.unregisterHlsEvent(S.Events.MANIFEST_LOADED, this.onHlsManifestLoaded), this.controller.unregisterHlsEvent(S.Events.LEVEL_LOADED, this.onHlsLevelLoaded), this.controller.unregisterHlsEvent(S.Events.FRAG_LOADED, this.onHlsFragLoaded), clearInterval(this.watchInterval)
                }
              }, {
                key: "onStatusChange",
                value: function (t) {
                  var e, r = t.status;
                  r === O.START ? this.currentPlayStats.firstFrameData.startPlayTime = performance.now() : r === O.PLAYING ? (e = this.hlsFirstFrameManifestRequest ? Math.round(this.hlsFirstFrameManifestRequest.responseEnd - this.hlsFirstFrameManifestRequest.fetchStart) : 0, t = this.hlsFirstFrameLevelRequest ? Math.round(this.hlsFirstFrameLevelRequest.responseEnd - this.hlsFirstFrameLevelRequest.fetchStart) : 0, r = this.hlsFirstFrameTsRequest ? Math.round(this.hlsFirstFrameTsRequest.responseEnd - this.hlsFirstFrameTsRequest.fetchStart) : 0, this.currentPlayStats.firstFrameData.hlsManifestLoadCost = e, this.currentPlayStats.firstFrameData.hlsLevelLoadCost = t, this.currentPlayStats.firstFrameData.hlsTsLoadCost = r, this.currentPlayStats.firstFrameData.firstFrameShowTime = performance.now(), console.log("[first_frame_tracker]: ", this.currentPlayStats.firstFrameData)) : this.resetStatsData()
                }
              }, {
                key: "watch",
                value: function () {
                  var t = null === (t = this.controller) || void 0 === t ? void 0 : t.videoDom;
                  this.currentPlayStats.bufferSizes.push(M(t, null == t ? void 0 : t.currentTime, .5))
                }
              }, {
                key: "onHlsManifestLoaded",
                value: function (t, e) {
                  var r = performance.getEntries().filter(function (t) {
                      return t.name.includes(e.url)
                    }),
                    r = r.length && r[0];
                  r && (this.hlsFirstFrameManifestRequest = r)
                }
              }, {
                key: "onHlsLevelLoaded",
                value: function (t, e) {
                  var r;
                  "auto" !== this.controller.config.definition || this.hlsFirstFrameLevelRequest || (r = (r = performance.getEntries().filter(function (t) {
                    return t.name.includes(e.details.url)
                  })).length && r[0]) && (this.hlsFirstFrameLevelRequest = r)
                }
              }, {
                key: "onHlsFragLoaded",
                value: function (t, e) {
                  var r;
                  this.hlsFirstFrameTsRequest || (r = (r = performance.getEntries().filter(function (t) {
                    return t.name.includes(e.networkDetails.responseURL)
                  })).length && r[0]) && (this.hlsFirstFrameTsRequest = r)
                }
              }, {
                key: "resetStatsData",
                value: function () {
                  this.currentPlayStats = {
                    firstFrameData: {
                      startPlayTime: 0,
                      firstFrameShowTime: 0
                    },
                    bufferSizes: []
                  }, this.hlsFirstFrameManifestRequest = null, this.hlsFirstFrameLevelRequest = null, this.hlsFirstFrameTsRequest = null
                }
              }]), e
            }(),
            U, B;

          function H(t, e, r) {
            try {
              if (t) {
                for (var i = t.buffered, n = [], a = 0; a < i.length; a += 1) n.push({
                  start: i.start(a),
                  end: i.end(a)
                });
                return function (t, e, r) {
                  var i, n, a, s, o, l = [];
                  for (t.sort(function (t, e) {
                      var r = t.start - e.start;
                      return r || e.end - t.end
                    }), o = 0; o < t.length; o += 1) {
                    var u, h = l.length;
                    h ? (u = l[h - 1].end, t[o].start - u < r ? t[o].end > u && (l[h - 1].end = t[o].end) : l.push(t[o])) : l.push(t[o])
                  }
                  for (i = o = 0, n = a = e; o < l.length; o += 1) {
                    var d = l[o].start,
                      c = l[o].end;
                    if (d <= e + r && e < c) n = d, i = (a = c) - e;
                    else if (e + r < d) {
                      s = d;
                      break
                    }
                  }
                  return {
                    len: i,
                    start: n,
                    end: a,
                    nextStart: s
                  }
                }(n, e, r)
              }
            } catch (t) {}
            return {
              len: 0,
              start: e,
              end: e,
              nextStart: void 0
            }
          }

          function G() {
            var t = -1 < window.navigator.userAgent.toLowerCase().indexOf("chrome"),
              e = -1 < window.navigator.userAgent.toLowerCase().indexOf("safari");
            return !t && e
          }(Q = U = U || {}).INITIAL = "initial", Q.START = "start", Q.PLAYING = "playing", Q.PAUSED = "paused", Q.END = "end", Q.ERROR = "error", (Z = B = B || {}).VIDEO_ATTACHED = "video_attached", Z.AUTO_FORCE_MUTED = "auto_force_muted", Z.AUTO_FORCE_PAUSED = "auto_force_paused", Z.ERROR = "error", Z.STALLED = "stalled", Z.STALLED_RECOVER = "stalled_recover", Z.STATUS_CHANGE = "status_change", Z.FORCE_PAUSED = "force_paused", Z.START = "start", Z.SUCCESS = "success", Z.DESTROY = "destroy", Z.RESET = "reset";
          var j = function () {
            function t() {
              s(this, t), u(this, "videoDom", void 0), u(this, "playStatus", U.INITIAL), u(this, "hls", void 0), u(this, "config", {
                src: "",
                lowLatencyMode: !1,
                realtimePlaybackMode: !1,
                vodMode: !1,
                startPosition: 0,
                hlsConfig: {}
              }), u(this, "retryPlayTimes", 0), u(this, "bufferEosData", null), u(this, "hlsAddonConfig", {}), u(this, "firstFrameTracker", void 0), u(this, "stallStartTime", 0), u(this, "stallDetectTimer", 0), u(this, "extra", {}), u(this, "eventListeners", new Map), u(this, "hlsEventListeners", new Map), u(this, "errorData", {}), u(this, "playbackRate", 1), this.play = this.play.bind(this), this.onHlsMediaAttach = this.onHlsMediaAttach.bind(this), this.onHlsLevelLoaded = this.onHlsLevelLoaded.bind(this), this.onHlsManifestParsed = this.onHlsManifestParsed.bind(this), this.onHlsError = this.onHlsError.bind(this), this.onHlsStallRecover = this.onHlsStallRecover.bind(this), this.onHlsBufferEos = this.onHlsBufferEos.bind(this), this.onNativePlay = this.onNativePlay.bind(this), this.onNativePause = this.onNativePause.bind(this), this.onNativeEnd = this.onNativeEnd.bind(this), this.firstFrameTracker = new N(this), this.recover = this.recover.bind(this)
            }
            return o(t, [{
              key: "setup",
              value: function (t) {
                this.config = l(l({}, this.config), t)
              }
            }, {
              key: "init",
              value: function (t) {
                var e, r, i, n, a = this;
                this.reset(), this.firstFrameTracker.run();
                var s = l(l({}, this.config), t),
                  t = {
                    enableWorker: !0,
                    mildomFragMaxParallelLoadNum: 1,
                    debug: I
                  },
                  t = this.config.vodMode ? l(l({}, t), {}, {
                    maxAudioFramesDrift: 999999,
                    startPosition: (s.startPosition || 0) / 1e3,
                    mildomFragMaxParallelLoadNum: 1
                  }) : this.config.realtimePlaybackMode ? l(l({}, t), {}, {
                    maxAudioFramesDrift: 999999,
                    startPosition: (s.startPosition || 0) / 1e3,
                    mildomRealtimePlaybackMode: !0
                  }) : s.lowLatencyMode ? l(l({}, t), {}, {
                    mildomLevelMaxReloadInterval: 500,
                    liveSyncDuration: void 0,
                    liveSyncDurationCount: 2,
                    progressive: !0,
                    lowLatencyMode: !0,
                    mildomSpeedMaxBufferSizeThreshold: 2e3,
                    mildomSpeedResetBufferSizeThreshold: 1e3
                  }) : l(l({}, t), {}, {
                    maxBufferLength: 60,
                    maxAudioFramesDrift: 999999,
                    forceKeyFrameOnDiscontinuity: !1,
                    skipBufferHole: !0,
                    autoStartLoad: !1,
                    mildomFragMaxParallelLoadNum: -1 < navigator.userAgent.toLowerCase().indexOf("firefox") ? 1 : 2,
                    mildomSpeedUpRate: 1.08,
                    mildomSpeedDownRate: .92,
                    mildomSpeedResetFactor: .2,
                    mildomSpeedMaxBufferSizeThreshold: 15e3,
                    mildomSpeedResetBufferSizeThreshold: 9e3,
                    mildomSpeedUpBufferGap: 8e3,
                    mildomSpeedResetBufferGap: 2e3
                  });
                t = l(l(l({}, t), s.hlsConfig), this.hlsAddonConfig);
                s = {};
                try {
                  var o = localStorage.getItem("configure");
                  o && (s = JSON.parse(o))
                } catch (t) {
                  console.log(t)
                }(null === s || void 0 === s || null === (e = s.body) || void 0 === e || null === (r = e.web_hls_config) || void 0 === r || !r.parallel_load_open_rate || Math.random() >= ((null === s || void 0 === s || null === (i = s.body) || void 0 === i || null === (n = i.web_hls_config) || void 0 === n ? void 0 : n.parallel_load_open_rate) || 0)) && (console.log("[player-controller]: downgrade frag load parallel number to 1"), t.mildomFragMaxParallelLoadNum = 1), this.extra.isParallelLoad = 1 < t.mildomFragMaxParallelLoadNum, console.log("[player-controller]: hlsConfig", t), this.hls = new S(t), this.hls.observer && this.hls.observer.setMaxListeners(200), this.hls.on(S.Events.MEDIA_ATTACHED, this.onHlsMediaAttach), this.hls.on(S.Events.LEVEL_LOADED, this.onHlsLevelLoaded), this.hls.on(S.Events.MANIFEST_PARSED, this.onHlsManifestParsed), this.hls.on(S.Events.ERROR, this.onHlsError), this.hls.on(S.Events.MILDOM_STALL_RECOVER, this.onHlsStallRecover), this.hls.on(S.Events.BUFFER_EOS, this.onHlsBufferEos), this.hlsEventListeners.forEach(function (t, e) {
                  t.forEach(function (t) {
                    a.hls.on(e, t)
                  })
                }), this.videoDom && (this.attachVideo(this.videoDom), this.videoDom.playbackRate = this.playbackRate)
              }
            }, {
              key: "reset",
              value: function () {
                var r = this;
                clearInterval(this.stallDetectTimer), _.clear(), this.hls && (this.hls.off(S.Events.MEDIA_ATTACHED, this.onHlsMediaAttach), this.hls.off(S.Events.LEVEL_LOADED, this.onHlsLevelLoaded), this.hls.off(S.Events.MANIFEST_PARSED, this.onHlsManifestParsed), this.hls.off(S.Events.ERROR, this.onHlsError), this.hls.off(S.Events.MILDOM_STALL_RECOVER, this.onHlsStallRecover), this.hls.off(S.Events.BUFFER_EOS, this.onHlsBufferEos), this.hlsEventListeners.forEach(function (t, e) {
                  t.forEach(function (t) {
                    r.hls.off(e, t)
                  })
                }), this.hls.stopLoad(), this.hls.detachMedia(), this.hls.destroy()), this.hls = null, this.bufferEosData = null, this.videoDom && (this.videoDom.removeEventListener("play", this.onNativePlay), this.videoDom.removeEventListener("pause", this.onNativePause), this.videoDom.removeEventListener("ended", this.onNativeEnd)), this.chagnePlayStatus(U.INITIAL), this.fireEventListener(B.RESET), this.firstFrameTracker.stop()
              }
            }, {
              key: "destroy",
              value: function () {
                this.reset(), this.config = {}, this.deattachVideo(), this.fireEventListener(B.DESTROY), this.eventListeners = new Map
              }
            }, {
              key: "play",
              value: function () {
                var t = this;
                this.checkStallError();
                var e = this.config.startPosition ? this.config.startPosition / 1e3 : -1;
                this.hls.startLoad(this.config.realtimePlaybackMode ? e : -1), this.chagnePlayStatus(U.START), this.fireEventListener(B.START), this.tryPlay().then(function () {
                  t.fireEventListener(B.SUCCESS), t.chagnePlayStatus(U.PLAYING)
                }).catch(function (t) {
                  console.warn("auto play failed, error: ", t)
                })
              }
            }, {
              key: "pause",
              value: function () {
                this.videoDom && (clearInterval(this.stallDetectTimer), this.stallStartTime = 0, this.videoDom.pause(), this.chagnePlayStatus(U.PAUSED)), this.hls && this.hls.stopLoad()
              }
            }, {
              key: "attachVideo",
              value: function (t) {
                t && (this.deattachVideo(), (this.videoDom = t).addEventListener("play", this.onNativePlay), t.addEventListener("pause", this.onNativePause), t.addEventListener("ended", this.onNativeEnd), this.hls && (this.hls.attachMedia(this.videoDom), this.play()), this.fireEventListener(B.VIDEO_ATTACHED, t))
              }
            }, {
              key: "deattachVideo",
              value: function () {
                this.videoDom && (this.videoDom.removeEventListener("play", this.onNativePlay), this.videoDom.removeEventListener("pause", this.onNativePause), this.videoDom.removeEventListener("ended", this.onNativeEnd)), this.videoDom = null
              }
            }, {
              key: "checkStallError",
              value: function () {
                var t = this;
                this.stallDetectTimer = setInterval(function () {
                  t.videoDom && H(t.videoDom, t.videoDom.currentTime, .5).len < .2 ? 0 === t.stallStartTime && (t.stallStartTime = performance.now()) : t.stallStartTime = 0, t.stallStartTime && 6e4 < performance.now() - t.stallStartTime && t.recover({
                    details: "unknow"
                  })
                }, 1e3)
              }
            }, {
              key: "onHlsMediaAttach",
              value: function () {
                this.hls.loadSource(this.config.src), this.setPlaybackRate(this.playbackRate)
              }
            }, {
              key: "onHlsError",
              value: function (t, e) {
                e.details === S.ErrorDetails.BUFFER_STALLED_ERROR && this.fireEventListener(B.STALLED), e.details === S.ErrorDetails.BUFFER_APPEND_MEDIA_ERROR && (this.hlsAddonConfig = {
                  skipDiscontinuity: !0
                }), (e.fatal || this.stallStartTime && 6e4 < performance.now() - this.stallStartTime && e.details === S.ErrorDetails.FRAG_LOAD_ERROR) && this.recover(e)
              }
            }, {
              key: "recover",
              value: function (t) {
                3 <= this.retryPlayTimes ? (this.pause(), this.reset(), this.fireEventListener(B.AUTO_FORCE_PAUSED), this.fireEventListener(B.ERROR, t), this.errorData = t, this.chagnePlayStatus(U.ERROR, t), this.retryPlayTimes = 0) : (this.retryPlayTimes += 1, this.playStatus !== U.START && this.playStatus !== U.PLAYING || this.init())
              }
            }, {
              key: "onHlsLevelLoaded",
              value: function (t, e) {
                this.hls.config.skipDiscontinuity || (this.hls.config.skipDiscontinuity = "cae" === e.details.defination && G())
              }
            }, {
              key: "onHlsManifestParsed",
              value: function (t) {
                var e;
                t && t.levels && (t = (e = t.levels).length % 2 == 0 ? e[Math.max(e.length / 2, 0)] : e[Math.floor(e.length / 2)], t = e.indexOf(t), this.hls.startLevel = -1 === t ? e.length - 1 : t), this.hls.startLoad()
              }
            }, {
              key: "onHlsStallRecover",
              value: function () {
                this.fireEventListener(B.STALLED_RECOVER)
              }
            }, {
              key: "onHlsBufferEos",
              value: function (t) {
                this.bufferEosData = t
              }
            }, {
              key: "onNativePlay",
              value: function () {
                this.playStatus !== U.START && this.playStatus !== U.PLAYING && this.chagnePlayStatus(U.PLAYING)
              }
            }, {
              key: "onNativePause",
              value: function () {
                this.playStatus !== U.PAUSED && null === this.bufferEosData && this.chagnePlayStatus(U.PAUSED)
              }
            }, {
              key: "onNativeEnd",
              value: function () {
                null !== this.bufferEosData && (clearInterval(this.stallDetectTimer), this.chagnePlayStatus(U.END, this.bufferEosData))
              }
            }, {
              key: "tryPlay",
              value: function () {
                var i = this;
                return new Promise(function (t, e) {
                  if (i.videoDom) try {
                    var r = i.videoDom.play();
                    r && r.then ? r.then(function () {
                      return t(!0)
                    }).catch(function (t) {
                      return "NotAllowedError" === t.name || "AbortError" === t.name && G() ? (i.setMuted(!0), i.fireEventListener(B.AUTO_FORCE_MUTED), i.play()) : void e(t)
                    }) : t(!1)
                  } catch (t) {
                    return i.setMuted(!0), i.fireEventListener(B.AUTO_FORCE_MUTED), i.play()
                  } else t(!0)
                })
              }
            }, {
              key: "registerEvent",
              value: function (t, e) {
                this.eventListeners.has(t) ? this.eventListeners.set(t, (this.eventListeners.get(t) || []).concat(e)) : this.eventListeners.set(t, [e])
              }
            }, {
              key: "unregisterEvent",
              value: function (t, e) {
                var r;
                this.eventListeners.has(t) && (r = (r = this.eventListeners.get(t) || []).filter(function (t) {
                  return t !== e
                }), this.eventListeners.set(t, r))
              }
            }, {
              key: "registerHlsEvent",
              value: function (t, e) {
                this.hlsEventListeners.has(t) ? this.hlsEventListeners.set(t, (this.hlsEventListeners.get(t) || []).concat(e)) : this.hlsEventListeners.set(t, [e]), this.hls && this.hls.on(t, e)
              }
            }, {
              key: "unregisterHlsEvent",
              value: function (t, e) {
                var r;
                this.hlsEventListeners.has(t) && (r = (r = this.hlsEventListeners.get(t) || []).filter(function (t) {
                  return t !== e
                }), this.hlsEventListeners.set(t, r), this.hls && this.hls.off(t, e))
              }
            }, {
              key: "fireEventListener",
              value: function (t, e) {
                this.eventListeners.has(t) && ((this.eventListeners.get(t) || []).forEach(function (t) {
                  t(e)
                }), console.log("[player-controller]: fire event ".concat(t)))
              }
            }, {
              key: "chagnePlayStatus",
              value: function (t) {
                var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
                  r = this.playStatus;
                r !== t && (console.log("[player-controller]: ".concat(r, " => ").concat(t)), this.playStatus = t, this.fireEventListener(B.STATUS_CHANGE, {
                  status: t,
                  prevStatus: r,
                  data: e
                }))
              }
            }, {
              key: "getLog",
              value: function () {
                return _.trace
              }
            }, {
              key: "setMuted",
              value: function (t) {
                this.videoDom && (this.videoDom.muted = t)
              }
            }, {
              key: "setVolume",
              value: function (t) {
                this.videoDom && (this.videoDom.volume = t)
              }
            }, {
              key: "setPlaybackRate",
              value: function (t) {
                this.videoDom && (this.playbackRate = t, this.videoDom.playbackRate = this.playbackRate)
              }
            }]), t
          }();

          function V(t) {
            var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {
                pixel: -1,
                cmode: "",
                name: ""
              },
              r = t.find(function (t) {
                return t.cmode === e.cmode
              });
            if (r) return r;
            var i = e.pixel;
            if (i <= 0 || 99999 === i || "auto" === e.cmode) {
              var n = t.find(function (t) {
                return "auto" === t.cmode
              });
              if (n) return n
            }
            if (!i && i <= 0 || 99999 === i) {
              n = t.find(function (t) {
                return t.cmode.includes("540")
              });
              return n ? n : (t.length % 2 == 0 ? t[Math.max(t.length / 2 - 1, 0)] : t[Math.floor(t.length / 2)]) || null
            }
            for (var a = -1, s = null, o = 0; o < t.length; o += 1) {
              var l = Math.abs(t[o].pixel - i);
              (l < a || -1 === a) && (s = t[o], a = l)
            }
            return s
          }

          function z(t, e, r) {
            var i = "";
            return i = 0 < t && r && e ? (i = (i = "".concat(e, "/").concat(t, "_").concat(r, ".m3u8")).replace("_raw", "")).replace("_auto", "_master") : i
          }
          u(j, "PlayerStatus", U), u(j, "PlayerEvent", B);
          var q, K, W = Object.freeze({
              __proto__: null,
              getDefaultDefinition: V,
              getHlsSource: z
            }),
            Y = function () {
              function n(t, e) {
                var r = e.initialDefinitionPixel,
                  e = e.autoDefinitionBlackList,
                  e = void 0 === e ? [] : e;
                s(this, n), u(this, "_core", void 0), u(this, "_fullscreenDom", void 0), u(this, "_focusDom", void 0), u(this, "_definitionList", []), u(this, "_definition", {
                  name: "",
                  cmode: "",
                  pixel: -1
                }), u(this, "_pipMode", !1), u(this, "_autoDefinitionBlackList", []), u(this, "_playbackRate", 1), u(this, "_fullscreen", !!document.fullscreenElement), u(this, "_focus", !0), u(this, "eventListeners", new Map), u(this, "mouseMoveTimer", void 0), this._core = t, this._autoDefinitionBlackList = e, this.grabFocus = this.grabFocus.bind(this), this.loseFocus = this.loseFocus.bind(this), this.syncExitFullscreen = this.syncExitFullscreen.bind(this), this.syncPipModeLeave = this.syncPipModeLeave.bind(this), this.onMouseMove = this.onMouseMove.bind(this), this.onHlsLevelSwitched = this.onHlsLevelSwitched.bind(this), this.onHlsCreated = this.onHlsCreated.bind(this), r && (this._definition.pixel = r), document.addEventListener("fullscreenchange", this.syncExitFullscreen);
                r = this._core.videoDom;
                r && r.addEventListener("leavepictureinpicture", this.syncPipModeLeave), this._core.registerEvent(j.PlayerEvent.START, this.onHlsCreated), this._core.hls && this._core.hls.on(S.Events.LEVEL_SWITCHED, this.onHlsLevelSwitched)
              }
              return o(n, [{
                key: "syncExitFullscreen",
                value: function () {
                  !document.fullscreenElement && this._fullscreen && (this._fullscreen = !1, this.fireEventListener(n.PlayerEvent.FULLSCREEN_CHANGED, this._fullscreen))
                }
              }, {
                key: "syncPipModeLeave",
                value: function () {
                  this._pipMode = !1, this.fireEventListener(n.PlayerEvent.PIP_MODE_CHANGED, this._pipMode)
                }
              }, {
                key: "destroy",
                value: function () {
                  this.reset(), this.core.destroy()
                }
              }, {
                key: "reset",
                value: function () {
                  document.removeEventListener("fullscreenchange", this.syncExitFullscreen), this._focusDom && (this._focusDom.removeEventListener("mouseenter", this.grabFocus), this._focusDom.removeEventListener("mouseleave", this.loseFocus), this._focusDom.removeEventListener("mousemove", this.onMouseMove));
                  var t = this._core.videoDom;
                  t && t.removeEventListener("leavepictureinpicture", this.syncPipModeLeave), this._core.unregisterEvent(j.PlayerEvent.START, this.onHlsCreated), this._core.hls && this._core.hls.off(S.Events.LEVEL_SWITCHED, this.onHlsLevelSwitched), this.core.reset()
                }
              }, {
                key: "setFullscreenDom",
                value: function (t) {
                  this._fullscreenDom = t
                }
              }, {
                key: "setFocusDom",
                value: function (t) {
                  this._focusDom && (this._focusDom.removeEventListener("mouseenter", this.grabFocus), this._focusDom.removeEventListener("mouseleave", this.loseFocus), this._focusDom.removeEventListener("mousemove", this.onMouseMove)), (this._focusDom = t) && (t.addEventListener("mouseenter", this.grabFocus), t.addEventListener("mouseleave", this.loseFocus), t.addEventListener("mousemove", this.onMouseMove))
                }
              }, {
                key: "core",
                get: function () {
                  return this._core
                }
              }, {
                key: "fullscreen",
                get: function () {
                  return this._fullscreen
                },
                set: function (t) {
                  var e, r = this;
                  null !== this._fullscreenDom && this._fullscreen !== t && (t ? (e = (e = this._fullscreenDom, (t = e.requestFullscreen || e.msRequestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullscreen) ? t.call(e) : Promise.reject(new Error("enter fullscreen failed")))) && e.then ? e.then(function () {
                    r._fullscreen = !0, r.fireEventListener(n.PlayerEvent.FULLSCREEN_CHANGED, r._fullscreen)
                  }) : (this._fullscreen = !0, this.fireEventListener(n.PlayerEvent.FULLSCREEN_CHANGED, this._fullscreen)) : (e = (e = (e = document).exitFullscreen || e.webkitExitFullscreen || e.mozCancelFullScreen || e.msExitFullscreen) ? e.call(document) : Promise.reject(new Error("exit fullscreen failed"))) && e.then ? e.then(function () {
                    r._fullscreen = !1, r.fireEventListener(n.PlayerEvent.FULLSCREEN_CHANGED, r._fullscreen)
                  }) : (this._fullscreen = !1, this.fireEventListener(n.PlayerEvent.FULLSCREEN_CHANGED, this._fullscreen)))
                }
              }, {
                key: "focus",
                get: function () {
                  return this._focus
                }
              }, {
                key: "grabFocus",
                value: function () {
                  this._focus || (this._focus = !0, this.fireEventListener(n.PlayerEvent.FOCUS_CHANGED, this._focus))
                }
              }, {
                key: "loseFocus",
                value: function () {
                  this._focus && (this._focus = !1, this.fireEventListener(n.PlayerEvent.FOCUS_CHANGED, this._focus))
                }
              }, {
                key: "definition",
                get: function () {
                  return this._definition
                },
                set: function (t) {
                  this._definition.cmode === t.cmode && this._definition.url === t.url || (this._definition = t, this.fireEventListener(n.PlayerEvent.DEFINTION_CHANGED, t), this.core.extra.definition = t, this.startPlay())
                }
              }, {
                key: "playbackRate",
                get: function () {
                  return this._playbackRate
                },
                set: function (t) {
                  t !== this._playbackRate && this._core.videoDom && (this._core.setPlaybackRate(t), this._playbackRate = t, this.fireEventListener(n.PlayerEvent.PLAYBACK_RATE_CHANGED, t))
                }
              }, {
                key: "pipMode",
                get: function () {
                  return this._pipMode
                },
                set: function (t) {
                  if (this._pipMode !== t) {
                    var e = this._core.videoDom;
                    if (e)
                      if (t) {
                        if (!e.requestPictureInPicture) return;
                        e.requestPictureInPicture()
                      } else {
                        e = document;
                        if (!e.exitPictureInPicture) return;
                        e.exitPictureInPicture(), this._core.playStatus === j.PlayerStatus.PLAYING && (this._core.config.vodMode ? this._core.play() : this._core.init())
                      }
                    this._pipMode = t, this.fireEventListener(n.PlayerEvent.PIP_MODE_CHANGED, t)
                  }
                }
              }, {
                key: "definitionList",
                get: function () {
                  return this._definitionList
                },
                set: function (r) {
                  var i = this;
                  this._definitionList = r, this._core.setup({
                    hlsConfig: l(l({}, this._core.config.hlsConfig), {}, {
                      mildomFilterLevels: function (t) {
                        if (t.length <= 1) return t;
                        var e = r.filter(function (t) {
                          return "audio" !== t.cmode && "auto" !== t.cmode && !i._autoDefinitionBlackList.includes(t.cmode)
                        }).map(function (t) {
                          return t.cmode
                        });
                        return t.filter(function (t) {
                          return e.length <= 0 ? t : e.includes(null === (t = t.attrs) || void 0 === t ? void 0 : t.CMODE)
                        })
                      }
                    })
                  }), this.fireEventListener(n.PlayerEvent.DEFINTION_LIST_CHANGED, r);
                  var t = V(r, this._definition);
                  this.definition = t || this._definition
                }
              }, {
                key: "registerEvent",
                value: function (t, e) {
                  this.eventListeners.has(t) ? this.eventListeners.set(t, (this.eventListeners.get(t) || []).concat(e)) : this.eventListeners.set(t, [e])
                }
              }, {
                key: "unregisterEvent",
                value: function (t, e) {
                  var r;
                  this.eventListeners.has(t) && (r = (r = this.eventListeners.get(t) || []).filter(function (t) {
                    return t !== e
                  }), this.eventListeners.set(t, r))
                }
              }, {
                key: "fireEventListener",
                value: function (t) {
                  for (var e = this, r = arguments.length, i = new Array(1 < r ? r - 1 : 0), n = 1; n < r; n++) i[n - 1] = arguments[n];
                  this.eventListeners.has(t) && (this.eventListeners.get(t) || []).forEach(function (t) {
                    t.apply(e, i)
                  })
                }
              }, {
                key: "getCurrentPlaySource",
                value: function () {
                  var t;
                  return null === (t = this._definition) || void 0 === t ? void 0 : t.url
                }
              }, {
                key: "onMouseMove",
                value: function () {
                  var t = this;
                  this._fullscreen && (this.grabFocus(), clearTimeout(this.mouseMoveTimer), this.mouseMoveTimer = setTimeout(function () {
                    t._fullscreen && t.loseFocus()
                  }, 2e3))
                }
              }, {
                key: "onHlsLevelSwitched",
                value: function (t, e) {
                  var e = e.level,
                    r = this._core.hls.levels[e];
                  "auto" !== this._definition.cmode || !r || (e = this._definitionList.find(function (t) {
                    var e;
                    return t.cmode === (null == r || null === (e = r.attrs) || void 0 === e ? void 0 : e.CMODE)
                  })) && (this._definition.pixel = e.pixel, this.fireEventListener(n.PlayerEvent.AUTO_DEFINTION_SWITCHED, e))
                }
              }, {
                key: "onHlsCreated",
                value: function () {
                  this._core.hls.off(S.Events.LEVEL_SWITCHED, this.onHlsLevelSwitched), this._core.hls.on(S.Events.LEVEL_SWITCHED, this.onHlsLevelSwitched)
                }
              }, {
                key: "startPlay",
                value: function () {
                  var t, e = this.getCurrentPlaySource();
                  !e || this._core.config.src === e && [j.PlayerStatus.START, j.PlayerStatus.PAUSED, j.PlayerStatus.PLAYING].includes(this._core.playStatus) || (t = this._core.videoDom, this._core.config.vodMode && t ? this._core.setup({
                    src: e,
                    startPosition: 1e3 * t.currentTime
                  }) : this._core.setup({
                    src: e
                  }), this._core.setPlaybackRate(this._playbackRate), this._core.init())
                }
              }]), n
            }();
          u(Y, "PlayerEvent", {
            DEFINTION_CHANGED: "defintion_change",
            AUTO_DEFINTION_SWITCHED: "auto_defintion_switched",
            DEFINTION_LIST_CHANGED: "defintion_list_change",
            FULLSCREEN_CHANGED: "fullscreen_change",
            FOCUS_CHANGED: "focus_change",
            PIP_MODE_CHANGED: "pip_mode_changed",
            PLAYBACK_RATE_CHANGED: "playback_rate_changed"
          }), (T = q = q || {}).LEFT = "left", T.RIGHT = "right", T.TOP = "top", (nt = K = K || {}).HLS = "hls", nt.LHLS = "lhls";
          var X = function () {
            h(n, Y);
            var r = c(n);

            function n(t, e) {
              s(this, n), u(d(t = r.call(this, t, e)), "_roomId", 0), u(d(t), "_streamServerList", []), u(d(t), "_currentStreamServerList", []), u(d(t), "_currentStreamServer", {
                url: "",
                groupId: "",
                index: 0,
                protocol: K.HLS
              }), u(d(t), "_lowLatencyMode", !1), u(d(t), "_realtimePlaybackMode", !1), u(d(t), "_currentPlayTime", 0), u(d(t), "_duration", 0), u(d(t), "_countLiveDurationTimer", void 0), u(d(t), "_liveDefitionList", []), u(d(t), "_realtimePlaybackDefinitionList", []), u(d(t), "liveStartTime", void 0), t.onVideoTimeUpdate = t.onVideoTimeUpdate.bind(d(t)), t.countLiveDuration = t.countLiveDuration.bind(d(t));
              e = t._core.videoDom;
              return e && t.realtimePlaybackMode && e.addEventListener("timeupdate", t.onVideoTimeUpdate), t
            }
            return o(n, [{
              key: "reset",
              value: function () {
                f(a(n.prototype), "reset", this).call(this);
                var t = this._core.videoDom;
                t && t.removeEventListener("timeupdate", this.onVideoTimeUpdate), clearInterval(this._countLiveDurationTimer)
              }
            }, {
              key: "destroyWithoutDeattach",
              value: function () {
                this.reset(), this.core.config = {}, this.core.extra = {}
              }
            }, {
              key: "getCurrentPlaySource",
              value: function () {
                return this.realtimePlaybackMode && this._definition.url ? this._definition.url : z(this.roomId, this._currentStreamServer.url, this._definition.cmode)
              }
            }, {
              key: "roomId",
              get: function () {
                return this._roomId
              },
              set: function (t) {
                this._roomId !== t && (this._roomId = t, this.startPlay())
              }
            }, {
              key: "realtimePlaybackMode",
              get: function () {
                return this._realtimePlaybackMode
              },
              set: function (t) {
                var e;
                this._realtimePlaybackMode !== t && (this._realtimePlaybackMode = t, this._core.setup({
                  realtimePlaybackMode: t
                }), (e = this._core.videoDom) && (this.playbackRate = 1, e.removeEventListener("timeupdate", this.onVideoTimeUpdate), t ? (e.addEventListener("timeupdate", this.onVideoTimeUpdate), this.definitionList = this._realtimePlaybackDefinitionList) : this.definitionList = this._liveDefitionList), this.pipMode = !1, this.fireEventListener(n.PlayerEvent.REALTIME_PLAYBACK_MODE_CHANGED, t))
              }
            }, {
              key: "duration",
              get: function () {
                return this._duration
              }
            }, {
              key: "updateDuration",
              value: function (t) {
                this._duration = t, this.fireEventListener(n.PlayerEvent.DURATION_CHANGED, t), this._realtimePlaybackMode || this.updateCurrentPlayTime(t)
              }
            }, {
              key: "currentPlayTime",
              get: function () {
                return this._currentPlayTime
              }
            }, {
              key: "updateCurrentPlayTime",
              value: function (t) {
                this._currentPlayTime = t, this.fireEventListener(n.PlayerEvent.CURRENT_PLAY_TIME_CHANGED, t), this._realtimePlaybackMode ? this._core.setup({
                  startPosition: t
                }) : this._core.setup({
                  startPosition: 0
                })
              }
            }, {
              key: "streamServerList",
              get: function () {
                return this._streamServerList
              },
              set: function (t) {
                var e = this;
                this._streamServerList = t, this.currentStreamServerList = t.filter(function (t) {
                  return e._lowLatencyMode ? t.protocol === K.LHLS : t.protocol === K.HLS
                }).sort(function (t, e) {
                  return t.index - e.index
                })
              }
            }, {
              key: "currentStreamServerList",
              get: function () {
                return this._currentStreamServerList
              },
              set: function (t) {
                var e = this;
                this._currentStreamServerList = t, this.fireEventListener(n.PlayerEvent.STREAM_SERVER_LIST_CHANGED, this._currentStreamServerList), 0 < this._currentStreamServerList.length && (this._currentStreamServerList.find(function (t) {
                  return t.url === e._currentStreamServer.url
                }) || (t = k(this._currentStreamServerList, 1), this.currentStreamServer = t[0]))
              }
            }, {
              key: "currentStreamServer",
              get: function () {
                return this._currentStreamServer
              },
              set: function (t) {
                var e;
                this._currentStreamServer.url !== t.url && (e = this._currentStreamServer, this._currentStreamServer = t, this.fireEventListener(n.PlayerEvent.STREAM_SERVER_CHANGED, t), e.protocol === t.protocol && this.startPlay())
              }
            }, {
              key: "lowLatencyMode",
              get: function () {
                return this._lowLatencyMode
              },
              set: function (t) {
                var e, r, i = this;
                this._lowLatencyMode !== t && (this._lowLatencyMode = t, this.fireEventListener(n.PlayerEvent.LOW_LATENCY_MODE_CHANGED, t), this._core.setup({
                  lowLatencyMode: this._lowLatencyMode
                }), this.currentStreamServerList = this._streamServerList.filter(function (t) {
                  return i._lowLatencyMode ? t.protocol === K.LHLS : t.protocol === K.HLS
                }).sort(function (t, e) {
                  return t.index - e.index
                }), "auto" === this._definition.cmode ? (t = this._core.hls.levels[this._core.hls.nextLoadLevel], e = null == t || null === (r = t.attrs) || void 0 === r ? void 0 : r.CMODE, (r = this._definitionList.find(function (t) {
                  return t.cmode === e
                })) ? this.definition = r : 0 < this._definitionList.length && (r = k(this._definitionList.filter(function (t) {
                  return "auto" !== t.cmode
                }), 1), this.definition = r[0])) : (this._core.setup({
                  src: this.getCurrentPlaySource()
                }), this._core.init()))
              }
            }, {
              key: "streamServer",
              get: function () {
                return this._lowLatencyMode
              },
              set: function (t) {
                this._lowLatencyMode !== t && (this._lowLatencyMode = t, this.fireEventListener(n.PlayerEvent.LOW_LATENCY_MODE_CHANGED, t))
              }
            }, {
              key: "onVideoTimeUpdate",
              value: function (t) {
                this.realtimePlaybackMode && this.updateCurrentPlayTime(1e3 * t.target.currentTime || 0)
              }
            }, {
              key: "countLiveDuration",
              value: function () {
                this.updateDuration(this._duration + 1e3)
              }
            }, {
              key: "setLiveStartTime",
              value: function (t) {
                t <= 0 || t === this.liveStartTime || (this.liveStartTime = t, this.updateDuration(Date.now() - t), clearInterval(this._countLiveDurationTimer), this._countLiveDurationTimer = setInterval(this.countLiveDuration, 1e3))
              }
            }, {
              key: "setLiveDefinitionList",
              value: function (t) {
                this._liveDefitionList = t, this._realtimePlaybackMode || (this.definitionList = t)
              }
            }, {
              key: "setRealtimePlaybackDefinitionList",
              value: function (t) {
                this._realtimePlaybackDefinitionList = t, this._realtimePlaybackMode && (this.definitionList = t)
              }
            }, {
              key: "seek",
              value: function (t) {
                this._duration - t <= 5e3 ? this.realtimePlaybackMode = !1 : (this._core.config.startPosition = t, this.realtimePlaybackMode = !0, this._core.videoDom && (this._core.videoDom.currentTime = t / 1e3), this.updateCurrentPlayTime(t)), this.fireEventListener(n.PlayerEvent.ON_SEEK)
              }
            }]), n
          }();
          u(X, "PlayerEvent", l(l({}, Y.PlayerEvent), {}, {
            LOW_LATENCY_MODE_CHANGED: "low_latency_mode_change",
            STREAM_SERVER_LIST_CHANGED: "stream_server_list_changed",
            STREAM_SERVER_CHANGED: "stream_server_changed",
            REALTIME_PLAYBACK_MODE_CHANGED: "realtime_playback_mode_changed",
            CURRENT_PLAY_TIME_CHANGED: "current_play_time_changed",
            DURATION_CHANGED: "duration_changed",
            ON_SEEK: "on_seek"
          }));
          var $, Q = {
              PlayerController: j,
              LivePlayerController: X,
              CommonPlayerController: Y
            },
            J = e.default.div(g(["\n  align-items: center;\n  display: flex;\n  flex-direction: column;\n\n  transition: opacity 0.5s;\n  ", "\n  .layout-top {\n    width: 100%;\n  }\n  .layout-bottom {\n    background: rgba(0, 0, 0, 0.6);\n    align-items: center;\n    display: flex;\n    height: 48px;\n    width: 100%;\n    padding-left: 18px;\n    .layout-left {\n      display: flex;\n      height: 100%;\n    }\n    .layout-right {\n      height: 100%;\n      margin-left: auto;\n      display: flex;\n      align-items: center;\n    }\n  }\n"]), function (t) {
              t = t.visible;
              return R.css($ = $ || g(["\n    opacity: ", ";\n  "]), t ? 1 : 0)
            }),
            Z = {
              ControlBar: function (t) {
                var e = t.visible,
                  r = void 0 === e || e,
                  i = t.controls,
                  n = t.style,
                  a = i.filter(function (t) {
                    return "left" === t.position
                  }).sort(function (t, e) {
                    return t.sort - e.sort
                  }).map(function (t) {
                    return D.default.cloneElement(t.render(), {
                      key: t.id
                    })
                  }),
                  e = i.filter(function (t) {
                    return "right" === t.position
                  }).sort(function (t, e) {
                    return t.sort - e.sort
                  }).map(function (t) {
                    return D.default.cloneElement(t.render(), {
                      key: t.id
                    })
                  }),
                  t = i.filter(function (t) {
                    return "top" === t.position
                  }).sort(function (t, e) {
                    return t.sort - e.sort
                  }).map(function (t) {
                    return D.default.cloneElement(t.render(), {
                      key: t.id
                    })
                  }),
                  i = A.useCallback(function (t) {
                    t && t.stopPropagation && t.stopPropagation()
                  }, []);
                return D.default.createElement(J, {
                  visible: r,
                  onDoubleClick: i
                }, D.default.createElement("div", {
                  className: "layout-top"
                }, t), D.default.createElement("div", {
                  className: "layout-bottom",
                  style: n
                }, D.default.createElement("div", {
                  className: "layout-left"
                }, a), D.default.createElement("div", {
                  className: "layout-right"
                }, e)))
              }
            },
            T = {
              useControllerState: function (t) {
                var e = t.controller,
                  r = t.property,
                  i = t.propertyDefaultValue,
                  n = t.propertyChangeEvent,
                  a = t.propertyChangeEventDataHandle,
                  t = k(A.useState(e ? e[r] : i), 2),
                  i = t[0],
                  s = t[1];
                return A.useEffect(function () {
                  if (e) {
                    s(e[r]);
                    var t = function () {
                      var t = arguments.length <= 0 ? void 0 : arguments[0];
                      a && (t = a.apply(void 0, arguments)), s(t)
                    };
                    return e.registerEvent(n, t),
                      function () {
                        e.unregisterEvent(n, t)
                      }
                  }
                }, [e, r, n, a]), i
              }
            },
            tt = function () {
              function e(t) {
                s(this, e), u(this, "playerController", void 0), u(this, "dataArray", []), this.playerController = t
              }
              return o(e, [{
                key: "statisticData",
                value: function (t) {
                  if (0 < t.length) {
                    t.sort(function (t, e) {
                      return t - e
                    });
                    var e = t.reduce(function (t, e) {
                      return Math.abs(t) + Math.abs(e)
                    }) / t.length;
                    return {
                      min: t[0],
                      avg: e,
                      max: t[t.length - 1]
                    }
                  }
                  return null
                }
              }, {
                key: "popData",
                value: function () {
                  var t = this.statisticData(this.dataArray);
                  return this.clear(), t
                }
              }, {
                key: "clear",
                value: function () {
                  this.dataArray = []
                }
              }, {
                key: "getLatestData",
                value: function () {
                  return this.dataArray.length && this.dataArray[this.dataArray.length - 1]
                }
              }, {
                key: "collectData",
                value: function (t) {
                  this.dataArray.push(t)
                }
              }]), e
            }(),
            et = function () {
              h(r, tt);
              var e = c(r);

              function r(t) {
                return s(this, r), (t = e.call(this, t)).onHlsFragBuffered = t.onHlsFragBuffered.bind(d(t)), t
              }
              return o(r, [{
                key: "run",
                value: function () {
                  var t;
                  this.playerController && null !== (t = this.playerController.hls) && void 0 !== t && t.on(S.Events.FRAG_BUFFERED, this.onHlsFragBuffered)
                }
              }, {
                key: "destroy",
                value: function () {
                  var t;
                  this.playerController && null !== (t = this.playerController.hls) && void 0 !== t && t.off(S.Events.FRAG_BUFFERED, this.onHlsFragBuffered)
                }
              }, {
                key: "onHlsFragBuffered",
                value: function () {
                  var t;
                  this.playerController && this.playerController.hls && this.playerController.hls.streamController && this.playerController.hls.streamController.fragmentTracker && ((t = Object.values(this.playerController.hls.streamController.fragmentTracker.fragments)).length <= 0 || (t = t[t.length - 1]).range && t.range.audio && 0 < t.range.audio.time.length && t.range.video && 0 < t.range.video.time.length && (t = t.range.audio.time[0].endPTS - t.range.audio.time[0].startPTS - (t.range.video.time[0].endPTS - t.range.video.time[0].startPTS), this.collectData(t)))
                }
              }]), r
            }(),
            rt = function () {
              h(a, tt);
              var n = c(a);

              function a() {
                var t;
                s(this, a);
                for (var e = arguments.length, r = new Array(e), i = 0; i < e; i++) r[i] = arguments[i];
                return u(d(t = n.call.apply(n, [this].concat(r))), "timer", 0), t
              }
              return o(a, [{
                key: "run",
                value: function () {
                  var r = this;
                  this.timer = window.setInterval(function () {
                    var t, e;
                    r.collectData(Number(M(r.playerController.videoDom, null === (t = r.playerController) || void 0 === t || null === (e = t.videoDom) || void 0 === e ? void 0 : e.currentTime, .5).len.toFixed(2)))
                  }, 1e3)
                }
              }, {
                key: "destroy",
                value: function () {
                  clearInterval(this.timer)
                }
              }]), a
            }(),
            it = function () {
              h(i, tt);
              var r = c(i);

              function i(t) {
                var e;
                return s(this, i), u(d(e = r.call(this, t)), "timer", 0), e.playerController = t, e.calculateFps = e.calculateFps.bind(d(e)), e.onPlayStatusChange = e.onPlayStatusChange.bind(d(e)), e
              }
              return o(i, [{
                key: "run",
                value: function () {
                  var t, e;
                  null !== (t = this.playerController) && void 0 !== t && null !== (e = t.videoDom) && void 0 !== e && e.getVideoPlaybackQuality && (this.calculateFps(), this.playerController.registerEvent(B.STATUS_CHANGE, this.onPlayStatusChange))
                }
              }, {
                key: "destroy",
                value: function () {
                  clearInterval(this.timer), this.playerController.unregisterEvent(B.STATUS_CHANGE, this.onPlayStatusChange)
                }
              }, {
                key: "calculateFps",
                value: function () {
                  var t, e = this,
                    r = this.playerController.videoDom;
                  r && (t = r.getVideoPlaybackQuality().totalVideoFrames, this.timer = window.setInterval(function () {
                    e.collectData(r.getVideoPlaybackQuality().totalVideoFrames - t), t = r.getVideoPlaybackQuality().totalVideoFrames
                  }, 1e3))
                }
              }, {
                key: "onPlayStatusChange",
                value: function (t) {
                  t.status === U.PLAYING ? this.calculateFps() : clearInterval(this.timer)
                }
              }]), i
            }(),
            nt = function () {
              h(i, tt);
              var e = c(i);

              function i(t) {
                var r;
                return s(this, i), u(d(r = e.call(this, t)), "onHlsFragBuffered", function (t, e) {
                  r.collectData(Math.round(e.stats.bwEstimate / 1024))
                }), r.onHlsFragBuffered = r.onHlsFragBuffered.bind(d(r)), r
              }
              return o(i, [{
                key: "run",
                value: function () {
                  var t;
                  this.playerController && null !== (t = this.playerController.hls) && void 0 !== t && t.on(S.Events.FRAG_BUFFERED, this.onHlsFragBuffered)
                }
              }, {
                key: "destroy",
                value: function () {
                  var t;
                  this.playerController && null !== (t = this.playerController.hls) && void 0 !== t && t.off(S.Events.FRAG_BUFFERED, this.onHlsFragBuffered)
                }
              }]), i
            }(),
            at = function () {
              h(r, tt);
              var e = c(r);

              function r(t) {
                return s(this, r), (t = e.call(this, t)).onLevelLoaded = t.onLevelLoaded.bind(d(t)), t
              }
              return o(r, [{
                key: "run",
                value: function () {
                  var t;
                  this.playerController && null !== (t = this.playerController.hls) && void 0 !== t && t.on(S.Events.LEVEL_LOADED, this.onLevelLoaded)
                }
              }, {
                key: "destroy",
                value: function () {
                  var t;
                  this.playerController && null !== (t = this.playerController.hls) && void 0 !== t && t.off(S.Events.LEVEL_LOADED, this.onLevelLoaded)
                }
              }, {
                key: "onLevelLoaded",
                value: function (t, e) {
                  var r, i = e.details;
                  i && i.fragments && i.live && (r = i.fragments[i.fragments.length - 1], e = this.playerController.videoDom, i = r.programDateTime, e && this.collectData(Number((r.start - e.currentTime + (Date.now() - i) / 1e3).toFixed(2))))
                }
              }]), r
            }(),
            st = function () {
              h(i, tt);
              var r = c(i);

              function i(t) {
                var e;
                return s(this, i), u(d(e = r.call(this, t)), "stallStartTime", 0), u(d(e), "catonTime", 0), u(d(e), "catonCount", 0), u(d(e), "touchStallRecover", !0), e.playerController = t, e.onPlayStalled = e.onPlayStalled.bind(d(e)), e.onStallRecover = e.onStallRecover.bind(d(e)), e
              }
              return o(i, [{
                key: "run",
                value: function () {
                  this.playerController.registerEvent(B.STALLED, this.onPlayStalled), this.playerController.registerEvent(B.STALLED_RECOVER, this.onStallRecover)
                }
              }, {
                key: "destroy",
                value: function () {
                  this.playerController.unregisterEvent(B.STALLED, this.onPlayStalled), this.playerController.unregisterEvent(B.STALLED_RECOVER, this.onStallRecover)
                }
              }, {
                key: "onPlayStalled",
                value: function () {
                  0 === this.stallStartTime && (this.touchStallRecover = !1, this.stallStartTime = performance.now(), this.catonCount += 1)
                }
              }, {
                key: "onStallRecover",
                value: function () {
                  var t;
                  0 < this.stallStartTime && (this.touchStallRecover = !0, t = performance.now() - this.stallStartTime, this.catonTime += t, this.stallStartTime = 0)
                }
              }, {
                key: "popData",
                value: function () {
                  this.touchStallRecover ? this.stallStartTime = 0 : (this.onStallRecover(), this.stallStartTime = performance.now());
                  var t = {
                    catonTime: this.catonTime,
                    catonCount: this.catonCount
                  };
                  return this.clear(), t
                }
              }, {
                key: "clear",
                value: function () {
                  this.catonTime = 0, this.catonCount = 0
                }
              }]), i
            }(),
            X = l(l({}, W), {}, {
              PlayerData: {
                Avdiff: et,
                BufferSize: rt,
                Fps: it,
                NetSpeed: nt,
                Latency: at,
                CatonTime: st
              }
            });

          function ot(t, e, r) {
            return t ? r(t, e) : e
          }
          var lt, ut = function () {
            function e(t) {
              s(this, e), this.controller = t, u(this, "fragStatisticData", {
                frag_min_latency: 0,
                frag_max_latency: 0,
                frag_avg_latency: 0,
                frag_min_load: 0,
                frag_max_load: 0,
                frag_avg_load: 0,
                frag_min_process: 0,
                frag_max_process: 0,
                frag_avg_process: 0,
                min_net_speed: 0,
                max_net_speed: 0,
                avg_net_speed: 0,
                frag_min_duration: 0,
                frag_max_duration: 0,
                frag_avg_duration: 0,
                frag_min_size: 0,
                frag_max_size: 0,
                frag_avg_size: 0,
                frag_num: 0,
                frag_bitrate: 0
              }), u(this, "fragSources", []), u(this, "m3u8StatisticData", {
                m3u8_update_time: "",
                min_m3u8_latency: 0,
                max_m3u8_latency: 0,
                avg_m3u8_latency: 0,
                m3u8_num: 0
              }), u(this, "lastLevelUpdateTime", 0), u(this, "notUpdateLevelCount", 0), u(this, "levelLoadErrorCount", 0), u(this, "levelLoadTimeoutCount", 0), u(this, "levelUpdateInterval", []), u(this, "m3u8Sources", []), u(this, "currentM3u8Details", {}), this.onLevelLoaded = this.onLevelLoaded.bind(this), this.onFragLoaded = this.onFragLoaded.bind(this), this.onHlsError = this.onHlsError.bind(this)
            }
            return o(e, [{
              key: "run",
              value: function () {
                this.controller.hls && (this.controller.hls.on(S.Events.FRAG_LOADED, this.onFragLoaded), this.controller.hls.on(S.Events.LEVEL_LOADED, this.onLevelLoaded), this.controller.hls.on(S.Events.ERROR, this.onHlsError))
              }
            }, {
              key: "stop",
              value: function () {
                this.controller.hls && (this.controller.hls.off(S.Events.FRAG_LOADED, this.onFragLoaded), this.controller.hls.off(S.Events.LEVEL_LOADED, this.onLevelLoaded), this.controller.hls.off(S.Events.ERROR, this.onHlsError)), this.resetAnalyze(), this.fragStatisticData = {
                  frag_min_latency: 0,
                  frag_max_latency: 0,
                  frag_avg_latency: 0,
                  frag_min_load: 0,
                  frag_max_load: 0,
                  frag_avg_load: 0,
                  frag_min_process: 0,
                  frag_max_process: 0,
                  frag_avg_process: 0,
                  min_net_speed: 0,
                  max_net_speed: 0,
                  avg_net_speed: 0,
                  frag_min_duration: 0,
                  frag_max_duration: 0,
                  frag_avg_duration: 0,
                  frag_min_size: 0,
                  frag_max_size: 0,
                  frag_avg_size: 0,
                  frag_num: 0,
                  frag_bitrate: 0
                }, this.m3u8StatisticData = {
                  m3u8_update_time: "",
                  min_m3u8_latency: 0,
                  max_m3u8_latency: 0,
                  avg_m3u8_latency: 0,
                  m3u8_num: 0
                }
              }
            }, {
              key: "popData",
              value: function () {
                var t = 0 === this.fragStatisticData.frag_num ? {} : this.fragStatisticData,
                  e = 0 === this.m3u8StatisticData.m3u8_num ? {} : this.m3u8StatisticData;
                return l(l({}, t), e)
              }
            }, {
              key: "onHlsError",
              value: function (t, e) {
                e.details === S.ErrorDetails.LEVEL_LOAD_TIMEOUT && (this.levelLoadTimeoutCount += 1), e.details === S.ErrorDetails.LEVEL_LOAD_ERROR && (this.levelLoadErrorCount += 1)
              }
            }, {
              key: "onLevelLoaded",
              value: function (t, e) {
                var r, i = e.details;
                this.lastLevelUpdateTime || (this.lastLevelUpdateTime = Date.now()), this.currentM3u8Details && i.endSN !== this.currentM3u8Details.endSN ? (r = Date.now() - this.lastLevelUpdateTime, this.lastLevelUpdateTime = Date.now(), this.levelUpdateInterval.push({
                  updateInterval: r,
                  notUpdateLevelCount: this.notUpdateLevelCount,
                  lastSn: this.currentM3u8Details.endSN,
                  newSn: i.endSN,
                  levelLoadErrorCount: this.levelLoadErrorCount,
                  levelLoadTimeoutCount: this.levelLoadTimeoutCount
                }), this.levelUpdateInterval.sort(function (t, e) {
                  return e.updateInterval - t.updateInterval
                }), this.notUpdateLevelCount = 0, this.levelLoadErrorCount = 0, this.levelLoadTimeoutCount = 0) : this.currentM3u8Details && i.endSN === this.currentM3u8Details.endSN && (this.notUpdateLevelCount += 1), this.currentM3u8Details = i, this.m3u8Sources.push({
                  latency: e.stats.loading.start - e.stats.loading.end
                }), this.analyzeM3u8Data()
              }
            }, {
              key: "onFragLoaded",
              value: function (t, e) {
                e = {
                  fragLatency: e.frag.stats.start - e.frag.stats.first,
                  fragLoad: e.frag.stats.end - e.frag.stats.first,
                  fragProcess: e.frag.stats.parsing.start - e.frag.stats.parsing.end,
                  fragSize: e.frag.stats.total / 1e3,
                  fragDuration: e.frag.duration || 0,
                  netspeed: Math.round(8 * e.frag.stats.total / (e.frag.stats.loading.end - e.frag.stats.loading.start))
                };
                this.fragSources.push(e), this.analyzeFragData(e)
              }
            }, {
              key: "analyzeFragData",
              value: function (t) {
                var e = this.fragSources.reduce(function (t, e) {
                    return {
                      sumFragSize: t.sumFragSize + e.fragSize,
                      sumFragDuration: t.sumFragDuration + e.fragDuration,
                      sumFragLatency: t.sumFragLatency + e.fragLatency,
                      sumFragLoad: t.sumFragLoad + e.fragLoad,
                      sumFragProcess: t.sumFragProcess + e.fragProcess,
                      sumNetspeed: t.sumNetspeed + e.netspeed
                    }
                  }, {
                    sumFragDuration: 0,
                    sumFragSize: 0,
                    sumFragLatency: 0,
                    sumFragLoad: 0,
                    sumFragProcess: 0,
                    sumNetspeed: 0
                  }),
                  r = e.sumFragSize,
                  i = e.sumFragDuration,
                  n = e.sumFragLatency,
                  a = e.sumFragLoad,
                  s = e.sumFragProcess,
                  o = e.sumNetspeed,
                  e = this.fragSources.length;
                this.fragStatisticData = Object.assign(this.fragStatisticData, {
                  frag_num: e,
                  frag_min_latency: ot(this.fragStatisticData.frag_min_latency, t.fragLatency, Math.min),
                  frag_max_latency: ot(this.fragStatisticData.frag_max_latency, t.fragLatency, Math.max),
                  frag_avg_latency: Math.round(n / e),
                  frag_min_load: ot(this.fragStatisticData.frag_min_load, t.fragLoad, Math.min),
                  frag_max_load: ot(this.fragStatisticData.frag_max_latency, t.fragLoad, Math.max),
                  frag_avg_load: Math.round(a / e),
                  frag_min_process: ot(this.fragStatisticData.frag_min_process, t.fragProcess, Math.min),
                  frag_max_process: ot(this.fragStatisticData.frag_max_process, t.fragProcess, Math.max),
                  frag_avg_process: Math.round(s / e),
                  min_net_speed: ot(this.fragStatisticData.min_net_speed, t.netspeed, Math.min),
                  max_net_speed: ot(this.fragStatisticData.max_net_speed, t.netspeed, Math.max),
                  avg_net_speed: Math.round(o / e),
                  frag_min_size: ot(this.fragStatisticData.frag_min_size, t.fragSize, Math.min),
                  frag_max_size: ot(this.fragStatisticData.frag_max_size, t.fragSize, Math.max),
                  frag_avg_size: Math.round(r / e),
                  frag_min_duration: ot(this.fragStatisticData.frag_min_duration, t.fragDuration, Math.min).toFixed(2),
                  frag_max_duration: ot(this.fragStatisticData.frag_max_duration, t.fragDuration, Math.max).toFixed(2),
                  frag_avg_duration: (i / e).toFixed(2),
                  frag_bitrate: Math.round(8 * r / i)
                })
              }
            }, {
              key: "analyzeM3u8Data",
              value: function () {
                var r = 0,
                  i = 0,
                  n = 0,
                  t = "",
                  e = this.m3u8Sources;
                e.forEach(function (t, e) {
                  t = t.latency;
                  i = 0 === e ? r = t : (r = Math.max(t, r), Math.min(t, i)), n += t
                }), 0 < e.length && (t = (n / e.length).toFixed(2));
                var i = Math.round(i),
                  r = Math.round(r),
                  a = this.levelUpdateInterval.map(function (t) {
                    return "".concat(t.updateInterval, "-").concat(t.notUpdateLevelCount, "-").concat(t.levelLoadErrorCount, "-").concat(t.levelLoadTimeoutCount, "(").concat(t.lastSn, "->").concat(t.newSn, ")")
                  });
                this.m3u8StatisticData = Object.assign(this.m3u8StatisticData, {
                  m3u8_update_time: a.slice(0, 3).join(","),
                  max_m3u8_latency: r,
                  min_m3u8_latency: i,
                  avg_m3u8_latency: t,
                  m3u8_num: e.length
                })
              }
            }, {
              key: "resetAnalyze",
              value: function () {
                this.fragStatisticData = {
                  frag_min_latency: 0,
                  frag_max_latency: 0,
                  frag_avg_latency: 0,
                  frag_min_load: 0,
                  frag_max_load: 0,
                  frag_avg_load: 0,
                  frag_min_process: 0,
                  frag_max_process: 0,
                  frag_avg_process: 0,
                  min_net_speed: 0,
                  max_net_speed: 0,
                  avg_net_speed: 0,
                  frag_min_duration: 0,
                  frag_max_duration: 0,
                  frag_avg_duration: 0,
                  frag_min_size: 0,
                  frag_max_size: 0,
                  frag_avg_size: 0,
                  frag_num: 0,
                  frag_bitrate: 0
                }, this.m3u8StatisticData = {
                  m3u8_update_time: "",
                  min_m3u8_latency: 0,
                  max_m3u8_latency: 0,
                  avg_m3u8_latency: 0,
                  m3u8_num: 0
                }
              }
            }]), e
          }();
          (W = lt = lt || {}).SPEED_UP = "speed_up", W.SPEED_RESET = "speed_reset", W.SPEED_DOWN = "speed_down";
          var ht = function () {
              function r(t) {
                var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 6e4;
                s(this, r), this.controller = t, this.interval = e, u(this, "latencyStats", {
                  current_latency: null,
                  avg_play_latency: null,
                  max_play_latency: null,
                  min_play_latency: null,
                  avg_buffer_duration: null,
                  max_buffer_duration: null,
                  min_buffer_duration: null
                }), u(this, "timer", void 0), u(this, "latencyStatus", lt.SPEED_RESET), u(this, "statusChangeStart", 0), u(this, "statusChangeEnd", 0), u(this, "statusChangeTime", 0), u(this, "playBackRateChangeDuration", 0), u(this, "latencyRecorder", void 0), u(this, "bufferSizeRecorder", void 0), this.latencyStats = {
                  avg_play_latency: null,
                  max_play_latency: null,
                  min_play_latency: null,
                  avg_buffer_duration: null,
                  max_buffer_duration: null,
                  min_buffer_duration: null
                }, this.onMildomLatencyControl = this.onMildomLatencyControl.bind(this), this.controller.hls && (this.controller.hls.on(S.Events.MILDOM_LATENCY_CONTROL, this.onMildomLatencyControl), this.latencyRecorder = new at(t), this.bufferSizeRecorder = new rt(t))
              }
              return o(r, [{
                key: "run",
                value: function () {
                  var r = this;
                  this.latencyRecorder && this.bufferSizeRecorder && (this.latencyRecorder.run(), this.bufferSizeRecorder.run(), this.timer = setInterval(function () {
                    var t = r.latencyRecorder.popData(),
                      e = r.bufferSizeRecorder.popData();
                    r.latencyStats = {
                      avg_play_latency: null == t ? void 0 : t.avg,
                      max_play_latency: null == t ? void 0 : t.max,
                      min_play_latency: null == t ? void 0 : t.min,
                      avg_buffer_duration: null == e ? void 0 : e.avg,
                      max_buffer_duration: null == e ? void 0 : e.max,
                      min_buffer_duration: null == e ? void 0 : e.min
                    }
                  }, this.interval - 100))
                }
              }, {
                key: "stop",
                value: function () {
                  clearInterval(this.timer), this.latencyRecorder && this.latencyRecorder.destroy(), this.bufferSizeRecorder && this.latencyRecorder.destroy(), this.controller.hls && this.controller.hls.off(S.Events.MILDOM_LATENCY_CONTROL, this.onMildomLatencyControl), this.latencyStats = {
                    avg_play_latency: null,
                    max_play_latency: null,
                    min_play_latency: null,
                    avg_buffer_duration: null,
                    max_buffer_duration: null,
                    min_buffer_duration: null
                  }, this.statusChangeTime = 0, this.playBackRateChangeDuration = 0, this.latencyStatus = lt.SPEED_RESET
                }
              }, {
                key: "popData",
                value: function () {
                  var t, e = 0;
                  this.latencyStatus === lt.SPEED_RESET ? 0 !== this.statusChangeEnd && (e = Math.round((this.statusChangeEnd - this.statusChangeStart) / 1e3), this.statusChangeStart = 0, this.statusChangeEnd = 0) : 0 !== this.statusChangeStart && (e = Math.round((performance.now() - this.statusChangeStart) / 1e3), this.statusChangeStart = performance.now()), 1 < this.statusChangeTime && (e = this.playBackRateChangeDuration), this.statusChangeTime = 0, this.playBackRateChangeDuration = 0, null !== (t = this.controller) && void 0 !== t && t.videoDom && this.controller.videoDom.paused && (this.statusChangeStart = 0, this.statusChangeEnd = 0);
                  e = Object.assign(l({}, this.latencyStats), {
                    latency_control_duration: 0 < e ? e : 0
                  });
                  return this.latencyStats = {
                    avg_play_latency: null,
                    max_play_latency: null,
                    min_play_latency: null,
                    avg_buffer_duration: null,
                    max_buffer_duration: null,
                    min_buffer_duration: null
                  }, e
                }
              }, {
                key: "onMildomLatencyControl",
                value: function (t, e) {
                  this.controller.playStatus === j.PlayerStatus.PLAYING && null != e && e.status && (this.latencyStatus = e.status, this.latencyStatus !== lt.SPEED_RESET ? this.statusChangeStart = performance.now() : (this.statusChangeEnd = performance.now(), this.statusChangeTime += 1, this.playBackRateChangeDuration += Math.round((this.statusChangeEnd - this.statusChangeStart) / 1e3)))
                }
              }]), r
            }(),
            dt = function () {
              function r(t) {
                var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 6e4;
                s(this, r), u(this, "catonTimeRecorder", void 0), u(this, "avDiffRecorder", void 0), u(this, "fpsRecorder", void 0), u(this, "data", {}), u(this, "controller", void 0), u(this, "interval", void 0), u(this, "timer", void 0), this.controller = t, this.interval = e
              }
              return o(r, [{
                key: "run",
                value: function () {
                  var i = this;
                  this.catonTimeRecorder = new st(this.controller), this.avDiffRecorder = new et(this.controller), this.fpsRecorder = new it(this.controller), this.catonTimeRecorder.run(), this.avDiffRecorder.run(), this.fpsRecorder.run(), this.timer = setInterval(function () {
                    var t = i.catonTimeRecorder.popData(),
                      e = i.avDiffRecorder.popData(),
                      r = i.fpsRecorder.popData();
                    i.data = {
                      caton_time: null == t ? void 0 : t.catonTime,
                      caton_pv: null == t ? void 0 : t.catonCount,
                      max_av_diff: null == e ? void 0 : e.max,
                      avg_fps: null == r ? void 0 : r.avg
                    }
                  }, this.interval - 100)
                }
              }, {
                key: "stop",
                value: function () {
                  clearInterval(this.timer), this.catonTimeRecorder && this.catonTimeRecorder.destroy(), this.avDiffRecorder && this.avDiffRecorder.destroy(), this.fpsRecorder && this.fpsRecorder.destroy(), this.data = {}
                }
              }, {
                key: "popData",
                value: function () {
                  var t = l({}, this.data);
                  return this.data = {}, t
                }
              }]), r
            }(),
            ct = function () {
              function e(t) {
                s(this, e), u(this, "controller", void 0), u(this, "hlsBufferedCost", 0), u(this, "dataArray", []), this.controller = t, this.onFragBuffered = this.onFragBuffered.bind(this)
              }
              return o(e, [{
                key: "run",
                value: function () {
                  this.controller.hls.on(S.Events.FRAG_BUFFERED, this.onFragBuffered)
                }
              }, {
                key: "stop",
                value: function () {
                  this.controller.hls.off(S.Events.FRAG_BUFFERED, this.onFragBuffered)
                }
              }, {
                key: "popData",
                value: function () {
                  if (!this.dataArray.length) return {};
                  var t = m(this.dataArray.sort(function (t, e) {
                    return t - e
                  }));
                  return this.clear(), {
                    buffered_cost: t[t.length - 1]
                  }
                }
              }, {
                key: "clear",
                value: function () {
                  this.dataArray = [], this.hlsBufferedCost = 0
                }
              }, {
                key: "onFragBuffered",
                value: function (t, e) {
                  this.hlsBufferedCost = Math.round(e.frag.stats.buffering.end - e.frag.stats.buffering.start), this.hlsBufferedCost && this.dataArray.push(this.hlsBufferedCost)
                }
              }]), e
            }();

          function ft(t) {
            return (10 <= t ? "" : "0").concat(t)
          }

          function gt() {
            return Math.round(window.performance.now())
          }

          function mt(t) {
            return isNaN(t) ? 0 : Math.round(t)
          }
          nt = function () {
            function r(t) {
              var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {
                reportInterval: 6e4,
                reportFn: function () {},
                extraInfo: function () {
                  return {}
                }
              };
              s(this, r), u(this, "controller", void 0), u(this, "startPlayTime", 0), u(this, "reportTimer", void 0), u(this, "extraInfo", {}), u(this, "networkAnalyzer", void 0), u(this, "latencyAnalyzer", void 0), u(this, "qualityAnalyzer", void 0), u(this, "cpuAnalyzer", void 0), u(this, "config", {
                reportInterval: 0,
                reportFn: function () {},
                extraInfo: function () {}
              }), this.controller = t, this.onPlayStatusChange = this.onPlayStatusChange.bind(this), this.startReport = this.startReport.bind(this), this.stopReport = this.stopReport.bind(this), this.doReport = this.doReport.bind(this), this.config = e
            }
            return o(r, [{
              key: "run",
              value: function () {
                this.stop(), this.controller.registerEvent(j.PlayerEvent.STATUS_CHANGE, this.onPlayStatusChange), this.controller.playStatus === j.PlayerStatus.PLAYING && this.startReport()
              }
            }, {
              key: "stop",
              value: function () {
                clearInterval(this.reportTimer), this.reportTimer = null, this.networkAnalyzer && this.networkAnalyzer.stop(), this.latencyAnalyzer && this.latencyAnalyzer.stop(), this.cpuAnalyzer && this.cpuAnalyzer.stop()
              }
            }, {
              key: "onPlayStatusChange",
              value: function (t) {
                switch (t.status) {
                case j.PlayerStatus.PLAYING:
                  this.startReport();
                  break;
                case j.PlayerStatus.INITIAL:
                case j.PlayerStatus.PAUSED:
                  this.stopReport()
                }
              }
            }, {
              key: "startReport",
              value: function () {
                this.startPlayTime = gt(), clearInterval(this.reportTimer), this.reportTimer = setInterval(this.doReport, this.config.reportInterval), this.networkAnalyzer = new ut(this.controller), this.networkAnalyzer.run(), this.controller.config.vodMode || this.controller.config.realtimePlaybackMode || (this.latencyAnalyzer = new ht(this.controller, this.config.reportInterval), this.latencyAnalyzer.run()), this.qualityAnalyzer = new dt(this.controller, this.config.reportInterval), this.qualityAnalyzer.run(), this.cpuAnalyzer = new ct(this.controller), this.cpuAnalyzer.run()
              }
            }, {
              key: "stopReport",
              value: function () {
                this.doReport(), this.startPlayTime = 0, clearInterval(this.reportTimer), this.reportTimer = null, this.networkAnalyzer && this.networkAnalyzer.stop(), this.latencyAnalyzer && this.latencyAnalyzer.stop(), this.qualityAnalyzer && this.qualityAnalyzer.stop()
              }
            }, {
              key: "doReport",
              value: function () {
                var t, e, r, i = gt(),
                  n = Math.round((i - this.startPlayTime) / 1e3);
                this.startPlayTime <= 0 || n < 5 || void 0 !== document.hidden && document.hidden || (t = this.networkAnalyzer ? this.networkAnalyzer.popData() : {}, e = this.latencyAnalyzer ? this.latencyAnalyzer.popData() : {}, r = this.qualityAnalyzer ? this.qualityAnalyzer.popData() : {}, i = this.cpuAnalyzer.popData(), i = l(l(l(l(l({
                  p_time: Math.min(n, this.config.reportInterval / 1e3),
                  bj_minute: (n = Date.now(), n = new Date(n + 288e5), "".concat(n.getUTCFullYear(), "-").concat(ft(n.getUTCMonth() + 1), "-").concat(ft(n.getUTCDate()), " ").concat(ft(n.getUTCHours()), ":").concat(ft(n.getUTCMinutes())))
                }, t), e), r), i), {}, {
                  is_parallel_load: this.controller.extra.isParallelLoad ? 1 : 0
                }, this.config.extraInfo ? this.config.extraInfo() : {}), this.startPlayTime = gt(), this.config.reportFn(i))
              }
            }]), r
          }();
          var vt = function () {
            function i(t, e, r) {
              s(this, i), this.sn = t, this.url = e, this.controller = r, u(this, "trequest", performance.now()), u(this, "tfirst", 0), u(this, "tload", 0), u(this, "tbuffered", 0), this.sn = t, this.url = e, this.controller = r
            }
            return o(i, [{
              key: "onFresh",
              value: function (t) {
                this.trequest = mt(t.loading.start), this.tfirst = mt(t.loading.first), this.tload = mt(t.loading.end), this.tbuffered = mt(t.parsing.end)
              }
            }, {
              key: "repr",
              value: function () {
                return {
                  lag_frag_url: this.url,
                  lag_frag_latency: Math.max(this.tfirst - this.trequest, 0),
                  lag_frag_load: Math.max(this.tload - this.tfirst, 0),
                  lag_frag_buffer: Math.max(this.tbuffered - this.tload, 0),
                  tload: this.tload
                }
              }
            }, {
              key: "isClosed",
              value: function () {
                return 0 < this.trequest && 0 < this.tfirst && 0 < this.tload && 0 < this.tbuffered
              }
            }]), i
          }();

          function pt(t) {
            return 0 === t ? 0 : Math.round(Math.min(t - performance.now(), 0))
          }

          function yt(t, e) {
            var r = Object.keys(t);
            if (!(r.length <= e)) {
              r.sort(function (t, e) {
                return t - e
              });
              for (var i = 0; i < r.length - e; i += 1) delete t[r[i]]
            }
          }

          function Et(t) {
            for (var e = "", r = t.length, i = 0; i < r; i += 1) e += "[".concat(t.start(i).toFixed(3), ",").concat(t.end(i).toFixed(3), "]");
            return e
          }
          var bt = function () {
              function t() {
                s(this, t), u(this, "currentStartSN", 0), u(this, "currentEndSN", 0), u(this, "repeatCount", 0), u(this, "levelLoadErrorCount", 0), u(this, "levelLoadTimeoutCount", 0), u(this, "levelLatencyList", []), u(this, "updateAt", 0), u(this, "avgSize", 0), u(this, "avgDuration", 0), u(this, "fragShowMap", {}), u(this, "durationMap", {})
              }
              return o(t, [{
                key: "onFresh",
                value: function (t) {
                  if (t && t.details) {
                    var e, r = t.details,
                      i = function (t, e) {
                        var r = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                        if (!r) {
                          if (Array.isArray(t) || (r = v(t)) || e && t && "number" == typeof t.length) {
                            r && (t = r);
                            var i = 0,
                              e = function () {};
                            return {
                              s: e,
                              n: function () {
                                return i >= t.length ? {
                                  done: !0
                                } : {
                                  done: !1,
                                  value: t[i++]
                                }
                              },
                              e: function (t) {
                                throw t
                              },
                              f: e
                            }
                          }
                          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                        }
                        var n, a = !0,
                          s = !1;
                        return {
                          s: function () {
                            r = r.call(t)
                          },
                          n: function () {
                            var t = r.next();
                            return a = t.done, t
                          },
                          e: function (t) {
                            s = !0, n = t
                          },
                          f: function () {
                            try {
                              a || null == r.return || r.return()
                            } finally {
                              if (s) throw n
                            }
                          }
                        }
                      }(r.fragments);
                    try {
                      for (i.s(); !(e = i.n()).done;) {
                        var n = e.value;
                        this.fragShowMap.hasOwnProperty(n.sn) || (this.fragShowMap[n.sn] = performance.now(), yt(this.fragShowMap, 100)), this.durationMap.hasOwnProperty(n.sn) || (this.durationMap[n.sn] = n.duration, yt(this.durationMap, 10))
                      }
                    } catch (t) {
                      i.e(t)
                    } finally {
                      i.f()
                    }
                    t = r.startSN, r = r.endSN;
                    this.currentStartSN !== t || this.currentEndSN !== r ? (this.currentStartSN = t, this.currentEndSN = r, this.repeatCount = 0, this.levelLatencyList = [], this.levelLoadErrorCount = 0, this.levelLoadTimeoutCount = 0, this.updateAt = performance.now()) : this.repeatCount += 1
                  }
                }
              }, {
                key: "onLevelLoadTimeout",
                value: function () {
                  this.levelLoadTimeoutCount += 1
                }
              }, {
                key: "onLevelLoadError",
                value: function () {
                  this.levelLoadErrorCount += 1
                }
              }, {
                key: "addLevelLatency",
                value: function (t) {
                  this.levelLatencyList.push(t)
                }
              }, {
                key: "getFirstShow",
                value: function (t) {
                  return this.fragShowMap.hasOwnProperty(t) ? this.fragShowMap[t] : 0
                }
              }, {
                key: "getAvgDuration",
                value: function () {
                  var t, e = 0,
                    r = 0;
                  for (t in this.durationMap) r += this.durationMap[t], e += 1;
                  return 0 === e ? 0 : Math.round(r / e)
                }
              }, {
                key: "repr",
                value: function () {
                  return {
                    playlist_last_SN: this.currentEndSN,
                    playlist_repeat: this.repeatCount,
                    playlist_last_update: pt(this.updateAt),
                    avg_duration: this.getAvgDuration(),
                    playlist_load_err_cnt: this.levelLoadErrorCount,
                    playlist_load_timeout_cnt: this.levelLoadTimeoutCount,
                    playlist_latency: this.levelLatencyList.sort(function (t, e) {
                      return e - t
                    }).slice(0, 3).join()
                  }
                }
              }]), t
            }(),
            St = "play_list_not_refresh",
            _t = "play_list_refresh_too_late",
            Lt = "ts_not_send",
            Tt = "ts_connect_time_out",
            At = "ts_load_time_out",
            Rt = "ts_buffer_time_out",
            Dt = "low_performance",
            kt = "unknown",
            W = function () {
              function r(t) {
                var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {
                  reportFn: function () {},
                  extraInfo: function () {}
                };
                s(this, r), this.controller = t, this.config = e, u(this, "playList", new bt), u(this, "sizeMap", {}), u(this, "fragMap", {}), u(this, "noTsLoadingTimer", null), u(this, "checkVideoFreezenTimer", null), u(this, "hasReported", !1), u(this, "hasReportedVideoFreezen", !1), u(this, "levelLoadStart", 0), u(this, "levelLoadEnd", 0), u(this, "fragLoadStart", 0), u(this, "fragLoadEnd", 0), this.onPlayStalled = this.onPlayStalled.bind(this), this.onHlsManifestLoaded = this.onHlsManifestLoaded.bind(this), this.onHlsLevelLoading = this.onHlsLevelLoading.bind(this), this.onHlsLevelLoaded = this.onHlsLevelLoaded.bind(this), this.onHlsError = this.onHlsError.bind(this), this.onHlsFragLoading = this.onHlsFragLoading.bind(this), this.onHlsFragLoadProgress = this.onHlsFragLoadProgress.bind(this), this.onHlsFragLoaded = this.onHlsFragLoaded.bind(this), this.onHlsFragBuffered = this.onHlsFragBuffered.bind(this), this.freshFrag = this.freshFrag.bind(this), this.getLastClosedSN = this.getLastClosedSN.bind(this)
              }
              return o(r, [{
                key: "run",
                value: function () {
                  this.controller.registerEvent(j.PlayerEvent.STALLED, this.onPlayStalled), this.controller.registerHlsEvent(S.Events.MANIFEST_LOADED, this.onHlsManifestLoaded), this.controller.registerHlsEvent(S.Events.LEVEL_LOADED, this.onHlsLevelLoaded), this.controller.registerHlsEvent(S.Events.LEVEL_LOADING, this.onHlsLevelLoading), this.controller.registerHlsEvent(S.Events.ERROR, this.onHlsError), this.controller.registerHlsEvent(S.Events.FRAG_LOADING, this.onHlsFragLoading), this.controller.registerHlsEvent(S.Events.FRAG_LOAD_PROGRESS, this.onHlsFragLoadProgress), this.controller.registerHlsEvent(S.Events.FRAG_LOADED, this.onHlsFragLoaded), this.controller.registerHlsEvent(S.Events.FRAG_BUFFERED, this.onHlsFragBuffered)
                }
              }, {
                key: "stop",
                value: function () {
                  clearTimeout(this.noTsLoadingTimer), clearTimeout(this.checkVideoFreezenTimer), this.controller.unregisterEvent(j.PlayerEvent.STALLED, this.onPlayStalled), this.controller.unregisterHlsEvent(S.Events.MANIFEST_LOADED, this.onHlsManifestLoaded), this.controller.unregisterHlsEvent(S.Events.LEVEL_LOADED, this.onHlsLevelLoaded), this.controller.unregisterHlsEvent(S.Events.LEVEL_LOADING, this.onHlsLevelLoading), this.controller.unregisterHlsEvent(S.Events.ERROR, this.onHlsError), this.controller.unregisterHlsEvent(S.Events.FRAG_LOADING, this.onHlsFragLoading), this.controller.unregisterHlsEvent(S.Events.FRAG_LOAD_PROGRESS, this.onHlsFragLoadProgress), this.controller.unregisterHlsEvent(S.Events.FRAG_LOADED, this.onHlsFragLoaded), this.controller.unregisterHlsEvent(S.Events.FRAG_BUFFERED, this.onHlsFragBuffered)
                }
              }, {
                key: "onHlsManifestLoaded",
                value: function (t, e) {
                  e.levels && e.levels[0] && this.playList.onFresh(e.levels[0])
                }
              }, {
                key: "onHlsLevelLoading",
                value: function () {
                  this.levelLoadStart = Date.now()
                }
              }, {
                key: "onHlsLevelLoaded",
                value: function (t, e) {
                  var r, i, n, a;
                  null != e && null !== (r = e.stats) && void 0 !== r && null !== (i = r.loading) && void 0 !== i && i.end && null != e && null !== (n = e.stats) && void 0 !== n && null !== (a = n.loading) && void 0 !== a && a.start ? this.levelLoadEnd = this.levelLoadStart + e.stats.loading.end - e.stats.loading.start : this.levelLoadEnd = 0, this.playList.addLevelLatency(e.stats.loading.start - e.stats.loading.first), this.playList.onFresh(e)
                }
              }, {
                key: "onHlsError",
                value: function (t, e) {
                  var r, i, n, a, s;
                  e.details === S.ErrorDetails.LEVEL_LOAD_TIMEOUT ? this.playList.onLevelLoadTimeout() : e.details === S.ErrorDetails.LEVEL_LOAD_ERROR ? this.playList.onLevelLoadError() : ![S.ErrorDetails.LEVEL_LOAD_TIMEOUT, S.ErrorDetails.LEVEL_LOAD_ERROR, S.ErrorDetails.FRAG_LOAD_TIMEOUT, S.ErrorDetails.FRAG_LOAD_ERROR, S.ErrorDetails.BUFFER_STALLED_ERROR].includes(e.details) && e.fatal && this.reportExpection(e), [S.ErrorDetails.BUFFER_STALLED_ERROR].includes(e.details) || (e = {
                    lt: "video",
                    ct: "caton_error",
                    dt: "error_event",
                    aid: this.config.extraInfo && (null === (r = this.config.extraInfo()) || void 0 === r ? void 0 : r.aid),
                    err_type: e.details,
                    status: (null == e || null === (i = e.networkDetails) || void 0 === i ? void 0 : i.status) || 0,
                    ready_state: (null == e || null === (n = e.networkDetails) || void 0 === n ? void 0 : n.readyState) || 0,
                    response_text: "arraybuffer" !== (null == e || null === (a = e.networkDetails) || void 0 === a ? void 0 : a.responseType) ? null == e || null === (s = e.networkDetails) || void 0 === s ? void 0 : s.responseText : "",
                    baseurl: (null === (s = e.frag) || void 0 === s ? void 0 : s.baseurl) || (null == e ? void 0 : e.url) || "",
                    ts_url: (null === (s = e.frag) || void 0 === s ? void 0 : s.relurl) || "",
                    sn: (null === (e = e.frag) || void 0 === e ? void 0 : e.sn) || 0,
                    is_parallel_load: this.controller.extra.isParallelLoad ? 1 : 0
                  }, this.config.reportFn(e))
                }
              }, {
                key: "onHlsFragLoading",
                value: function (t, e) {
                  this.fragLoadStart = Date.now(), this.addFrag(e), clearTimeout(this.noTsLoadingTimer), this.noTsLoadingTimer = null
                }
              }, {
                key: "onHlsFragLoadProgress",
                value: function (t, e) {
                  this.freshFrag(e)
                }
              }, {
                key: "onHlsFragLoaded",
                value: function (t, e) {
                  this.fragLoadEnd = Date.now(), clearTimeout(this.checkVideoFreezenTimer), this.checkVideoFreezenTimer = null, this.freshFrag(e), e && e.frag && e.stats && (this.sizeMap[e.frag.sn] = e.stats.total / 1e3, yt(this.sizeMap, 10))
                }
              }, {
                key: "onHlsFragBuffered",
                value: function (t, e) {
                  this.freshFrag(e)
                }
              }, {
                key: "onPlayStalled",
                value: function () {
                  var t;
                  null != this && null !== (t = this.controller.videoDom) && void 0 !== t && t.seeking || this.report()
                }
              }, {
                key: "addFrag",
                value: function (t) {
                  var e = t.frag.sn,
                    t = t.frag.relurl;
                  this.fragMap[e] = new vt(e, t, this.controller), yt(this.fragMap, 10)
                }
              }, {
                key: "freshFrag",
                value: function (t) {
                  var e = t.frag.sn;
                  this.fragMap.hasOwnProperty(e) && this.fragMap[e].onFresh(t.frag.stats)
                }
              }, {
                key: "getLastClosedSN",
                value: function () {
                  var t = -1,
                    e = Object.keys(this.fragMap);
                  if (e.length <= 0) return -1;
                  e.sort(function (t, e) {
                    return e - t
                  });
                  for (var r = 0; r < e.length; r += 1) {
                    var i = e[r];
                    if (this.fragMap[i].isClosed()) {
                      t = Number(i);
                      break
                    }
                  }
                  return t
                }
              }, {
                key: "getFirstLoadingSN",
                value: function () {
                  var t = -1,
                    e = Object.keys(this.fragMap);
                  if (e.length <= 0) return -1;
                  e.sort(function (t, e) {
                    return t - e
                  });
                  for (var r = 0; r < e.length; r += 1) {
                    var i = e[r];
                    if (!this.fragMap[i].isClosed()) {
                      t = Number(i);
                      break
                    }
                  }
                  return t
                }
              }, {
                key: "getAvgSize",
                value: function () {
                  var t, e = 0,
                    r = 0;
                  for (t in this.sizeMap) r += this.sizeMap[t], e += 1;
                  return 0 === e ? 0 : Math.round(r / e)
                }
              }, {
                key: "report",
                value: function () {
                  var t = this.getInitialMsg(),
                    e = -1,
                    r = this.getFirstLoadingSN();
                  (e = r < 0 ? this.getLastClosedSN() + 1 : r) <= 0 || (t = Object.assign(t, this.playList.repr(), {
                    lag_frag_SN: e,
                    lag_frag_show_time: pt(this.playList.getFirstShow(e)),
                    avg_size: this.getAvgSize()
                  }), (e = this.fragMap[e]) && e.trequest && (t = Object.assign(t, e.repr(), {
                    is_frag_send: 1
                  })), this.errorAnalyse(t), sessionStorage.setItem("catonMessage", JSON.stringify({
                    type: function (t) {
                      var e = 0;
                      switch (t) {
                      case Tt:
                      case At:
                        e = 1;
                        break;
                      case St:
                        e = 2;
                        break;
                      case _t:
                        e = 3;
                        break;
                      case Dt:
                        e = 4;
                        break;
                      case kt:
                        e = 5
                      }
                      return e
                    }(t.err_type),
                    kd_start_time: Date.now(),
                    frag_request_time: this.fragLoadStart,
                    playlist_request_time: Math.round(this.levelLoadStart),
                    playlist_response_time: this.levelLoadEnd,
                    buffering_time: this.fragLoadEnd ? Math.round(Date.now() - this.fragLoadEnd) : 0,
                    frag_url: t.lag_frag_url,
                    playlist_url: t.src
                  })), this.config.reportFn(t))
                }
              }, {
                key: "getInitialMsg",
                value: function () {
                  return l({
                    playlist_last_SN: 0,
                    playlist_repeat: 0,
                    playlist_last_update: 0,
                    is_frag_send: 0,
                    lag_frag_SN: 0,
                    lag_frag_url: "",
                    lag_frag_trequest: 0,
                    lag_frag_latency: 0,
                    lag_frag_load: 0,
                    lag_frag_buffer: 0,
                    lag_frag_show_time: 0,
                    avg_size: 0,
                    avg_duration: 0,
                    is_fatal: 0,
                    is_parallel_load: this.controller.extra.isParallelLoad ? 1 : 0
                  }, this.config.extraInfo ? this.config.extraInfo() : {})
                }
              }, {
                key: "errorAnalyse",
                value: function (t) {
                  if (t.lag_frag_SN > t.playlist_last_SN) t.err_type = St;
                  else {
                    if (!(Math.abs(t.lag_frag_show_time) < 300)) return 0 === t.is_frag_send ? (t.err_type = Lt, void this.checkNoTsLoadingError()) : 0 === t.lag_frag_latency ? (this.checkVideoFreezen(), void(t.err_type = Tt)) : 0 === t.lag_frag_load ? (this.checkVideoFreezen(), void(t.err_type = At)) : void(0 !== t.lag_frag_buffer ? t.tload && 500 < performance.now() - t.tload ? t.err_type = Dt : t.err_type = kt : t.err_type = Rt);
                    t.err_type = _t
                  }
                }
              }, {
                key: "checkNoTsLoadingError",
                value: function () {
                  var t = this;
                  this.hasReported || this.noTsLoadingTimer || (this.noTsLoadingTimer = setTimeout(function () {
                    clearTimeout(t.noTsLoadingTimer), t.noTsLoadingTimer = null, t.reportNoTsLoadingError()
                  }, 1e4))
                }
              }, {
                key: "reportNoTsLoadingError",
                value: function () {
                  var t, e, r = this.controller.hls;
                  r && r.streamController && r.media && (t = l({
                    lt: "video",
                    ct: "play",
                    dt: "pc_error",
                    err_type: "player_error",
                    err_position: "video:no_ts_loading",
                    err_msg: {}
                  }, this.config.extraInfo ? this.config.extraInfo() : {}), e = r.streamController, r = r.media, r = {
                    streamController: l({
                      state: e._state,
                      loadedmetadata: e.loadedmetadata,
                      pendingDownloadFrags: e.pendingDownloadFrags && e.pendingDownloadFrags.map(function (t) {
                        return t.sn
                      }),
                      pendingParseFragData: e.pendingParseFragDatas && e.pendingParseFragDatas.map(function (t) {
                        return t && t.frag && t.frag.sn
                      }),
                      pendingDownloadFragsOnError: e.pendingDownloadFragsOnError,
                      pendingParseFragsOnError: e.pendingParseFragsOnError,
                      nextLoadPosition: e.nextLoadPosition,
                      fragPrevious: e.fragPrevious && e.fragPrevious.sn,
                      fragCurrent: e.fragCurrent && e.fragCurrent.sn,
                      startFragRequested: e.startFragRequested,
                      level: e.level
                    }, this.getLevelInfo(e.levels, e.level)),
                    mediaElement: {
                      buffered: Et(r.buffered),
                      currentTime: r.currentTime,
                      duration: r.duration
                    }
                  }, t.err_msg = r, this.config.reportFn(t), this.hasReported = !0)
                }
              }, {
                key: "checkVideoFreezen",
                value: function () {
                  var t = this;
                  this.hasReportedVideoFreezen || this.checkVideoFreezenTimer || (this.checkVideoFreezenTimer = setTimeout(function () {
                    clearTimeout(t.checkVideoFreezenTimer), t.checkVideoFreezenTimer = null, t.reportVideoFreezen()
                  }, 3e4))
                }
              }, {
                key: "reportVideoFreezen",
                value: function () {
                  var t = this.controller.hls,
                    e = l({
                      lt: "video",
                      ct: "play",
                      dt: "pc_error",
                      err_type: "player_error",
                      err_position: "video:video_freezen",
                      err_msg: {}
                    }, this.config.extraInfo ? this.config.extraInfo() : {}),
                    r = t.streamController,
                    t = t.media,
                    t = {
                      streamController: l({
                        state: r._state,
                        loadedmetadata: r.loadedmetadata,
                        pendingDownloadFrags: r.pendingDownloadFrags && r.pendingDownloadFrags.map(function (t) {
                          return t.sn
                        }),
                        pendingParseFragData: r.pendingParseFragDatas && r.pendingParseFragDatas.map(function (t) {
                          return t && t.frag && t.frag.sn
                        }),
                        pendingDownloadFragsOnError: r.pendingDownloadFragsOnError,
                        pendingParseFragsOnError: r.pendingParseFragsOnError,
                        nextLoadPosition: r.nextLoadPosition,
                        fragPrevious: r.fragPrevious && r.fragPrevious.sn,
                        fragCurrent: r.fragCurrent && r.fragCurrent.sn,
                        startFragRequested: r.startFragRequested,
                        level: r.level
                      }, this.getLevelInfo(r.levels, r.level)),
                      mediaElement: {
                        buffered: Et(t.buffered),
                        currentTime: t.currentTime,
                        duration: t.duration
                      }
                    };
                  e.err_msg = t, this.config.reportFn(e), this.hasReportedVideoFreezen = !0
                }
              }, {
                key: "reportExpection",
                value: function (t) {
                  this.getInitialMsg();
                  var e = {
                    err_type: t.details,
                    is_fatal: 1,
                    log_trace: this.controller.getLog().join("---")
                  };
                  this.config.reportFn(e)
                }
              }, {
                key: "getLevelInfo",
                value: function (t, e) {
                  if (!t) return {};
                  var r = t[e] && t[e].details;
                  if (!r) return {};
                  t = r.fragments;
                  if (!t || t.length <= 0) return {};
                  e = t.length;
                  return {
                    startTimeStamp: t[0].start,
                    endTimeStamp: t[e - 1].start + t[e - 1].duration,
                    PTSKnown: r.PTSKnown,
                    levelDetails: t.map(function (t) {
                      return {
                        sn: t.sn,
                        duration: t.duration,
                        start: t.start
                      }
                    })
                  }
                }
              }]), r
            }(),
            nt = l(l(l(l({}, Q), T), X), {}, {
              SourceProtocol: K,
              ControlPosition: q,
              Components: Z,
              Plugins: {
                PlayStatisticReporter: nt,
                PlayErrorReporter: W
              }
            }),
            W = b(function (t) {
              var i = Object.prototype.hasOwnProperty,
                f = "~";

              function r() {}

              function a(t, e, r) {
                this.fn = t, this.context = e, this.once = r || !1
              }

              function n(t, e, r, i, n) {
                if ("function" != typeof r) throw new TypeError("The listener must be a function");
                n = new a(r, i || t, n), e = f ? f + e : e;
                return t._events[e] ? t._events[e].fn ? t._events[e] = [t._events[e], n] : t._events[e].push(n) : (t._events[e] = n, t._eventsCount++), t
              }

              function l(t, e) {
                0 == --t._eventsCount ? t._events = new r : delete t._events[e]
              }

              function e() {
                this._events = new r, this._eventsCount = 0
              }
              Object.create && (r.prototype = Object.create(null), (new r).__proto__ || (f = !1)), e.prototype.eventNames = function () {
                var t, e, r = [];
                if (0 === this._eventsCount) return r;
                for (e in t = this._events) i.call(t, e) && r.push(f ? e.slice(1) : e);
                return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(t)) : r
              }, e.prototype.listeners = function (t) {
                var e = this._events[f ? f + t : t];
                if (!e) return [];
                if (e.fn) return [e.fn];
                for (var r = 0, i = e.length, n = new Array(i); r < i; r++) n[r] = e[r].fn;
                return n
              }, e.prototype.listenerCount = function (t) {
                t = this._events[f ? f + t : t];
                return t ? t.fn ? 1 : t.length : 0
              }, e.prototype.emit = function (t, e, r, i, n, a) {
                var s = f ? f + t : t;
                if (!this._events[s]) return !1;
                var o, l = this._events[s],
                  u = arguments.length;
                if (l.fn) {
                  switch (l.once && this.removeListener(t, l.fn, void 0, !0), u) {
                  case 1:
                    return l.fn.call(l.context), !0;
                  case 2:
                    return l.fn.call(l.context, e), !0;
                  case 3:
                    return l.fn.call(l.context, e, r), !0;
                  case 4:
                    return l.fn.call(l.context, e, r, i), !0;
                  case 5:
                    return l.fn.call(l.context, e, r, i, n), !0;
                  case 6:
                    return l.fn.call(l.context, e, r, i, n, a), !0
                  }
                  for (c = 1, o = new Array(u - 1); c < u; c++) o[c - 1] = arguments[c];
                  l.fn.apply(l.context, o)
                } else
                  for (var h, d = l.length, c = 0; c < d; c++) switch (l[c].once && this.removeListener(t, l[c].fn, void 0, !0), u) {
                  case 1:
                    l[c].fn.call(l[c].context);
                    break;
                  case 2:
                    l[c].fn.call(l[c].context, e);
                    break;
                  case 3:
                    l[c].fn.call(l[c].context, e, r);
                    break;
                  case 4:
                    l[c].fn.call(l[c].context, e, r, i);
                    break;
                  default:
                    if (!o)
                      for (h = 1, o = new Array(u - 1); h < u; h++) o[h - 1] = arguments[h];
                    l[c].fn.apply(l[c].context, o)
                  }
                return !0
              }, e.prototype.on = function (t, e, r) {
                return n(this, t, e, r, !1)
              }, e.prototype.once = function (t, e, r) {
                return n(this, t, e, r, !0)
              }, e.prototype.removeListener = function (t, e, r, i) {
                t = f ? f + t : t;
                if (!this._events[t]) return this;
                if (!e) return l(this, t), this;
                var n = this._events[t];
                if (n.fn) n.fn !== e || i && !n.once || r && n.context !== r || l(this, t);
                else {
                  for (var a = 0, s = [], o = n.length; a < o; a++)(n[a].fn !== e || i && !n[a].once || r && n[a].context !== r) && s.push(n[a]);
                  s.length ? this._events[t] = 1 === s.length ? s[0] : s : l(this, t)
                }
                return this
              }, e.prototype.removeAllListeners = function (t) {
                return t ? this._events[t = f ? f + t : t] && l(this, t) : (this._events = new r, this._eventsCount = 0), this
              }, e.prototype.off = e.prototype.removeListener, e.prototype.addListener = e.prototype.on, e.prefixed = f, t.exports = e.EventEmitter = e
            }),
            Ct = {
              UPDATE_CHAT_LIST: "update_chat_list",
              EMIT_CURRENT_CHATLIST: "emit_current_chatlist",
              CHATLIST_UPDATE: "chatlist_update",
              NEED_ANNIMATION: "need_annimation",
              IS_IN_BOTTOM: "is_in_bottom",
              CHATLIST_HAS_CACHE: "chatlist_has_cache",
              CHATLIST_CACHE_UPDATE: "chatlist_cache_update",
              CLICK_TO_BOTTOM: "click_to_bottom"
            },
            wt = new W,
            xt = function (t) {
              var e = typeof t;
              return null != t && ("object" == e || "function" == e)
            },
            W = "object" == typeof y && y && y.Object === Object && y,
            y = "object" == typeof self && self && self.Object === Object && self,
            Pt = W || y || Function("return this")(),
            Ot = function () {
              return Pt.Date.now()
            },
            Ft = /\s/,
            It = function (t) {
              for (var e = t.length; e-- && Ft.test(t.charAt(e)););
              return e
            },
            Mt = /^\s+/,
            Nt = function (t) {
              return t && t.slice(0, It(t) + 1).replace(Mt, "")
            },
            W = Pt.Symbol,
            y, Ut = (y = Object.prototype).hasOwnProperty,
            Bt = y.toString,
            Ht = W ? W.toStringTag : void 0,
            Gt = function (t) {
              var e = Ut.call(t, Ht),
                r = t[Ht];
              try {
                var i = !(t[Ht] = void 0)
              } catch (t) {}
              var n = Bt.call(t);
              return i && (e ? t[Ht] = r : delete t[Ht]), n
            },
            jt = Object.prototype.toString,
            Vt = function (t) {
              return jt.call(t)
            },
            zt = W ? W.toStringTag : void 0,
            qt = function (t) {
              return null == t ? void 0 === t ? "[object Undefined]" : "[object Null]" : (zt && zt in Object(t) ? Gt : Vt)(t)
            },
            Kt = function (t) {
              return null != t && "object" == typeof t
            },
            Wt = function (t) {
              return "symbol" == typeof t || Kt(t) && "[object Symbol]" == qt(t)
            },
            Yt = /^[-+]0x[0-9a-f]+$/i,
            Xt = /^0b[01]+$/i,
            $t = /^0o[0-7]+$/i,
            Qt = parseInt,
            Jt = function (t) {
              if ("number" == typeof t) return t;
              if (Wt(t)) return NaN;
              if (xt(t) && (e = "function" == typeof t.valueOf ? t.valueOf() : t, t = xt(e) ? e + "" : e), "string" != typeof t) return 0 === t ? t : +t;
              t = Nt(t);
              var e = Xt.test(t);
              return e || $t.test(t) ? Qt(t.slice(2), e ? 2 : 8) : Yt.test(t) ? NaN : +t
            },
            Zt = Math.max,
            te = Math.min;

          function ee(t) {
            var e = t.color,
              r = void 0 === e ? "#e8e8e8" : e,
              i = void 0 === (t = t.darkColor) ? "#404040" : t;
            return R.css(re = re || g(["\n    /* ie */\n    scrollbar-base-color: rgba(0, 0, 0, 0);\n\n    /* webkit */\n    ::-webkit-scrollbar {\n      width: 6px;\n      height: 6px;\n    }\n    ::-webkit-scrollbar-track {\n      background-color: rgba(0, 0, 0, 0);\n    }\n    ::-webkit-scrollbar-thumb {\n      border-radius: 3px;\n    }\n    ::-webkit-scrollbar-corner {\n      background-color: transparent;\n    }\n\n    /* firefox */\n    scrollbar-width: thin;\n\n    ", "\n  "]), function (t) {
              t = t.theme.darkTheme;
              return R.css(ie = ie || g(["\n      /* ie */\n      scrollbar-face-color: ", ";\n      scrollbar-shadow-color: ", ";\n      scrollbar-arrow-color: ", ";\n      scrollbar-highlight-color: ", ";\n      scrollbar-3dlight-color: ", ";\n      scrollbar-darkshadow-color: ", ";\n      scrollbar-track-color: ", ";\n      /* firefox */\n      scrollbar-color: ", " rgba(0, 0, 0, 0);\n      /* webkit */\n      ::-webkit-scrollbar-thumb {\n        background-color: ", ";\n      }\n    "]), t ? "#494C51" : "#cccccc", t ? "#494C51" : "#cccccc", t ? "#494C51" : "#cccccc", t ? "#494C51" : "#cccccc", t ? "#494C51" : "#cccccc", t ? "#494C51" : "#cccccc", t ? "rgb(32, 33, 35)" : "rgb(245, 245, 245)", t ? i : r, t ? i : r)
            })
          }
          var re, ie, ne, ae = function (i, r, t) {
              var n, a, s, o, l, u, h = 0,
                d = !1,
                c = !1,
                e = !0;
              if ("function" != typeof i) throw new TypeError("Expected a function");

              function f(t) {
                var e = n,
                  r = a;
                return n = a = void 0, h = t, o = i.apply(r, e)
              }

              function g(t) {
                var e = t - u;
                return void 0 === u || r <= e || e < 0 || c && s <= t - h
              }

              function m() {
                var t, e = Ot();
                if (g(e)) return v(e);
                l = setTimeout(m, (e = r - ((t = e) - u), c ? te(e, s - (t - h)) : e))
              }

              function v(t) {
                return l = void 0, e && n ? f(t) : (n = a = void 0, o)
              }

              function p() {
                var t = Ot(),
                  e = g(t);
                if (n = arguments, a = this, u = t, e) {
                  if (void 0 === l) return h = e = u, l = setTimeout(m, r), d ? f(e) : o;
                  if (c) return clearTimeout(l), l = setTimeout(m, r), f(u)
                }
                return void 0 === l && (l = setTimeout(m, r)), o
              }
              return r = Jt(r) || 0, xt(t) && (d = !!t.leading, c = "maxWait" in t, s = c ? Zt(Jt(t.maxWait) || 0, r) : s, e = "trailing" in t ? !!t.trailing : e), p.cancel = function () {
                void 0 !== l && clearTimeout(l), n = u = a = l = void(h = 0)
              }, p.flush = function () {
                return void 0 === l ? o : v(Ot())
              }, p
            },
            W = ee({}),
            se = e.default.div(g(["\n  flex: 1;\n  min-height: 0;\n  position: relative;\n  height: 100%;\n  .message-list-container {\n    flex: 1;\n    min-height: 0;\n    position: relative;\n    background-color: transparent;\n    height: 100%;\n    width: 100%;\n    .message-list {\n      position: absolute;\n      width: 100%;\n      height: 100%;\n      font-size: 13px;\n      flex: 1 1 auto;\n      outline: none;\n      overflow: auto;\n      min-height: 100%;\n      ", "\n      ", "\n    }\n  }\n  ", "\n"]), W, function (t) {
              t = t.theme.isFullScreen;
              return ee({
                color: t && "rgba(0, 0, 0, 0.15)",
                darkColor: t && "rgba(0, 0, 0, 0.15)"
              })
            }, function (t) {
              var e = t.needScrollSmooth,
                t = t.theme.noNeedAnimation;
              return e && !t && R.css(ne = ne || g(["\n      .message-list-container {\n        .message-list {\n          scroll-behavior: smooth;\n        }\n      }\n    "]))
            }),
            e = D.default.forwardRef(function (t, e) {
              var r = t.rowRenderFunc,
                i = t.gotoBtmRenderFunc,
                n = t.chatList,
                a = t.styleProp,
                s = t.action,
                o = t.isScrollToBtm,
                l = A.useRef(null),
                u = k(A.useState(!1), 2),
                h = u[0],
                d = u[1],
                c = k(A.useState(!0), 2),
                t = c[0],
                f = c[1],
                u = k(A.useState(!0), 2),
                g = u[0],
                m = u[1],
                c = k(A.useState(!1), 2),
                u = c[0],
                v = c[1],
                p = A.useRef(0),
                y = A.useRef(null),
                E = A.useRef(null),
                b = A.useCallback(function () {
                  f(!1), clearTimeout(y.current), y.current = setTimeout(function () {
                    f(!0)
                  }, 2e3)
                }, []),
                S = A.useCallback(function (t) {
                  m(t)
                }, []),
                _ = A.useCallback(function () {
                  m(!0), h || (l.current.scrollTop = 99999, o && o(!0))
                }, [o, t, h]),
                L = A.useCallback(ae(function () {
                  var t, e, r;
                  l.current && (t = (r = l.current).scrollTop, ((e = r.scrollHeight) < (r = r.clientHeight) + t + 10 || 0 === e || 0 === r) && _())
                }, 100), [_]),
                T = A.useCallback(function () {
                  _(), v(!1)
                }, [_]);
              return A.useEffect(function () {
                g ? (v(!1), _()) : n.length !== p.current && v(!0), p.current = n.length
              }, [g, n.length, _]), A.useEffect(function () {
                var e = -1 !== navigator.userAgent.indexOf("Firefox");
                l && l.current && l.current.addEventListener(e ? "DOMMouseScroll" : "mousewheel", function (t) {
                  0 !== l.current.scrollTop && (e ? t.detail < 0 && (m(!1), o && o(!1)) : 0 < t.wheelDelta && (m(!1), o && o(!1)))
                })
              }, [o]), A.useEffect(function () {
                wt.emit(Ct.IS_IN_BOTTOM, g)
              }, [g]), A.useEffect(function () {
                function t(t) {
                  d(0 < t), g || v(!0)
                }
                return wt.on(Ct.CHATLIST_CACHE_UPDATE, t),
                  function () {
                    wt.off(Ct.CHATLIST_CACHE_UPDATE, t)
                  }
              }, [g]), A.useEffect(function () {
                function t(t) {
                  f(t)
                }

                function e(t) {
                  var e, t = null === (e = l.current) || void 0 === e ? void 0 : e.children[t];
                  b(), null != t && t.scrollIntoView({
                    block: "start"
                  }), m(!1)
                }
                return wt.on(Ct.NEED_ANNIMATION, t), wt.on(Ct.CHATLIST_HAS_CACHE, e),
                  function () {
                    wt.off(Ct.NEED_ANNIMATION, t), wt.off(Ct.CHATLIST_HAS_CACHE, e)
                  }
              }, [b]), A.useImperativeHandle(e, function () {
                return {
                  list: l.current,
                  reset: T,
                  listContainerDom: E.current,
                  hideHasNewMessage: function () {
                    v(!1)
                  },
                  showHasNewMessage: function () {
                    v(!0)
                  },
                  isInBottom: g,
                  clickToBottom: function () {
                    wt.emit(Ct.CLICK_TO_BOTTOM), b(), m(!0), l.current.scrollTop = 99999
                  },
                  stopAnimationTemp: b,
                  setMessageListAutoScroll: S
                }
              }, [g, T, S, b]), D.default.createElement(R.ThemeProvider, {
                theme: s
              }, D.default.createElement(se, {
                needScrollSmooth: t,
                style: a
              }, D.default.createElement("div", {
                id: "message-list-container",
                className: "message-list-container",
                ref: E
              }, D.default.createElement("div", {
                className: "message-list",
                ref: l,
                onScroll: function () {
                  L()
                }
              }, A.useMemo(function () {
                return n.map(function (t, e) {
                  return r(t, e)
                })
              }, [n, r])), u && i())))
            }),
            oe = 500,
            le = 1e4,
            ue = 1,
            he = function () {
              function e(t) {
                s(this, e), u(this, "config", void 0), u(this, "bufferList", void 0), u(this, "lastClearTime", void 0), u(this, "clearTimer", void 0), u(this, "THROTTLE_INTERVAL", void 0), u(this, "highOrderMsg", void 0), this.config = t, this.highOrderMsg = [], this.bufferList = [], this.lastClearTime = 0, this.clearTimer = null, this.THROTTLE_INTERVAL = this.config.throttleInterval || 1e3
              }
              return o(e, [{
                key: "collect",
                value: function (t, e) {
                  var r = this;
                  t.recieveTime = +new Date, (t.order !== ue || e ? this.bufferList : this.highOrderMsg).push(t), Date.now() - this.lastClearTime > this.THROTTLE_INTERVAL ? this.pop() : null === this.clearTimer && (this.clearTimer = setTimeout(function () {
                    r.pop()
                  }, this.THROTTLE_INTERVAL))
                }
              }, {
                key: "pop",
                value: function () {
                  clearTimeout(this.clearTimer), this.clearTimer = null, this.lastClearTime = Date.now(), this.config.updateChatList([].concat(m(this.highOrderMsg), m(this.bufferList))), this.bufferList = [], this.highOrderMsg = []
                }
              }]), e
            }(),
            de = function () {
              function r(t, e) {
                s(this, r), u(this, "queue", void 0), u(this, "isRun", void 0), u(this, "clearTimer", void 0), u(this, "onData", void 0), u(this, "config", void 0), u(this, "msgInterval", 100), u(this, "maxFirstEndMsgTime", 5e3), this.onData = t, this.config = e, this.queue = [], this.isRun = !1, this.clearTimer = null, this.config.msgInterval && (this.msgInterval = this.config.msgInterval), this.config.maxFirstEndMsgTime && (this.maxFirstEndMsgTime = this.config.maxFirstEndMsgTime)
              }
              return o(r, [{
                key: "push",
                value: function (t, e) {
                  for (var r = 0; r < t.length; r += 1) {
                    if (t[r].order !== ue) {
                      var i, n = t.slice(r);
                      (i = this.queue).push.apply(i, m(n));
                      break
                    }
                    this.queue.unshift(t[r])
                  }
                  if (e) return this.onData(this.queue), void this.clear();
                  this.run()
                }
              }, {
                key: "run",
                value: function () {
                  this.isRun = !0, this.next()
                }
              }, {
                key: "next",
                value: function () {
                  var t, e = this;
                  if (0 !== this.queue.length) {
                    var r = this.queue.shift();
                    if ((null === (t = this.queue[this.queue.length - 1]) || void 0 === t ? void 0 : t.recieveTime) - (null == r ? void 0 : r.recieveTime) > this.maxFirstEndMsgTime) return this.onData(this.queue), void this.clear();
                    this.onData(r), this.clearTimer = setTimeout(function () {
                      e.next()
                    }, this.msgInterval)
                  } else this.clear()
                }
              }, {
                key: "clear",
                value: function () {
                  clearTimeout(this.clearTimer), this.clearTimer = null, this.queue = [], this.isRun = !1
                }
              }]), r
            }();
          return W = function () {
            function r(t, e) {
              var a = this;
              s(this, r), u(this, "chatList", []), u(this, "chatListCache", []), u(this, "isFirstLoad", !0), u(this, "msgFilter", void 0), u(this, "extra", void 0), u(this, "msgQueue", null), u(this, "chatCollector", null), u(this, "firstLoadTime", 5e3), u(this, "chatListMaxSize", oe), u(this, "chatListMaxCacheSize", le), u(this, "MsgListEventemitter", null), u(this, "isInbottom", !0), u(this, "resetFirstLoadTimer", null), u(this, "updataChatList", function (t) {
                var e = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1],
                  r = a.msgFilter ? a.msgFilter(t) : t;
                a.isNeedAnimationHandle(r), e && !a.isFirstLoad ? (a.msgQueue || (a.msgQueue = new de(function (t) {
                  a.realUpdateChatList(t)
                }, {
                  msgInterval: null === (e = a.extra) || void 0 === e ? void 0 : e.msgInterval,
                  maxFirstEndMsgTime: null === (e = a.extra) || void 0 === e ? void 0 : e.maxFirstEndMsgTime
                })), a.msgQueue.push(r, a.isFirstLoad)) : a.realUpdateChatList(r)
              }), u(this, "updateChatlistSilent", function (t) {
                a.chatList = m(t)
              }), u(this, "addItem", function (t) {
                var e;
                a.chatCollector || (a.chatCollector = new he({
                  throttleInterval: null === (e = a.extra) || void 0 === e ? void 0 : e.throttleInterval,
                  updateChatList: a.updataChatList
                })), t.key = function (t) {
                  return t = 0 < arguments.length && void 0 !== t ? t : 10, Number(Math.random().toString().substr(3, t) + Date.now()).toString(36)
                }(), a.chatCollector.collect(t, a.isFirstLoad)
              }), u(this, "removeItem", function (e) {
                console.log("MsgList?-- remove item --", e);
                var t = a.chatList.slice().filter(function (t) {
                  return (null == t ? void 0 : t.msgId) !== e
                });
                a.chatList = m(t), a.MsgListEventemitter.emit(Ct.CHATLIST_UPDATE)
              }), u(this, "updateItem", function (r, i) {
                console.log("MsgList?-- update item --", r, i);
                var n = a.chatList.slice();
                n.forEach(function (t, e) {
                  (null == t ? void 0 : t.msgId) === r && (t = l(l({}, t), i), n[e] = t)
                }), a.chatList = m(n), a.MsgListEventemitter.emit(Ct.CHATLIST_UPDATE)
              }), u(this, "resetFirstLoadState", function () {
                clearTimeout(a.resetFirstLoadTimer), a.resetFirstLoadTimer = setTimeout(function () {
                  a.isFirstLoad = !1
                }, a.firstLoadTime)
              }), u(this, "updateHeadChatList", function (t) {
                var e = [],
                  e = a.msgFilter ? a.msgFilter(t) : t;
                e = a.msgAbandon(e.concat(a.chatList), "tail"), a.chatList = e, a.MsgListEventemitter.emit(Ct.CHATLIST_UPDATE), console.log("MsgList?-- loading history msgs --", e)
              }), u(this, "reset", function () {
                console.log("MsgList?-- reset --"), a.chatList = [], a.chatListCache = [], a.isFirstLoad = !0, a.resetFirstLoadState()
              }), u(this, "updateExtra", function (t) {
                a.extra = l(l({}, a.extra), t)
              }), this.msgFilter = t, this.extra = e, this.MsgListEventemitter = wt, this.updateInBottomState = this.updateInBottomState.bind(this), this.realUpdateChatList = this.realUpdateChatList.bind(this), this.isNeedAnimationHandle = this.isNeedAnimationHandle.bind(this), this.msgAbandon = this.msgAbandon.bind(this), this.updataChatList = this.updataChatList.bind(this), this.addItem = this.addItem.bind(this), this.removeItem = this.removeItem.bind(this), this.updateHeadChatList = this.updateHeadChatList.bind(this), this.updateItem = this.updateItem.bind(this), this.resetFirstLoadState = this.resetFirstLoadState.bind(this), this.clickToBottomHandle = this.clickToBottomHandle.bind(this), this.reset = this.reset.bind(this), this.updateExtra = this.updateExtra.bind(this), this.resetFirstLoadState(), e.chatListMaxSize && e.chatListMaxSize < oe && (this.chatListMaxSize = e.chatListMaxSize), e.chatListMaxCacheSize && (this.chatListMaxCacheSize = e.chatListMaxCacheSize), this.MsgListEventemitter.on(Ct.IS_IN_BOTTOM, this.updateInBottomState), this.MsgListEventemitter.on(Ct.CLICK_TO_BOTTOM, this.clickToBottomHandle)
            }
            return o(r, [{
              key: "clickToBottomHandle",
              value: function () {
                var t, e = this.chatListCache.length;
                0 < e && (e < this.chatListMaxSize ? (t = this.chatListCache.splice(0, this.chatListMaxSize), this.chatList = this.chatList.slice(-(this.chatListMaxSize - e)).concat(t)) : this.chatList = this.chatListCache.slice(-this.chatListMaxSize), this.MsgListEventemitter.emit(Ct.CHATLIST_UPDATE)), this.chatListCache = [], this.isInbottom = !0
              }
            }, {
              key: "updateInBottomState",
              value: function (t) {
                console.log("MsgList?-- in bottom --", t);
                var e = 1;
                if (t) {
                  if (0 < this.chatListCache.length) {
                    var r = this.chatListCache.splice(0, this.chatListMaxSize),
                      i = r.length;
                    return i < this.chatListMaxSize ? (e = this.chatListMaxSize - i, this.chatList = this.chatList.slice(-(this.chatListMaxSize - i)).concat(r), this.isInbottom = !0) : (this.chatList = r, this.isInbottom = !1), this.MsgListEventemitter.emit(Ct.CHATLIST_UPDATE), void(30 < i ? this.MsgListEventemitter.emit(Ct.CHATLIST_HAS_CACHE, e) : (this.chatListCache = [], this.isInbottom = !0))
                  }
                  this.MsgListEventemitter.emit(Ct.CHATLIST_CACHE_UPDATE, 0)
                }
                this.isInbottom = t
              }
            }, {
              key: "msgAbandon",
              value: function (t) {
                var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "head",
                  r = localStorage.getItem("local_max_size"),
                  i = Number(r) || this.chatListMaxSize,
                  n = t,
                  a = t.length;
                return (r = i - t.length / 3) < 0 && (r = i), "head" === e && i < a && (n = t.slice(-r)), "tail" === e && (e = [], i < a && (n = t.slice(0, i), e = t.slice(i, a), this.chatListCache = e.concat(this.chatListCache))), n
              }
            }, {
              key: "realUpdateChatList",
              value: function (t) {
                if (this.isInbottom) {
                  if (0 < this.chatListCache.length) return;
                  var e = this.chatList.concat(t),
                    e = this.msgAbandon(e);
                  this.chatList = m(e), this.MsgListEventemitter.emit(Ct.CHATLIST_UPDATE), this.MsgListEventemitter.emit(Ct.CHATLIST_CACHE_UPDATE, 0)
                } else this.chatList.length < this.chatListMaxSize ? (this.chatList = this.chatList.concat(t), this.MsgListEventemitter.emit(Ct.CHATLIST_UPDATE), this.MsgListEventemitter.emit(Ct.CHATLIST_CACHE_UPDATE, 0)) : (this.chatListCache = this.chatListCache.concat(t), this.MsgListEventemitter.emit(Ct.CHATLIST_CACHE_UPDATE, this.chatListCache.length));
                this.chatListCache.length > this.chatListMaxCacheSize && this.clickToBottomHandle()
              }
            }, {
              key: "isNeedAnimationHandle",
              value: function (t) {
                t && (3 <= t.length ? this.MsgListEventemitter.emit(Ct.NEED_ANNIMATION, !1) : this.MsgListEventemitter.emit(Ct.NEED_ANNIMATION, !0))
              }
            }]), r
          }(), {
            VideoPlayer: nt,
            MsgList: l(l({
              Component: e
            }, {
              MsgListContoller: W
            }), {}, {
              MsgListEventemitter: wt,
              TYPE: Ct
            })
          }
        }(r("q1tI"), r("vOnD"))
      }).call(this, r("yLpj"))
    },
    vOnD: function (t, Vt, zt) {
      "use strict";
      zt.r(Vt),
        function (t) {
          zt.d(Vt, "ServerStyleSheet", function () {
            return Ut
          }), zt.d(Vt, "StyleSheetConsumer", function () {
            return rt
          }), zt.d(Vt, "StyleSheetContext", function () {
            return et
          }), zt.d(Vt, "StyleSheetManager", function () {
            return lt
          }), zt.d(Vt, "ThemeConsumer", function () {
            return Ct
          }), zt.d(Vt, "ThemeContext", function () {
            return kt
          }), zt.d(Vt, "ThemeProvider", function () {
            return wt
          }), zt.d(Vt, "__PRIVATE__", function () {
            return Gt
          }), zt.d(Vt, "createGlobalStyle", function () {
            return Mt
          }), zt.d(Vt, "css", function () {
            return yt
          }), zt.d(Vt, "isStyledComponent", function () {
            return L
          }), zt.d(Vt, "keyframes", function () {
            return Nt
          }), zt.d(Vt, "useTheme", function () {
            return Ht
          }), zt.d(Vt, "version", function () {
            return r
          }), zt.d(Vt, "withTheme", function () {
            return Bt
          });
          var a = zt("TOwV"),
            p = zt("q1tI"),
            c = zt.n(p),
            e = zt("Gytx"),
            s = zt.n(e),
            f = zt("0x0X"),
            l = zt("ME5O"),
            y = zt("9uj6"),
            e = zt("2mql"),
            g = zt.n(e);

          function E() {
            return (E = Object.assign || function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var r, i = arguments[e];
                for (r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
              }
              return t
            }).apply(this, arguments)
          }
          var n = function (t, e) {
              for (var r = [t[0]], i = 0, n = e.length; i < n; i += 1) r.push(e[i], t[i + 1]);
              return r
            },
            u = function (t) {
              return null !== t && "object" == typeof t && "[object Object]" === (t.toString ? t.toString() : Object.prototype.toString.call(t)) && !Object(a.typeOf)(t)
            },
            m = Object.freeze([]),
            b = Object.freeze({});

          function S(t) {
            return "function" == typeof t
          }

          function _(t) {
            return t.displayName || t.name || "Component"
          }

          function L(t) {
            return t && "string" == typeof t.styledComponentId
          }
          var h = void 0 !== t && (Object({
              RUN_ENV: "production",
              MWEBSVR: "https://m.mildom.com",
              WIASVR: "https://wia.mildom.com"
            }).REACT_APP_SC_ATTR || Object({
              RUN_ENV: "production",
              MWEBSVR: "https://m.mildom.com",
              WIASVR: "https://wia.mildom.com"
            }).SC_ATTR) || "data-styled",
            r = "5.2.3",
            i = "undefined" != typeof window && "HTMLElement" in window,
            e = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : void 0 !== t && void 0 !== Object({
              RUN_ENV: "production",
              MWEBSVR: "https://m.mildom.com",
              WIASVR: "https://wia.mildom.com"
            }).REACT_APP_SC_DISABLE_SPEEDY && "" !== Object({
              RUN_ENV: "production",
              MWEBSVR: "https://m.mildom.com",
              WIASVR: "https://wia.mildom.com"
            }).REACT_APP_SC_DISABLE_SPEEDY ? "false" !== Object({
              RUN_ENV: "production",
              MWEBSVR: "https://m.mildom.com",
              WIASVR: "https://wia.mildom.com"
            }).REACT_APP_SC_DISABLE_SPEEDY && Object({
              RUN_ENV: "production",
              MWEBSVR: "https://m.mildom.com",
              WIASVR: "https://wia.mildom.com"
            }).REACT_APP_SC_DISABLE_SPEEDY : void 0 !== t && void 0 !== Object({
              RUN_ENV: "production",
              MWEBSVR: "https://m.mildom.com",
              WIASVR: "https://wia.mildom.com"
            }).SC_DISABLE_SPEEDY && "" !== Object({
              RUN_ENV: "production",
              MWEBSVR: "https://m.mildom.com",
              WIASVR: "https://wia.mildom.com"
            }).SC_DISABLE_SPEEDY && ("false" !== Object({
              RUN_ENV: "production",
              MWEBSVR: "https://m.mildom.com",
              WIASVR: "https://wia.mildom.com"
            }).SC_DISABLE_SPEEDY && Object({
              RUN_ENV: "production",
              MWEBSVR: "https://m.mildom.com",
              WIASVR: "https://wia.mildom.com"
            }).SC_DISABLE_SPEEDY)),
            v = {};

          function T(t) {
            for (var e = arguments.length, r = new Array(1 < e ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];
            throw new Error("An error occurred. See https://git.io/JUIaE#" + t + " for more information." + (0 < r.length ? " Args: " + r.join(", ") : ""))
          }

          function o(t) {
            if (C.has(t)) return C.get(t);
            for (; w.has(x);) x++;
            var e = x++;
            return C.set(t, e), w.set(e, t), e
          }

          function d(t, e) {
            for (var r, i, n = e.innerHTML.split("/*!sc*/\n"), a = [], s = 0, o = n.length; s < o; s++) {
              var l, u, h, d = n[s].trim();
              d && ((l = d.match(O)) ? (u = 0 | parseInt(l[1], 10), h = l[2], 0 != u && (r = h, i = u, C.set(r, i), w.set(i, r), function (t, e) {
                for (var r, i = l[3].split(","), n = 0, a = i.length; n < a; n++)(r = i[n]) && t.registerName(e, r)
              }(t, h), t.getTag().insertRules(u, a)), a.length = 0) : a.push(d))
            }
          }

          function A() {
            return "undefined" != typeof window && void 0 !== window.__webpack_nonce__ ? window.__webpack_nonce__ : null
          }

          function R(t) {
            var e = document.head,
              i = t || e,
              r = document.createElement("style"),
              e = void 0 !== (t = function () {
                for (var t = i.childNodes, e = t.length; 0 <= e; e--) {
                  var r = t[e];
                  if (r && 1 === r.nodeType && r.hasAttribute(h)) return r
                }
              }()) ? t.nextSibling : null;
            return r.setAttribute(h, "active"), r.setAttribute("data-styled-version", "5.2.3"), (t = A()) && r.setAttribute("nonce", t), i.insertBefore(r, e), r
          }

          function D(t) {
            return String.fromCharCode(t + (25 < t ? 39 : 97))
          }
          var k = ((t = z.prototype).indexOfGroup = function (t) {
              for (var e = 0, r = 0; r < t; r++) e += this.groupSizes[r];
              return e
            }, t.insertRules = function (t, e) {
              if (t >= this.groupSizes.length) {
                for (var r = this.groupSizes, i = r.length, n = i; n <= t;)(n <<= 1) < 0 && T(16, "" + t);
                this.groupSizes = new Uint32Array(n), this.groupSizes.set(r), this.length = n;
                for (var a = i; a < n; a++) this.groupSizes[a] = 0
              }
              for (var s = this.indexOfGroup(t + 1), o = 0, l = e.length; o < l; o++) this.tag.insertRule(s, e[o]) && (this.groupSizes[t]++, s++)
            }, t.clearGroup = function (t) {
              if (t < this.length) {
                var e = this.groupSizes[t],
                  r = this.indexOfGroup(t),
                  i = r + e;
                this.groupSizes[t] = 0;
                for (var n = r; n < i; n++) this.tag.deleteRule(r)
              }
            }, t.getGroup = function (t) {
              var e = "";
              if (t >= this.length || 0 === this.groupSizes[t]) return e;
              for (var r = this.groupSizes[t], t = this.indexOfGroup(t), i = t + r, n = t; n < i; n++) e += this.tag.getRule(n) + "/*!sc*/\n";
              return e
            }, z),
            C = new Map,
            w = new Map,
            x = 1,
            P = "style[" + h + '][data-styled-version="5.2.3"]',
            O = new RegExp("^" + h + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'),
            F = ((t = V.prototype).insertRule = function (t, e) {
              try {
                return this.sheet.insertRule(e, t), this.length++, !0
              } catch (t) {
                return !1
              }
            }, t.deleteRule = function (t) {
              this.sheet.deleteRule(t), this.length--
            }, t.getRule = function (t) {
              t = this.sheet.cssRules[t];
              return void 0 !== t && "string" == typeof t.cssText ? t.cssText : ""
            }, V),
            I = ((t = j.prototype).insertRule = function (t, e) {
              if (t <= this.length && 0 <= t) {
                e = document.createTextNode(e), t = this.nodes[t];
                return this.element.insertBefore(e, t || null), this.length++, !0
              }
              return !1
            }, t.deleteRule = function (t) {
              this.element.removeChild(this.nodes[t]), this.length--
            }, t.getRule = function (t) {
              return t < this.length ? this.nodes[t].textContent : ""
            }, j),
            M = ((t = G.prototype).insertRule = function (t, e) {
              return t <= this.length && (this.rules.splice(t, 0, e), this.length++, !0)
            }, t.deleteRule = function (t) {
              this.rules.splice(t, 1), this.length--
            }, t.getRule = function (t) {
              return t < this.length ? this.rules[t] : ""
            }, G),
            N = i,
            U = {
              isServer: !i,
              useCSSOMInjection: !e
            },
            B = function () {
              function r(t, e, r) {
                void 0 === t && (t = b), void 0 === e && (e = {}), this.options = E({}, U, {}, t), this.gs = e, this.names = new Map(r), !this.options.isServer && i && N && (N = !1, function (t) {
                  for (var e = document.querySelectorAll(P), r = 0, i = e.length; r < i; r++) {
                    var n = e[r];
                    n && "active" !== n.getAttribute(h) && (d(t, n), n.parentNode && n.parentNode.removeChild(n))
                  }
                }(this))
              }
              r.registerId = o;
              var t = r.prototype;
              return t.reconstructWithOptions = function (t, e) {
                return void 0 === e && (e = !0), new r(E({}, this.options, {}, t), this.gs, e && this.names || void 0)
              }, t.allocateGSInstance = function (t) {
                return this.gs[t] = (this.gs[t] || 0) + 1
              }, t.getTag = function () {
                return this.tag || (this.tag = (t = (r = this.options).isServer, e = r.useCSSOMInjection, r = r.target, r = new(t ? M : e ? F : I)(r), new k(r)));
                var t, e, r
              }, t.hasNameForId = function (t, e) {
                return this.names.has(t) && this.names.get(t).has(e)
              }, t.registerName = function (t, e) {
                var r;
                o(t), this.names.has(t) ? this.names.get(t).add(e) : ((r = new Set).add(e), this.names.set(t, r))
              }, t.insertRules = function (t, e, r) {
                this.registerName(t, e), this.getTag().insertRules(o(t), r)
              }, t.clearNames = function (t) {
                this.names.has(t) && this.names.get(t).clear()
              }, t.clearRules = function (t) {
                this.getTag().clearGroup(o(t)), this.clearNames(t)
              }, t.clearTag = function () {
                this.tag = void 0
              }, t.toString = function () {
                return function (t) {
                  for (var e = t.getTag(), r = e.length, i = "", n = 0; n < r; n++) {
                    var a, s, o, l = (s = n, w.get(s));
                    void 0 !== l && (a = t.names.get(l), s = e.getGroup(n), void 0 !== a && 0 !== s.length && (l = h + ".g" + n + '[id="' + l + '"]', o = "", void 0 !== a && a.forEach(function (t) {
                      0 < t.length && (o += t + ",")
                    }), i += s + l + '{content:"' + o + '"}/*!sc*/\n'))
                  }
                  return i
                }(this)
              }, r
            }(),
            H = /(a)(d)/gi;

          function G(t) {
            this.rules = [], this.length = 0
          }

          function j(t) {
            t = this.element = R(t);
            this.nodes = t.childNodes, this.length = 0
          }

          function V(t) {
            t = this.element = R(t);
            t.appendChild(document.createTextNode("")), this.sheet = function (t) {
              if (t.sheet) return t.sheet;
              for (var e = document.styleSheets, r = 0, i = e.length; r < i; r++) {
                var n = e[r];
                if (n.ownerNode === t) return n
              }
              T(17)
            }(t), this.length = 0
          }

          function z(t) {
            this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = t
          }

          function q(t) {
            for (var e = "", r = Math.abs(t); 52 < r; r = r / 52 | 0) e = D(r % 52) + e;
            return (D(r % 52) + e).replace(H, "$1-$2")
          }

          function K(t) {
            return W(5381, t)
          }
          var W = function (t, e) {
            for (var r = e.length; r;) t = 33 * t ^ e.charCodeAt(--r);
            return t
          };

          function Y(t) {
            for (var e = 0; e < t.length; e += 1) {
              var r = t[e];
              if (S(r) && !L(r)) return !1
            }
            return !0
          }
          var X = K("5.2.3"),
            $ = (Z.prototype.generateAndInjectStyles = function (t, e, r) {
              var i, n = this.componentId,
                a = [];
              if (this.baseStyle && a.push(this.baseStyle.generateAndInjectStyles(t, e, r)), this.isStatic && !r.hash) this.staticRulesId && e.hasNameForId(n, this.staticRulesId) ? a.push(this.staticRulesId) : (i = pt(this.rules, t, e, r).join(""), o = q(W(this.baseHash, i.length) >>> 0), e.hasNameForId(n, o) || (s = r(i, "." + o, void 0, n), e.insertRules(n, o, s)), a.push(o), this.staticRulesId = o);
              else {
                for (var s, o, l = this.rules.length, u = W(this.baseHash, r.hash), h = "", d = 0; d < l; d++) {
                  var c = this.rules[d];
                  "string" == typeof c ? h += c : c && (c = pt(c, t, e, r), c = Array.isArray(c) ? c.join("") : c, u = W(u, c + d), h += c)
                }
                h && (s = q(u >>> 0), e.hasNameForId(n, s) || (o = r(h, "." + s, void 0, n), e.insertRules(n, s, o)), a.push(s))
              }
              return a.join(" ")
            }, Z),
            Q = /^\s*\/\/.*$/gm,
            J = [":", "[", ".", "#"];

          function Z(t, e, r) {
            this.rules = t, this.staticRulesId = "", this.isStatic = (void 0 === r || r.isStatic) && Y(t), this.componentId = e, this.baseHash = W(X, e), this.baseStyle = r, B.registerId(e)
          }

          function tt(t) {
            function i(t, e, r) {
              return 0 === e && -1 !== J.indexOf(r[a.length]) || r.match(o) ? t : "." + n
            }
            var n, a, s, o, h, e = void 0 === t ? b : t,
              t = e.options,
              t = void 0 === t ? b : t,
              e = e.plugins,
              e = void 0 === e ? m : e,
              l = new f.a(t),
              r = [],
              t = (h = function (t) {
                r.push(t)
              }, function (t, e, r, i, n, a, s, o, l, u) {
                switch (t) {
                case 1:
                  if (0 === l && 64 === e.charCodeAt(0)) return h(e + ";"), "";
                  break;
                case 2:
                  if (0 === o) return e + "/*|*/";
                  break;
                case 3:
                  switch (o) {
                  case 102:
                  case 112:
                    return h(r[0] + e), "";
                  default:
                    return e + (0 === u ? "/*|*/" : "")
                  }
                case -2:
                  e.split("/*|*/}").forEach(d)
                }
              });

            function d(t) {
              if (t) try {
                h(t + "}")
              } catch (t) {}
            }

            function u(t, e, r, i) {
              void 0 === i && (i = "&");
              t = t.replace(Q, ""), t = e && r ? r + " " + e + " { " + t + " }" : t;
              return n = i, a = e, s = new RegExp("\\" + a + "\\b", "g"), o = new RegExp("(\\" + a + "\\b){2,}"), l(r || !e ? "" : e, t)
            }
            return l.use([].concat(e, [function (t, e, r) {
              2 === t && r.length && 0 < r[0].lastIndexOf(a) && (r[0] = r[0].replace(s, i))
            }, t, function (t) {
              if (-2 === t) {
                t = r;
                return r = [], t
              }
            }])), u.hash = e.length ? e.reduce(function (t, e) {
              return e.name || T(15), W(t, e.name)
            }, 5381).toString() : "", u
          }
          var et = c.a.createContext(),
            rt = et.Consumer,
            it = c.a.createContext(),
            nt = (it.Consumer, new B),
            at = tt();

          function st() {
            return Object(p.useContext)(et) || nt
          }

          function ot() {
            return Object(p.useContext)(it) || at
          }

          function lt(e) {
            var t = Object(p.useState)(e.stylisPlugins),
              r = t[0],
              i = t[1],
              n = st(),
              a = Object(p.useMemo)(function () {
                var t = n;
                return e.sheet ? t = e.sheet : e.target && (t = t.reconstructWithOptions({
                  target: e.target
                }, !1)), e.disableCSSOMInjection && (t = t.reconstructWithOptions({
                  useCSSOMInjection: !1
                })), t
              }, [e.disableCSSOMInjection, e.sheet, e.target]),
              t = Object(p.useMemo)(function () {
                return tt({
                  options: {
                    prefix: !e.disableVendorPrefixes
                  },
                  plugins: r
                })
              }, [e.disableVendorPrefixes, r]);
            return Object(p.useEffect)(function () {
              s()(r, e.stylisPlugins) || i(e.stylisPlugins)
            }, [e.stylisPlugins]), c.a.createElement(et.Provider, {
              value: a
            }, c.a.createElement(it.Provider, {
              value: t
            }, e.children))
          }
          var ut = (gt.prototype.getName = function (t) {
              return void 0 === t && (t = at), this.name + t.hash
            }, gt),
            ht = /([A-Z])/,
            dt = /([A-Z])/g,
            ct = /^ms-/,
            ft = function (t) {
              return "-" + t.toLowerCase()
            };

          function gt(t, e) {
            var i = this;
            this.inject = function (t, e) {
              void 0 === e && (e = at);
              var r = i.name + e.hash;
              t.hasNameForId(i.id, r) || t.insertRules(i.id, r, e(i.rules, r, "@keyframes"))
            }, this.toString = function () {
              return T(12, String(i.name))
            }, this.name = t, this.id = "sc-keyframes-" + t, this.rules = e
          }

          function mt(t) {
            return ht.test(t) ? t.replace(dt, ft).replace(ct, "-ms-") : t
          }
          var vt = function (t) {
            return null == t || !1 === t || "" === t
          };

          function pt(t, e, r, i) {
            if (Array.isArray(t)) {
              for (var n, a = [], s = 0, o = t.length; s < o; s += 1) "" !== (n = pt(t[s], e, r, i)) && (Array.isArray(n) ? a.push.apply(a, n) : a.push(n));
              return a
            }
            return vt(t) ? "" : L(t) ? "." + t.styledComponentId : S(t) ? "function" != typeof t || t.prototype && t.prototype.isReactComponent || !e ? t : pt(t(e), e, r, i) : t instanceof ut ? r ? (t.inject(r, i), t.getName(i)) : t : u(t) ? function t(e, r) {
              var i, n, a, s = [];
              for (a in e) e.hasOwnProperty(a) && !vt(e[a]) && (u(e[a]) ? s.push.apply(s, t(e[a], a)) : S(e[a]) ? s.push(mt(a) + ":", e[a], ";") : s.push(mt(a) + ": " + (i = a, null == (n = e[a]) || "boolean" == typeof n || "" === n ? "" : "number" != typeof n || 0 === n || i in l.a ? String(n).trim() : n + "px") + ";"));
              return r ? [r + " {"].concat(s, ["}"]) : s
            }(t) : t.toString()
          }

          function yt(t) {
            for (var e = arguments.length, r = new Array(1 < e ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];
            return S(t) || u(t) ? pt(n(m, [t].concat(r))) : 0 === r.length && 1 === t.length && "string" == typeof t[0] ? t : pt(n(t, r))
          }
          new Set;
          var Et = function (t, e, r) {
              return void 0 === r && (r = b), t.theme !== r.theme && t.theme || e || r.theme
            },
            bt = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,
            St = /(^-|-$)/g;

          function _t(t) {
            return t.replace(bt, "-").replace(St, "")
          }
          var Lt = function (t) {
            return q(K(t) >>> 0)
          };

          function Tt(t) {
            return "string" == typeof t && !0
          }
          var At = function (t) {
              return "function" == typeof t || "object" == typeof t && null !== t && !Array.isArray(t)
            },
            Rt = function (t) {
              return "__proto__" !== t && "constructor" !== t && "prototype" !== t
            };

          function Dt(t) {
            for (var e = arguments.length, r = new Array(1 < e ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];
            for (var n, a, s, o, l = 0, u = r; l < u.length; l++) {
              var h = u[l];
              if (At(h))
                for (var d in h) Rt(d) && (n = t, a = h[d], s = d, o = void 0, o = n[s], At(a) && At(o) ? Dt(o, a) : n[s] = a)
            }
            return t
          }
          var kt = c.a.createContext(),
            Ct = kt.Consumer;

          function wt(r) {
            var i = Object(p.useContext)(kt),
              t = Object(p.useMemo)(function () {
                return t = r.theme, e = i, t ? S(t) ? t(e) : Array.isArray(t) || "object" != typeof t ? T(8) : e ? E({}, e, {}, t) : t : T(14);
                var t, e
              }, [r.theme, i]);
            return r.children ? c.a.createElement(kt.Provider, {
              value: t
            }, r.children) : null
          }
          var xt = {};

          function Pt(r, i, n) {
            var e = L(r),
              t = !Tt(r),
              a = i.attrs,
              s = void 0 === a ? m : a,
              o = i.componentId,
              l = void 0 === o ? function (t, e) {
                t = "string" != typeof t ? "sc" : _t(t);
                xt[t] = (xt[t] || 0) + 1;
                t = t + "-" + Lt("5.2.3" + t + xt[t]);
                return e ? e + "-" + t : t
              }(i.displayName, i.parentComponentId) : o,
              u = i.displayName,
              a = void 0 === u ? Tt(r) ? "styled." + r : "Styled(" + _(r) + ")" : u,
              o = i.displayName && i.componentId ? _t(i.displayName) + "-" + i.componentId : i.componentId || l,
              h = e && r.attrs ? Array.prototype.concat(r.attrs, s).filter(Boolean) : s,
              u = i.shouldForwardProp;
            e && r.shouldForwardProp && (u = i.shouldForwardProp ? function (t, e) {
              return r.shouldForwardProp(t, e) && i.shouldForwardProp(t, e)
            } : r.shouldForwardProp);
            var v, l = new $(n, o, e ? r.componentStyle : void 0),
              d = l.isStatic && 0 === s.length,
              s = function (t, e) {
                return function (r, t, e) {
                  var i, n = v.attrs,
                    a = v.componentStyle,
                    s = v.defaultProps,
                    o = v.foldedComponentIds,
                    l = v.shouldForwardProp,
                    u = v.styledComponentId,
                    h = v.target,
                    d = function (t, e) {
                      void 0 === t && (t = b);
                      var a = E({}, r, {
                          theme: t
                        }),
                        s = {};
                      return e.forEach(function (t) {
                        var e, r, i, n = t;
                        for (e in S(n) && (n = n(a)), n) a[e] = s[e] = "className" === e ? (r = s[e], i = n[e], r && i ? r + " " + i : r || i) : n[e]
                      }), [a, s]
                    }(Et(r, Object(p.useContext)(kt), s) || b, n),
                    c = d[0],
                    s = d[1],
                    c = (n = a, d = e, a = c, e = st(), c = ot(), d ? n.generateAndInjectStyles(b, e, c) : n.generateAndInjectStyles(a, e, c)),
                    t = t,
                    h = s.$as || r.$as || s.as || r.as || h,
                    f = Tt(h),
                    g = s !== r ? E({}, r, {}, s) : r,
                    m = {};
                  for (i in g) "$" !== i[0] && "as" !== i && ("forwardedAs" === i ? m.as = g[i] : (l ? l(i, y.default) : !f || Object(y.default)(i)) && (m[i] = g[i]));
                  return r.style && s.style !== r.style && (m.style = E({}, r.style, {}, s.style)), m.className = Array.prototype.concat(o, u, c !== u ? c : null, r.className, s.className).filter(Boolean).join(" "), m.ref = t, Object(p.createElement)(h, m)
                }(t, e, d)
              };
            return s.displayName = a, (v = c.a.forwardRef(s)).attrs = h, v.componentStyle = l, v.displayName = a, v.shouldForwardProp = u, v.foldedComponentIds = e ? Array.prototype.concat(r.foldedComponentIds, r.styledComponentId) : m, v.styledComponentId = o, v.target = e ? r.target : r, v.withComponent = function (t) {
              var e = i.componentId,
                r = function (t, e) {
                  if (null == t) return {};
                  for (var r, i = {}, n = Object.keys(t), a = 0; a < n.length; a++) r = n[a], 0 <= e.indexOf(r) || (i[r] = t[r]);
                  return i
                }(i, ["componentId"]),
                e = e && e + "-" + (Tt(t) ? t : _t(_(t)));
              return Pt(t, E({}, r, {
                attrs: h,
                componentId: e
              }), n)
            }, Object.defineProperty(v, "defaultProps", {
              get: function () {
                return this._foldedDefaultProps
              },
              set: function (t) {
                this._foldedDefaultProps = e ? Dt({}, r.defaultProps, t) : t
              }
            }), v.toString = function () {
              return "." + v.styledComponentId
            }, t && g()(v, r, {
              attrs: !0,
              componentStyle: !0,
              displayName: !0,
              foldedComponentIds: !0,
              shouldForwardProp: !0,
              styledComponentId: !0,
              target: !0,
              withComponent: !0
            }), v
          }

          function Ot(t) {
            return function e(r, i, n) {
              if (void 0 === n && (n = b), !Object(a.isValidElementType)(i)) return T(1, String(i));

              function t() {
                return r(i, n, yt.apply(void 0, arguments))
              }
              return t.withConfig = function (t) {
                return e(r, i, E({}, n, {}, t))
              }, t.attrs = function (t) {
                return e(r, i, E({}, n, {
                  attrs: Array.prototype.concat(n.attrs, t).filter(Boolean)
                }))
              }, t
            }(Pt, t)
          }["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"].forEach(function (t) {
            Ot[t] = Ot(t)
          });
          var Ft = ((e = It.prototype).createStyles = function (t, e, r, i) {
            i = i(pt(this.rules, e, r, i).join(""), ""), t = this.componentId + t;
            r.insertRules(t, t, i)
          }, e.removeStyles = function (t, e) {
            e.clearRules(this.componentId + t)
          }, e.renderStyles = function (t, e, r, i) {
            2 < t && B.registerId(this.componentId + t), this.removeStyles(t, r), this.createStyles(t, e, r, i)
          }, It);

          function It(t, e) {
            this.rules = t, this.componentId = e, this.isStatic = Y(t), B.registerId(this.componentId + 1)
          }

          function Mt(t) {
            for (var e = arguments.length, r = new Array(1 < e ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];
            var t = yt.apply(void 0, [t].concat(r)),
              n = "sc-global-" + Lt(JSON.stringify(t)),
              h = new Ft(t, n);

            function d(a) {
              var s = st(),
                o = ot(),
                l = Object(p.useContext)(kt),
                u = Object(p.useRef)(s.allocateGSInstance(n)).current;
              return Object(p.useLayoutEffect)(function () {
                return t = u, e = a, r = s, i = l, n = o, h.isStatic ? h.renderStyles(t, v, r, n) : (i = E({}, e, {
                    theme: Et(e, i, d.defaultProps)
                  }), h.renderStyles(t, i, r, n)),
                  function () {
                    return h.removeStyles(u, s)
                  };
                var t, e, r, i, n
              }, [u, a, s, l, o]), null
            }
            return c.a.memo(d)
          }

          function Nt(t) {
            for (var e = arguments.length, r = new Array(1 < e ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];
            var n = yt.apply(void 0, [t].concat(r)).join(""),
              t = Lt(n);
            return new ut(t, n)
          }
          var Ut = ((e = jt.prototype).collectStyles = function (t) {
              return this.sealed ? T(2) : c.a.createElement(lt, {
                sheet: this.instance
              }, t)
            }, e.interleaveWithNodeStream = function (t) {
              return T(3)
            }, jt),
            Bt = function (n) {
              var t = c.a.forwardRef(function (t, e) {
                var r = Object(p.useContext)(kt),
                  i = n.defaultProps,
                  i = Et(t, r, i);
                return c.a.createElement(n, E({}, t, {
                  theme: i,
                  ref: e
                }))
              });
              return g()(t, n), t.displayName = "WithTheme(" + _(n) + ")", t
            },
            Ht = function () {
              return Object(p.useContext)(kt)
            },
            Gt = {
              StyleSheet: B,
              masterSheet: nt
            };

          function jt() {
            var r = this;
            this._emitSheetCSS = function () {
              var t = r.instance.toString(),
                e = A();
              return "<style " + [e && 'nonce="' + e + '"', h + '="true"', 'data-styled-version="5.2.3"'].filter(Boolean).join(" ") + ">" + t + "</style>"
            }, this.getStyleTags = function () {
              return r.sealed ? T(2) : r._emitSheetCSS()
            }, this.getStyleElement = function () {
              if (r.sealed) return T(2);
              var t = ((e = {})[h] = "", e["data-styled-version"] = "5.2.3", e.dangerouslySetInnerHTML = {
                  __html: r.instance.toString()
                }, e),
                e = A();
              return e && (t.nonce = e), [c.a.createElement("style", E({}, t, {
                key: "sc-0-0"
              }))]
            }, this.seal = function () {
              r.sealed = !0
            }, this.instance = new B({
              isServer: !0
            }), this.sealed = !1
          }
          Vt.default = Ot
        }.call(this, zt("8oxB"))
    }
  }
]);
//# sourceMappingURL=http://hw-source-map.mildom.jp/mildompc-web-server-sourcemap/static_sourcemap/vendors~entry~pre_liveroom_c51cf7c4d219cf486e21.js.map